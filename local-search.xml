<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>我的2022</title>
    <link href="/2023/01/21/%E6%88%91%E7%9A%842022/"/>
    <url>/2023/01/21/%E6%88%91%E7%9A%842022/</url>
    
    <content type="html"><![CDATA[<h2 id="最是人间留不住，朱颜辞镜花辞树。"><a href="#最是人间留不住，朱颜辞镜花辞树。" class="headerlink" title="最是人间留不住，朱颜辞镜花辞树。"></a>最是人间留不住，朱颜辞镜花辞树。</h2><p>今天是一年的最后一天了，今晚过完就是癸卯兔年了。回顾2022全年，最开心的事情莫过于阿根廷夺冠，messi终圆童话梦,<br>也让我多年的青春和执念有始有终了。糟心的事情则是国内放开后家人相继中招，元旦时我和媳妇在这边也莫名中招了，家<br>里就剩小贝儿和母亲没被感染，真心希望这疫情赶紧早点结束，早点恢复正常的通航。工作上，今年好像干的挺杂乱的，一<br>会是java，一会是powershell，一会又是c++，东一榔头西一棒槌，技术上感觉什么都没学到。。。今年工作之余抽时间看<br>完的书有&lt;&lt;Essential C++&gt;&gt;、&lt;&lt;C++ Primer Plus&gt;&gt;这两本，&lt;&lt;计算机系统要素&gt;&gt;这本书看了有一半吧，但是感觉这本<br>书给我的受益最大，跟着这本书可以从硬件一直构建到操作系统和编程语言的实现，因为看到一半，所以我现在只做到虚拟<br>机实现的上半部分。&lt;&lt;java虚拟机规范&gt;&gt;看了两章、&lt;&lt;数据密集型应用系统设计&gt;&gt;看了一章、&lt;&lt;Vim实用技巧&gt;&gt;看了三<br>章、&lt;&lt;剑指offer&gt;&gt;也看了一章多、&lt;&lt;Linux C&#x2F;C++ &gt;&gt;看到第五章，&lt;&lt;百年孤独&gt;&gt;看了几十页，工作之余看书都比较随<br>意，所以把每本书看的都很零碎，希望新的一年可以改掉这个毛病吧，也希望自己能加把劲把这些书都啃完吧！<br>   最后，祝每个人新年健康平安快乐，得偿所愿！</p>]]></content>
    
    
    <categories>
      
      <category>生活</category>
      
    </categories>
    
    
    <tags>
      
      <tag>年终回顾</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>linux系统调用下的文件I/O</title>
    <link href="/2023/01/15/linux%E6%96%87%E4%BB%B6io/"/>
    <url>/2023/01/15/linux%E6%96%87%E4%BB%B6io/</url>
    
    <content type="html"><![CDATA[<h2 id="关于I-x2F-O"><a href="#关于I-x2F-O" class="headerlink" title="关于I&#x2F;O"></a>关于I&#x2F;O</h2><p>I&#x2F;O就是输入&#x2F;输出，它是主存和外部设备（比如硬盘、U盘）之间复制数据的过程，其中数据从设备到内存的过程<br>称为输入，数据从内存到设备的过程叫输出，I&#x2F;O可以分为高级I&#x2F;O和低级I&#x2F;O，高级I&#x2F;O通常也称为带缓冲的I&#x2F;O，<br>比如ANSI C提供的标准I&#x2F;O库。低级I&#x2F;O通常也称为不带缓冲的I&#x2F;O，它是linux提供的系统调用，速度快，如函数<br>open、read、write等。而带缓冲的I&#x2F;O在系统调用前采用一定的策略，速度慢，但比不带缓冲的I&#x2F;O安全，如fopen、<br>fread、fwrite等。在linux下对文件进行输入输出操作有3种编程方式，一种是调用C库中文件的I&#x2F;O函数，比如<br>fopen、fread&#x2F;fwrite、fclose等，另外两种方式是使用linux的系统调用和C++文件流的操作。</p><h2 id="I-x2F-O相关函数"><a href="#I-x2F-O相关函数" class="headerlink" title="I&#x2F;O相关函数"></a>I&#x2F;O相关函数</h2><h4 id="文件描述符"><a href="#文件描述符" class="headerlink" title="文件描述符"></a>文件描述符</h4><p>对于linux而言，所有设备或文件的操作都是通过文件描述符进行的。当打开或者创建一个文件的时候，内核向进<br>程返回一个非负的文件描述符。后续对文件的操作只需要通过该文件描述符，内核记录有关这个打开文件的信息。<br>一个进程启动时，默认打开三个文件，标准输入、标准输出、标准错误，对应文件描述符是0（STDIN_FILENO）、<br>1（STDOUT_FILENO）、2（STDERR_FILENO）,这些常量定义在unistd.h头文件中。文件描述符和文件指针可以互相<br>转换，具体通过函数fileno和fdopen。函数fileno将文件指针转为文件描述符，函数声明如下:</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fileno</span><span class="hljs-params">(FILE *stream)</span></span>;<br></code></pre></td></tr></table></figure><p>其中，参数stream是文件指针。<br>函数fdopen将文件描述符转换为文件指针，声明如下：    </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">FILE *<span class="hljs-title">fdopen</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *mode)</span></span>;<br></code></pre></td></tr></table></figure><p>其中，参数fd是文件描述符，mode是打开方式。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;fileno(stdin) = %d\n&quot;</span>,<span class="hljs-built_in">fileno</span>(stdin));<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;fileno(stdout) = %d\n&quot;</span>,<span class="hljs-built_in">fileno</span>(stdout));<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;fileno(stderr) = %d\n&quot;</span>,<span class="hljs-built_in">fileno</span>(stderr));<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>编译运行：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">fileno(stdin) <span class="hljs-operator">=</span> <span class="hljs-number">0</span><span class="hljs-comment">;</span><br>fileno(stdout) <span class="hljs-operator">=</span> <span class="hljs-number">1</span><span class="hljs-comment">;</span><br>fileno(stderr) <span class="hljs-operator">=</span> <span class="hljs-number">2</span><span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><h4 id="打开或创建文件"><a href="#打开或创建文件" class="headerlink" title="打开或创建文件"></a>打开或创建文件</h4><p>linux提供open函数来打开或者创建一个文件。该函数声明如下：   </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">open</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *pathname, <span class="hljs-type">int</span> flags)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">open</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *pathname, <span class="hljs-type">int</span> flags, <span class="hljs-type">mode_t</span> mode)</span></span>;<br></code></pre></td></tr></table></figure><p>其中，参数pathname表示文件的名称，可以包含（绝对和相对）路径；flags表示文件打开方式；mode用来规定对该文件的<br>所有者、文件的用户组及系统中其他用户的访问权限。如果函数执行成功，就返回文件描述符，如果函数执行失败就返回-1.<br>文件打开的方式flags可以使用下列宏（当有多个选项时，采用“|”连接）： </p><blockquote><ul><li>O_RDONLY: 打开一个只供读取的文件。</li><li>O_WRONLY: 打开一个只供写入的文件。</li><li>O_RDWR: 打开一个可供读写的文件。</li><li>O_APPEND: 写入的所有数据将被追加到文件的末尾。</li><li>O_CREAT: 打开文件，如果文件不存在就建立文件。</li><li>O_EXCL: 如果已经置O_CREAT且文件存在，就强制open失败。</li><li>O_TRUNC: 在打开文件时，将文件的内容清。</li><li>O_DSYNC: 每次写入时，等待数据写到磁盘上。</li><li>O_RSYNC: 每次读取时，等待相同部分先写到磁盘上。</li><li>O_SYNC: 以同步方式写入文件，强制刷新内核缓冲区到输出文件。</li></ul></blockquote><p>最后三个SYNC（同步）选项都会降低性能，使用这些宏需要包含头文件fcntl.h。O_RDONLY、O_WRONLY或O_RDWR<br>这三个选项是必选一个的。mode只有创建文件时才使用此参数，指定文件的访问权限。模式包含以下:  </p><blockquote><ul><li>S_IRUSR: 文件所有者的读权限位。</li><li>S_IWUSR: 文件所有者的写权限位。</li><li>S_IXUSR: 文件所有者的执行权限位。</li><li>S_IRWXU: S_IRUSR | S_IWUSR | S_IXUSR。</li><li>S_IRGRP: 文件用户组的读权限位。</li><li>S_IWGRP: 文件用户组的写权限位。</li><li>S_IXGRP: 文件用户组的执行权限位。</li><li>S_IRWXG: S_IRGRP | S_IWGRP | S_IXGRP。</li><li>S_IROTH: 文件其他用户的读权限位。</li><li>S_IWOTH: 文件其他用户的写权限位。</li><li>S_IXOTH: 文件其他用户的执行权限位。</li><li>S_IRWXO: S_IROTH | S_IWOTH | S_IXOTH。</li></ul></blockquote><p>使用这些权限宏时需要包含头文件sys&#x2F;stat.h。文件的访问权限是跟根据umask&amp;~mode得出来的。例如：umask &#x3D; 0022,<br>mode &#x3D; 0655，则访问权限为：644。umask是目前用户在建立档案或目录时的权限默认值，可以通过命令umask或者<br>umask -S查看该值。<br>打开创建文件示例:</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">int</span> fd = <span class="hljs-keyword">open</span>(<span class="hljs-string">&quot;./test.txt&quot;</span>,O_RDONLY);<span class="hljs-regexp">//</span>以只读方式打开test.txt文件<br><span class="hljs-keyword">int</span> fd = <span class="hljs-keyword">open</span>(<span class="hljs-string">&quot;./test.txt&quot;</span>,O_CREAT | O_RDWR);<span class="hljs-regexp">//</span>不存在就新建，否则以读写方式打开test.txt文件<br></code></pre></td></tr></table></figure><p>为了维持与早期的unix系统的向后兼容性，linux也提供了一个专门创建文件的系统调用，creat函数，它的声明如下:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">creat</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *pathname, <span class="hljs-type">mode_t</span> mode)</span></span>;<br></code></pre></td></tr></table></figure><p>其中参数pathname表示文件的名称，可以包含（绝对和相对）路径；mode用来规定对该文件的所有者、文件的用户<br>组及系统中其他用户的访问权限，其取值与open函数的mode相同。如果函数执行成功就返回文件描述符，负责返回<br>-1。在unix的早期版本中，open系统调用仅仅存在两个参数的形式。如果文件不存在，就不能打开这些文件。文件<br>的创建则由单独的系统调用creat完成。在Linux及所有unix的近代版本中，creat系统调用是多余的，因为open也<br>可以用来创建文件。以下两种形式等价。</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">int fd</span> = creat(file , mode);<br><span class="hljs-attribute">int fd</span> = open(file , O_WRONLY | O_CREAT | O_TRUNC , mode);<br></code></pre></td></tr></table></figure><img src="/2023/01/15/linux%E6%96%87%E4%BB%B6io/1.png" class=""><h4 id="关闭文件"><a href="#关闭文件" class="headerlink" title="关闭文件"></a>关闭文件</h4><p> 文件不再使用的时候，需要关闭，关闭问价使用close函数，该函数声明如下：<br> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">close</span><span class="hljs-params">(<span class="hljs-type">int</span> fd)</span></span>;<br></code></pre></td></tr></table></figure><br>其中fd为要关闭的文件描述符，函数执行成功就返回文件描述符，否则则返回-1。<br>文件关闭以后，此问价描述符不再指向任何文件，从而此描述符可以再次使用。如果每次打开文件后不关闭，就会<br>将系统的文件描述符耗尽，最终导致不能再打开文件。</p><h4 id="读取文件数据"><a href="#读取文件数据" class="headerlink" title="读取文件数据"></a>读取文件数据</h4><p>read函数可以实现从已经打开的文件中读取数据，该函数声明如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">ssize_t</span> <span class="hljs-title">read</span><span class="hljs-params">(<span class="hljs-type">int</span> fd , <span class="hljs-type">void</span> *buf , <span class="hljs-type">size_t</span> count)</span></span>;<br></code></pre></td></tr></table></figure><p>该函数把参数fd所指的文件传送count个字节到buf指针所指的内存中，若count为0，则read函数不会起作用并<br>返回0，返回值为实际读取到的字节数，如果返回0，表示已经到达文件结尾或没有可以读取的数据。<em><strong>注意：文件读写位置会随读取到的字节移动。</strong></em><br>需要强调的是，如果函数读取成功，会返回实际读取到的字节数，所以最好能将返回值与参数count做比较，若<br>返回的字节数小于要求读取的字节数，则有可能读到了文件尾部或者read函数被信号中断了读取动作。若有错<br>误发生时，则返回-1，错误代码存入errno中，此时文件读写位置无法预期。<br>常见的错误代码如下：</p><blockquote><ul><li>EINTR: 此调用被信号所中断。</li><li>EAGAIN: 当使用不可阻断I&#x2F;O时（O_NONBLOCK），若无数据可读取，则返回此值。</li><li>EBADF: 参数fd为非有效的文件描述符，或者当前文件已关闭。</li></ul></blockquote><p>read函数示例如下：  </p><img src="/2023/01/15/linux%E6%96%87%E4%BB%B6io/2.png" class="">  <h4 id="向文件写入数据"><a href="#向文件写入数据" class="headerlink" title="向文件写入数据"></a>向文件写入数据</h4><p>函数write可用于将数据写入已经打开的文件，该函数声明如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">ssize_t</span> <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-type">int</span> fd , <span class="hljs-type">const</span> <span class="hljs-type">void</span> *buf , <span class="hljs-type">size_t</span> count)</span></span>;<br></code></pre></td></tr></table></figure><p>该函数会把参数buf所指向的缓冲区中的count个字节数据写入fd所指的文件内，文件读写位置会随之移动。fd<br>是一个已经打开的文件描述符；buf指向一个缓冲区，为要写入的数据；count表示要写入的数据长度，单位是<br>字节。函数执行成功时返回实际写入的数据的字节数，当有错误发生时返回-1。错误代码用errno查看，常见<br>错误代码如下：</p><blockquote><ul><li>EINTR: 此调用被信号所中断。</li><li>EADF: 参数fd是非有效的文件描述符，或者该文件已经关闭。</li></ul></blockquote><p>代码示例：  </p><img src="/2023/01/15/linux%E6%96%87%E4%BB%B6io/3.png" class="">   <h4 id="文件偏移量"><a href="#文件偏移量" class="headerlink" title="文件偏移量"></a>文件偏移量</h4><p>读写文件时可能需要从不同的位置开始，此时需要让文件的读写位置可以移动到新的位置，所以需要用到设定文<br>件偏移量的函数。文件偏移量指的是当前文件操作位置相对于文件开始位置的偏移，当打开一个文件时，如果没<br>有指定O_APPEND参数，文件的偏移量为0，如果指定了O_APPEND参数，文件的偏移量与文件的长度相等，即文件的<br>当前操作位置移到了文件的末尾。<br>用来设定文件偏移量的系统函数是lseek，声明如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">off_t</span> <span class="hljs-title">lseek</span><span class="hljs-params">(<span class="hljs-type">int</span> fd , <span class="hljs-type">off_t</span> offset , <span class="hljs-type">int</span> whence)</span></span>;<br></code></pre></td></tr></table></figure><p>该函数对文件描述符fd所代表的文件，按照操作模式whence和偏移量的大小off_t，重新设置文件偏移量。如果<br>lseek()函数操作成功，就返回新的文件偏移量的值；如果失败就返回-1.由于文件的偏移量可以为负值，因此判<br>断lseek()是否操作成功时，要用是否等于-1来判断，不能使用小于0进行判断。参数offset和whence搭配使用，<br>具体含义如下：</p><blockquote><ul><li>whence值为SEEK_SET时，offset为相对文件开始处的值。</li><li>whence值为SEEK_CUR时，offset为相对当前位置的值。</li><li>whence值为SEEK_END时，offset为相对文件结尾的值。</li></ul></blockquote><p>函数使用示例如下：  </p><img src="/2023/01/15/linux%E6%96%87%E4%BB%B6io/4.png" class="">  <p>打开lseek.txt文件，可以看到写入的内容前有^@符号，这些不是空格,而是“0“，或者称为文件空洞。如果偏<br>移量设置超出文件的大小，就会造成文件空洞现象，即文件尾部（0字节大小的文件尾部就是文件的开头）到设置<br>之间被”0”填充。示例代码中新创建的文件lseek.txt文件大小为0kb，所以设置文件偏移量后会造成文件空洞<br>的现象。 </p><img src="/2023/01/15/linux%E6%96%87%E4%BB%B6io/5.png" class="">  <p>删除掉刚才的lseek.txt文件，然后新建一个文件lseek.txt,输入123456789ABCDEF，然后再重新执行示例程序，<br>会看到offset test被写入到7后面，并覆盖7以后的内容。  </p><img src="/2023/01/15/linux%E6%96%87%E4%BB%B6io/6.png" class="">  <img src="/2023/01/15/linux%E6%96%87%E4%BB%B6io/7.png" class="">  <img src="/2023/01/15/linux%E6%96%87%E4%BB%B6io/8.png" class="">  <h4 id="获取文件状态"><a href="#获取文件状态" class="headerlink" title="获取文件状态"></a>获取文件状态</h4><p>程序设计的时候经常要用到文件的一些属性特征值，如文件的所有者、文件的修改时间、文件的大小等。此时可以<br>使用stat()函数、fstat()函数或者lstat()函数。这些函数都可以获得文件的状态，函数声明如下：  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">stat</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *path , <span class="hljs-keyword">struct</span> stat *buf)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fstat</span><span class="hljs-params">(<span class="hljs-type">int</span> fd , <span class="hljs-keyword">struct</span> stat *buf)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lstat</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *path , <span class="hljs-keyword">struct</span> stat *buf)</span></span>;<br></code></pre></td></tr></table></figure><p>其中参数path是文件路径（包含文件名）；fd是文件描述符；buf为指向struct stat的结构体指针，获得的文件<br>属性特征值从这个参数中回传。当函数执行成功时返回0，执行失败时返回-1.<br>fstat函数区别于另外两个系统调用函数的地方在于，fstat系统调用接受的是一个文件描述符，而另外两个则直接<br>接受文件的全路径。文件描述符需要使用open系统调用后才能取得，而文件全路径可以省略此步，直接使用文件的<br>path就可以了。stat函数与lstat的区别是：当文件是一个符号链接时，lstat返回的是该符号链接本身的信息；而<br>stat返回的是该链接指向的文件的信息。<br>结构体struct stat是文件的属性特征描述，该结构定义如下：  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">stat</span>&#123;<br>    <span class="hljs-type">mode_t</span>  st_mode;    <span class="hljs-comment">//文件对应的模式、文件、目录等</span><br>    <span class="hljs-type">ino_t</span>   st_ino;     <span class="hljs-comment">//inode节点号</span><br>    <span class="hljs-type">dev_t</span>   st_dev;     <span class="hljs-comment">//设备号码</span><br>    <span class="hljs-type">dev_t</span>   st_rdev;    <span class="hljs-comment">//特殊设备号码</span><br>    <span class="hljs-type">nlink_t</span> st_nlink;   <span class="hljs-comment">//文件的链接数</span><br>    <span class="hljs-type">uid_t</span>   st_uid;     <span class="hljs-comment">//文件所有者</span><br>    <span class="hljs-type">gid_t</span>   st_gid;     <span class="hljs-comment">//文件所有者对应的组</span><br>    <span class="hljs-type">off_t</span>   st_size;    <span class="hljs-comment">//普通文件，对应的文件字节数</span><br>    <span class="hljs-type">time_t</span>  st_atime;   <span class="hljs-comment">//文件最后被访问的时间</span><br>    <span class="hljs-type">time_t</span>  st_mtime;   <span class="hljs-comment">//文件内容最后被修改的时间</span><br>    <span class="hljs-type">time_t</span>  st_ctime;   <span class="hljs-comment">//文件状态改变的时间</span><br>    <span class="hljs-type">blksize_t</span>   st_blksize;    <span class="hljs-comment">//文件内容对应的块大小</span><br>    <span class="hljs-type">blkcnt_t</span>    st_blocks;     <span class="hljs-comment">//文件内容对应的块数量</span><br>&#125;；<br></code></pre></td></tr></table></figure><p>示例代码：  </p><img src="/2023/01/15/linux%E6%96%87%E4%BB%B6io/9.png" class="">  <h4 id="文件锁定"><a href="#文件锁定" class="headerlink" title="文件锁定"></a>文件锁定</h4><p>当一个文件被多个用户共同使用和操作时，会导致共享资源产生竞争的状态，Linux采用给文件上锁的方法来避免产生共享资<br>源竞争。文件锁分为建议性锁和强制性锁，建议锁是指给文件上锁后，只在文件上设置一个锁的标识，其他进程如果要对该<br>文件进行操作时可以检测到有锁的存在，但该锁并不能阻止其它进程对这个文件要进行的操作。类似于红绿灯，红灯并不能<br>阻止车辆闯红灯的行为，更多的是建议规范。而强制性锁则是当给文件上锁后，其它进程要对这个文件进行不兼容的操作（<br>上了读锁，另外一个进程要写入）时，系统内核将会阻止后来的第二个进程，一直到第一个进程将锁解开。一般情况下，内<br>核和系统都不适合使用建议性锁，而应该使用强制性锁，这样可以防止一些破坏性的操作。每个进程对文件进行操作时，例<br>如执行open、read、write等操作时，内核都会检测该文件是否被加了强制性锁，如果加了强制性锁，其它进程对这些文件的<br>操作就会失败，也就是内核强制应用程序（即其它进程）来遵守游戏规则，这就是强制性锁的原理。<br><em><strong>对文件的加索操作是原子性的，并且，由fork产生的子进程不能继承父进程所设置的锁。也就意味着，若一个进程得到一把<br>锁，然后调用fork，那么对于父进程所获得的锁而言，子进程将被视为其它进程。对于从父进程处继承过来的任一描述符，<br>子进程都需要调用fnctl()函数才能获得属于它自己的锁。</strong></em><br>linux下可以使用fcntl()函数来实现文件的锁定。锁定文件在很多场合都很有用，例如为了防止进程的重复启动，可以在进<br>程启动时对&#x2F;var&#x2F;run目录下的.PID文件进行锁定，这样进程重复启动时，会因为无法对该文件上锁而退出。fcntl函数不仅能<br>对整个文件上锁，而且还可以对文件的某一记录上锁，此时的锁又称为记录锁。fcntl函数声明如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fcntl</span><span class="hljs-params">(<span class="hljs-type">int</span> fd , <span class="hljs-type">int</span> cmd , <span class="hljs-keyword">struct</span> flock *lock)</span></span>;<br></code></pre></td></tr></table></figure><p>其中，参数fd为文件描述符，cmd为操作命令，锁定文件时取值如下：  </p><blockquote><ul><li>F_GETLK: 根据lock描述，决定是否上文件锁或者记录锁。</li><li>F_SETLK: 设置lock所描述的文件锁或者记录锁。</li></ul></blockquote><p>lock是指向结构体flock的指针，用来说明是一个文件锁还是一个记录锁，是用于整个文件锁定还是锁定文件中的某一部分字<br>节。锁的方式有两种：建议锁和强制锁（然而这两种锁的区分并不是通过参数设置完成的，而是通过对系统的设置加以实现<br>的）。建议锁，相对温柔，在对文件进行锁操作时，会检测是否已经有锁存在，并且尊重已有的锁，但是其它的进程仍然可<br>以自由的修改文件。如果所有的程序进程都以一致的方式处理文件锁（或者记录锁），即在读写共享的文件前都申请一次文<br>件锁或记录锁，或者都不申请，总之所有进程都要以一致的方式进行处理。那么就不会发生冲突，这样的进程集称为合作进<br>程，合作进程使用建议性锁是可行的。强制锁是由内核执行的锁，当一个文件被执行强制锁，并且当前进程正在写入数据的<br>操作，此时内核将阻止其它进程对该文件进行的读写操作。采取强锁会对性能影响很大，fcntl函数默认是建议锁，如果需要<br>在Linux中使用强制锁，则需要在root权限下，通过mount命令用-o mand选项打开该机制。结构体flock定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">flock</span><br>&#123;<br>    <span class="hljs-type">short</span> <span class="hljs-type">int</span> l_type;     <span class="hljs-comment">//锁定的状态</span><br>    <span class="hljs-type">short</span> <span class="hljs-type">int</span> l_whence;   <span class="hljs-comment">//决定l_start的位置</span><br>    <span class="hljs-type">off_t</span>     l_start;    <span class="hljs-comment">//锁定区域的开头位置</span><br>    <span class="hljs-type">off_t</span>     l_len;      <span class="hljs-comment">//锁定区域的大小</span><br>    <span class="hljs-type">pid_t</span>     l_pid;      <span class="hljs-comment">//锁定动作的进程</span><br>&#125;；<br></code></pre></td></tr></table></figure><p>l_type有三个选项：  </p><blockquote><ul><li>F_RDLCK: 共享锁（也称读锁），只读用，多个进程可以同时建立读取锁。</li><li>F_WRLCK: 独占锁（也称写锁），在任何时刻只能有一个进程建立写入锁</li><li>F_UNLCK: 解除锁定。</li></ul></blockquote><p>l_whence有以下几个选项（在unistd.h中定义）：</p><blockquote><ul><li>SEEK_SET: 文件开始位置</li><li>SEEK_CUR: 文件当前位置</li><li>SEEK_END: 文件末尾位置</li></ul></blockquote><p>其它的三个参数：</p><blockquote><ul><li>l_start: 相对开始偏移量，相对于l_whence而言。</li><li>l_len: 加锁的长度，0为到文件末尾。</li><li>l_pid：当前操作文件的进程ID号。</li></ul></blockquote><p>如果函数执行成功返回值为0，否则返回-1，此时可用errno查看错误码。函数使用示例代码如下：</p><img src="/2023/01/15/linux%E6%96%87%E4%BB%B6io/10.png" class="">  <p>如上图所示，程序编译并运行，此时程序处于死循环状态，并且文件已经加锁成功（默认为建议锁）。然后往lock.txt的文<br>件中写入数据，可以看到是可以写入成功的，如下图所示:  </p><img src="/2023/01/15/linux%E6%96%87%E4%BB%B6io/11.png" class="">  <p>上图中的lock.txt文件内容开始是空的，然后用echo往该上锁文件中写入数据，再次输出时可以看到写入的数据被输出了，<br>说明被建议锁锁住的文件的确是可以被其它进程修改的,所以建议锁只适合于合作进程。建议锁就是假定所有人都会遵守某<br>些规则去做一件事，例如人与车看到红灯都会停，看到绿灯才会继续走，此时的红绿灯就类似于建议锁，但这是一件需要<br>大家主动去遵守的规则，而并不能避免有些车与人强行闯红灯，而强制锁则完全是无法闯红灯的措施。<br>实现强制锁需要将文件所在的文件系统通过mount命令的“-o mand”选项来挂载，并且使用chmod函数或者chmod命令将文<br>件用户组的x权限去掉（即清楚组可执行位）。如下图所示：<br>首先切换到root用户，并查看我们的文件挂载硬盘信息：  </p><img src="/2023/01/15/linux%E6%96%87%E4%BB%B6io/12.png" class="">  <p> 可以看到lock.txt文件是挂载在&#x2F;dev&#x2F;sdc下的，所以进入lock.txt所在目录重新进行挂载，挂载完成后，此时文件系统<br> &#x2F;dev&#x2F;sdc增加了mand选项，然后再修改lock.txt的权限，将用户组的x权限去掉。如下图所示：  </p><img src="/2023/01/15/linux%E6%96%87%E4%BB%B6io/13.png" class="">  <img src="/2023/01/15/linux%E6%96%87%E4%BB%B6io/14.png" class="">  <p>此时重新运行之前的test_filelock程序，程序处于死循环当中，然后重新打开一个终端shell,尝试向lock.txt中写入新<br>内容，可以发现，#提示符出现不了，说明echo命令被阻塞不动了（内核阻止了该进程），说明强制锁已经生效。然后回<br>到之前的shell使用ctrl+c终止test_filelock程序，可以发现另一个shell的echo进程阻塞被解除了，出现了#提示符，查<br>看lock.txt文件，发现新的内容已经被写入，这说明强制锁解除后，就可以写入新内容了，否则无法写入。从这个例子可<br>以看出，强制锁的实现只是进行了一些系统上的设置，重新加载了文件系统，修改了文件的权限，程序上并没有进行任何<br>更改。</p><h4 id="文件与内存映射"><a href="#文件与内存映射" class="headerlink" title="文件与内存映射"></a>文件与内存映射</h4><p>文件和内存的映射，就是将普通文件映射到内存中，普通文件被映射到进程地址空间后，进程可以像访问普通内存一样对<br>文件进行访问，不需要再调用read或者write等函数进行操作。将普通文件映射到内存的系统函数为mmap,函数声明如下：  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/mman.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">void</span> *<span class="hljs-title">mmap</span><span class="hljs-params">(<span class="hljs-type">void</span> *start , <span class="hljs-type">size_t</span> length , <span class="hljs-type">int</span> prot , <span class="hljs-type">int</span> flags , <span class="hljs-type">int</span> fd , <span class="hljs-type">off_t</span> offset)</span></span>;<br></code></pre></td></tr></table></figure><p>其中参数start为映射区域的起始地址，通常为NULL或0，表示由系统自己决定映射到什么地址；length为映射数据的长度<br>，即文件需要映射到内存中的数据的大小；prot表示映射区域的保护方式，有以下取值（或它们的组合）：  </p><blockquote><ul><li>PROT_EXEC: 映射区可被执行。</li><li>PROT_READ: 映射区可读取。</li><li>PROT_WRITE: 映射区可写入。</li><li>PROT_NONE: 映射区不可访问。</li></ul></blockquote><p>flags用来指定映射对象的类型、映射选项和映射页是否可以共享，它的取值可以是一个或者多个位的组合。如下所示：  </p><blockquote><ul><li>MAP_FIXED: 如果参数start指定了需要映射到的地址，而所指定的地址无法成功建立映射，映射就会失败。通常不推<br>         荐使用此设置，而将start设置为NULL或0，由系统自动选取映射地址。</li><li>MAP_SHARED: 共享映射区域，映射区域允许其它进程共享，对映射区域写入数据将会写入原来的文件中。</li><li>MAP_PRIVATE: 对映射区域进行写入操作时会产生一个映射文件的复制，即私人的写入时复制（copy on write），对此<br>           映射区域的修改不会写回原来的文件，即不会影响原来文件的内容。</li><li>MAP_ANONYMOUS: 建立匿名映射。映射区不与任何文件关联，而且映射区无法与其它进程共享。</li><li>MAP_DENYWRITE: 对文件的写入操作将被禁止，不允许直接对文件进行操作。</li><li>MAP_LOCKED: 将映射区锁定，防止页面被交换出内存。</li></ul></blockquote><p>参数flags必须为MAP_SHARED或者MAP_PRIVATE二者之一的类型。MAP_SHARED类型表示多个进程使用的是一个内存映射的副<br>本，任何一个进程都可以对此映射进行修改，且其它进程对此修改是可见的。而MAP_PRIVATE则是多个进程使用的文件内存<br>映射，在写入操作后，会复制一个副本给修改的进程，多个进程之间的副本是不一致的。<br>参数fd表示文件描述符，一般由open()函数返回；<br>参数offset表示被映射数据在文件中的起点；<br>mmap()函数映射后，可以让用户程序直接访问设备内存，相比较在用户空间和内核空间相互复制数据，小路更高，在<br>要求高性能的应用中比较常用。mmap映射内存必须是页面大小的整数倍，面向流的设备不能进行mmap映射，mmap的实<br>现和硬件有关。<br>mmap()使用示例：   </p><img src="/2023/01/15/linux%E6%96%87%E4%BB%B6io/15.png" class="">   <img src="/2023/01/15/linux%E6%96%87%E4%BB%B6io/16.png" class="">     <p>以上的程序将文件test.txt的内容先映射到内存mapped_mem，然后使用printf函数将此内存区域的内容输出出来，可<br>以看到，输出的内容正是test.txt文本文件的内容。<br>以上的示例因为使用的是PROT_READ，所以只能读取文件里的内容，不能修改，如果使用PROT_WIRTE，就可以修改文件<br>的内容了。又因为使用了MMAP_PRIVATE，所以只能此进程使用此内存区域，若换用MAP_SHARED，则可以被其它进程访<br>问，如下例示：   </p><img src="/2023/01/15/linux%E6%96%87%E4%BB%B6io/17.png" class="">    <img src="/2023/01/15/linux%E6%96%87%E4%BB%B6io/18.png" class="">     <p>可以看到，我们通过对内存映射的修改，文本文件也修改成功了。   </p><h4 id="mmap和共享内存"><a href="#mmap和共享内存" class="headerlink" title="mmap和共享内存"></a>mmap和共享内存</h4><p>共享内存允许两个或者多个进程共享一个给定的存储区，因为数据不需要来回复制，所以是最快的一种进程间通讯机<br>制。共享内存可以通过mmap()映射普通文件（特殊情况下还可以采用匿名映射）机制实现，也可以通过系统V共享内<br>存机制实现。应用接口和原理很简单，内部机制复杂。为了实现更安全的通信，往往还与信号灯等同步机制共同使用<br>。对比如下：   </p><blockquote><ul><li>mmap机制：就是在硬盘上建立一个文件，每个进程存储器里面单独开辟一个空间来进行映射。如果是多进程，那<br>么对实际的物理存储器（主存）消耗不会太大。mmap保存到实际硬盘，实际存储并没有反映到主存上。优点是存储量<br>可以很大（多于主存），缺点是进程间读取和写入速度要比主存的慢。   </li><li>shm机制：每个进程的共享内存都直接映射到实际物理存储器里面。shm保存到物理存储器（主存），实际的存储<br>量直接反映到主存上。优点是进程间访问速度（读写）比磁盘要快，缺点是存储量不能非常大（多于主存）。</li></ul></blockquote><p>从使用上看，如果分配的存储量不大，就使用shm；如果存储量大，就使用mmap。</p>]]></content>
    
    
    <categories>
      
      <category>linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>I/O</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>窗口函数</title>
    <link href="/2022/11/20/%E7%AA%97%E5%8F%A3%E5%87%BD%E6%95%B0/"/>
    <url>/2022/11/20/%E7%AA%97%E5%8F%A3%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="窗口函数"><a href="#窗口函数" class="headerlink" title="窗口函数"></a>窗口函数</h2><p>窗口函数（也称为分析函数）针对一组行计算值，并为每行返回一个结果。这与聚合函数不同；聚合函数会为一组行返回一个结果。<br>窗口函数，也叫OLAP函数（Online Anallytical Processing，联机分析处理），可以对数据库数据进行实时分析处理。<br>窗口函数包含一个 OVER 子句，该子句定义了涵盖所要计算行的行窗口。对于每一行，系统会使用选定的行窗口作为输入来计算窗口函数结果，并可能进行聚合。<br>语法如下：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">&lt;窗口函数&gt; <span class="hljs-keyword">over</span> (<span class="hljs-keyword">partition</span> <span class="hljs-keyword">by</span> &lt;用于分组的列名&gt;<br>                <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> &lt;用于排序的列名&gt;)<br></code></pre></td></tr></table></figure><p>借助窗口函数，您可以计算移动平均值、对各项进行排名、计算累计总和，以及执行其他分析。<br>常用的业务场景有：部门按员工业绩排名、或者找出每个部门的topN员工等。</p><h4 id="窗口函数使用"><a href="#窗口函数使用" class="headerlink" title="窗口函数使用"></a>窗口函数使用</h4><p>窗口函数分为两种：</p><ul><li>专用窗口函数：rank, dense_rank, row_number等</li><li>聚合函数：sum. avg, count, max, min等</li></ul><ol><li>初始表数据如下<figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> student_score;<br></code></pre></td></tr></table></figure><img src="/2022/11/20/%E7%AA%97%E5%8F%A3%E5%87%BD%E6%95%B0/1.png" class=""><br><br></li><li>业务需求：各个班级独自按成绩排名<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">select</span> * ,rank()<span class="hljs-keyword">over</span>(<span class="hljs-keyword">partition</span> <span class="hljs-keyword">by</span> std_class <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> std_score <span class="hljs-keyword">desc</span>) <span class="hljs-keyword">as</span> ranking<br><span class="hljs-keyword">from</span> student_score;<br></code></pre></td></tr></table></figure>该sql语句使用partition by对班级进行分组，order by 对分组后的成绩进行排序。</li></ol><img src="/2022/11/20/%E7%AA%97%E5%8F%A3%E5%87%BD%E6%95%B0/2.png" class=""><br><br>上述业务group by和order by不易实现，因为group by分组完会改变表的行数，一行只代表一个类别，而partition by和rank是不会改变原表的行数的。3. 其它窗口函数<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">select</span> * ,rank()<span class="hljs-keyword">over</span>(<span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> std_score <span class="hljs-keyword">desc</span>) <span class="hljs-keyword">as</span> ranking, <br>         dense_rank() <span class="hljs-keyword">over</span>(<span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> std_score <span class="hljs-keyword">desc</span>) <span class="hljs-keyword">as</span> den_ranking, <br>         row_number() <span class="hljs-keyword">over</span>(<span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> std_score <span class="hljs-keyword">desc</span>) <span class="hljs-keyword">as</span> row_num <br><span class="hljs-keyword">from</span> student_score;<br></code></pre></td></tr></table></figure><img src="/2022/11/20/%E7%AA%97%E5%8F%A3%E5%87%BD%E6%95%B0/3.png" class=""><br><br>> rank函数：如果有并列的名次，则排名相同，下一位置被占。> dense_rank函数：如果有并列的名次，则排名相同，下一位置不被占。> row_num函数：不考虑并列情况。<ol start="4"><li>聚合函数<figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">select</span> * ,<span class="hljs-built_in">sum</span>(std_score) <span class="hljs-keyword">over</span>(<span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> std_id) <span class="hljs-keyword">as</span> std_sum,<br>       <span class="hljs-built_in">avg</span>(std_score) <span class="hljs-keyword">over</span>(<span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> std_id) <span class="hljs-keyword">as</span> std_avg,<br>       <span class="hljs-built_in">count</span>(std_score) <span class="hljs-keyword">over</span>(<span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> std_id) <span class="hljs-keyword">as</span> std_count,<br>       <span class="hljs-built_in">max</span>(std_score) <span class="hljs-keyword">over</span>(<span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> std_id) <span class="hljs-keyword">as</span> std_max,<br>       <span class="hljs-built_in">min</span>(std_score) <span class="hljs-keyword">over</span>(<span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> std_id) <span class="hljs-keyword">as</span> std_min<br>   <span class="hljs-keyword">from</span> student_score;<br><br></code></pre></td></tr></table></figure>如下图：</li></ol><img src="/2022/11/20/%E7%AA%97%E5%8F%A3%E5%87%BD%E6%95%B0/4.png" class=""><br> <br>窗口函数中使用聚合函数的效果如上所示，每行的值都是截至到该行数据的一个汇总计算，不会涵盖该行以下。<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><blockquote><p>窗口函数不同于group by等，它不会改变原表的行数，且同时具有分组和排序的功能，<br>窗口是指分组过后每组的数据范围，通常窗口函数只存在于select语句中。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>sql</category>
      
    </categories>
    
    
    <tags>
      
      <tag>sql函数</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>power shell脚本命令</title>
    <link href="/2022/11/11/powershell%E8%84%9A%E6%9C%AC/"/>
    <url>/2022/11/11/powershell%E8%84%9A%E6%9C%AC/</url>
    
    <content type="html"><![CDATA[<p>最近开始支援其他项目组做一些脚本开发，记录一下。  </p><ul><li>去除输入文件的首行，重新生成新的文件：<figure class="highlight dsconfig"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dsconfig">$<span class="hljs-string">x</span> = <span class="hljs-string">Get-Content</span> -<span class="hljs-string">Path</span> <span class="hljs-string">&quot;..test.csv&quot;</span><br><span class="hljs-built_in">set-Content</span> -<span class="hljs-string">Path</span> <span class="hljs-string">&quot;..new.csv&quot;</span> -<span class="hljs-string">Value</span> ($<span class="hljs-string">x</span>[<span class="hljs-string">1</span>..($<span class="hljs-string">x</span>.<span class="hljs-string">Length-1</span>)])<br></code></pre></td></tr></table></figure></li><li>获取文件的当前路径 $PSScriptRoot</li></ul><figure class="highlight monkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs monkey"><span class="hljs-keyword">Import</span>-<span class="hljs-keyword">Module</span> ./test.ps1<span class="hljs-meta"></span><br><span class="hljs-meta"># 更改为</span><br><span class="hljs-keyword">Import</span>-<span class="hljs-keyword">Module</span> $PSScriptRoot/test.ps1<br></code></pre></td></tr></table></figure><p>这样可以避免执行脚本时必须进入脚本所在的目录，只需要在任意路径下输入脚本的绝对路径，这样脚本中其它的导入模块也会正常的被脚本读取到。</p><ul><li>将读入的csv文件转化为数组<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-variable">$csvdata</span> = <span class="hljs-selector-tag">@</span>(<span class="hljs-built_in">Import-Csv</span> <span class="hljs-variable">$csvfile</span> <span class="hljs-literal">-Encoding</span> UTF8)<br><span class="hljs-comment"># 数组长度</span><br><span class="hljs-variable">$arrsize</span> = <span class="hljs-variable">$csvdate</span>.Count<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>shell</category>
      
    </categories>
    
    
    <tags>
      
      <tag>powershell脚本</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>poi包冲突调试</title>
    <link href="/2022/11/02/poi%E5%8C%85%E5%86%B2%E7%AA%81%E8%B0%83%E8%AF%95/"/>
    <url>/2022/11/02/poi%E5%8C%85%E5%86%B2%E7%AA%81%E8%B0%83%E8%AF%95/</url>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>媳妇她们项目组在做一个老旧项目的升级移行工作，她最近主要在负责batch这块的改修，其中有一个功能是关于<br>excel生成的，之前老项目中是HSSF的导出，现在她要升级为XSSF的导出，所以得引入一些poi的包，由于导入了<br>部分新包，所以项目产生了莫名其妙的报错。</p><h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><p>由于她们的项目是很老的项目，没有使用maven管理，所以排查起来很是费劲。先是在本地建了一个maven的项目，<br>然后导入了主要的两个poi包，poi-5.2.2.jar和poi-ooxml-5.2.2.jar，查看了它们的依赖关系，锁定了需要的最<br>小依赖，写了段简略的读写测试代码，运行调试通过。最后将项目所有包导入，运行报错，试着删除和poi有依赖<br>冲突可能的包，直到测试代码可以正常运行。最后锁定了一个名为poi-2.5.1-final-20040804.jar的包，删掉此<br>包后测试代码正常执行导入导出，但是奇怪的是再次导入此包后测试代码仍然可以正常运行，以为是项目缓存<br>导致的，所以将project又clean了继续运行，然而测试代码仍然正常结束。重复了几次，发现只有在第一次导入<br>所有包时运行报错，删除poi-2.5.1-final-20040804.jar包后就正常运行，再次导入后又不会引发冲突错误，更<br>令人费解的是正式项目的引用包中是没有poi-2.5.1-final-20040804.jar的。<br><br>报错如下：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">Exception <span class="hljs-keyword">in</span> thread <span class="hljs-string">&quot;main&quot;</span> java.lang.NoSuchMethodError: org.apache.poi.util.<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">IOUtils</span>.</span></span>copy(Ljava/io/InputStream;Ljava/io/OutputStream;)J<br>at org.apache.poi.openxml4j.opc.internal.marshallers.<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ZipPartMarshaller</span>.</span></span>marshall(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ZipPartMarshaller</span>.</span></span>java:<span class="hljs-number">89</span>)<br>at org.apache.poi.openxml4j.opc.internal.<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">MemoryPackagePart</span>.</span></span>save(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">MemoryPackagePart</span>.</span></span>java:<span class="hljs-number">111</span>)<br>at org.apache.poi.openxml4j.opc.internal.marshallers.<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">DefaultMarshaller</span>.</span></span>marshall(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">DefaultMarshaller</span>.</span></span>java:<span class="hljs-number">46</span>)<br>at org.apache.poi.openxml4j.opc.<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ZipPackage</span>.</span></span>save<span class="hljs-constructor">Impl(ZipPackage.<span class="hljs-params">java</span>:584)</span><br>at org.apache.poi.openxml4j.opc.<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">OPCPackage</span>.</span></span>save(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">OPCPackage</span>.</span></span>java:<span class="hljs-number">1490</span>)<br>at org.apache.poi.ooxml.<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">POIXMLDocument</span>.</span></span>write(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">POIXMLDocument</span>.</span></span>java:<span class="hljs-number">227</span>)<br>at testlib.<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Test</span>.</span></span>main(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Test</span>.</span></span>java:<span class="hljs-number">31</span>)<br></code></pre></td></tr></table></figure><p>或者报错是关于btye[]的方法peekFirstNBtyes之类。</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>由于错误log中所报的这些方法经过跟踪确实是存在的，删掉poi-2.5.1-final-20040804.jar包也确实不再报错，所以可以<br>确定的是问题肯定出在了poi-2.5.1-final-20040804.jar这个jar包上，但是为什么只有第一次存在这个jar包引用时会出错<br>删掉再导入后又不会引发冲突，为什么正式项目中没有此包也报错？本能觉得是项目结构构筑的问题，所以就查看了关于<br>build path的详细信息，发现关于order and export的一段描述是越上层的优先级越高，而我本地的build path中的导致<br>报错的poi-2.5.1-final-20040804.jar包却在最底层，所以我将该包的优先级调为了上层又复现了之前的错误，为什么只<br>有第一次导入会导致报错，删除后重新导入就不会引发错误的问题至此已经解决，还有第二个问题是正式项目中没有此包<br>为什么也会报错，这个问题经过查看build path后发现老项目中引用了一个外部工程common，而位于顶层的common当中<br>引用了poi-2.5.1-final-20040804.jar此包，经过优先级重调，第二个问题也顺利解决。<br><br>模拟第一次报错：</p><img src="/2022/11/02/poi%E5%8C%85%E5%86%B2%E7%AA%81%E8%B0%83%E8%AF%95/1.png" class=""><br><br><br><p>删除冲突包执行成功：</p><img src="/2022/11/02/poi%E5%8C%85%E5%86%B2%E7%AA%81%E8%B0%83%E8%AF%95/2.png" class=""><img src="/2022/11/02/poi%E5%8C%85%E5%86%B2%E7%AA%81%E8%B0%83%E8%AF%95/3.png" class=""><br><br><br><p>再次导入冲突包执行依然成功：</p><img src="/2022/11/02/poi%E5%8C%85%E5%86%B2%E7%AA%81%E8%B0%83%E8%AF%95/4.png" class=""><img src="/2022/11/02/poi%E5%8C%85%E5%86%B2%E7%AA%81%E8%B0%83%E8%AF%95/5.png" class=""><img src="/2022/11/02/poi%E5%8C%85%E5%86%B2%E7%AA%81%E8%B0%83%E8%AF%95/6.png" class=""><img src="/2022/11/02/poi%E5%8C%85%E5%86%B2%E7%AA%81%E8%B0%83%E8%AF%95/7.png" class=""><img src="/2022/11/02/poi%E5%8C%85%E5%86%B2%E7%AA%81%E8%B0%83%E8%AF%95/8.png" class=""><br><br><br><p>更改引用顺序，重现错误：</p><img src="/2022/11/02/poi%E5%8C%85%E5%86%B2%E7%AA%81%E8%B0%83%E8%AF%95/9.png" class=""><img src="/2022/11/02/poi%E5%8C%85%E5%86%B2%E7%AA%81%E8%B0%83%E8%AF%95/10.png" class="">]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>jar包冲突</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>指针相等问题</title>
    <link href="/2022/11/01/%E5%88%A4%E6%96%AD%E4%B8%A4%E4%B8%AA%E6%8C%87%E9%92%88%E7%9B%B8%E7%AD%89%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/"/>
    <url>/2022/11/01/%E5%88%A4%E6%96%AD%E4%B8%A4%E4%B8%AA%E6%8C%87%E9%92%88%E7%9B%B8%E7%AD%89%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</url>
    
    <content type="html"><![CDATA[<h2 id="指针操作"><a href="#指针操作" class="headerlink" title="指针操作"></a>指针操作</h2><p>C++ Primer中关于指针操作中有一段描述是：</p><blockquote><p>对于两个类型相同的合法指针，可以用相等操作符 &#x3D;&#x3D; 或 不相等操作符 !&#x3D; 来比较它们，比较的的结果<br>是布尔类型。如果两个指针存放的地址值相同，则它们相等；反之它们不相等。这里两个指针存放的地址值相同（两个指针相等）<br>有三种可能：它们都为空、都指向同一个对象、或者都指向了同一个对象的下一地址。<br>需要注意的是:<strong>一个指针指向某对象，同时另一个指针指向另外对象的下一地址，此时也有可能出现这两个指针值相同的情况，即指针相等。</strong></p></blockquote><p>关于最后描述的同一个对象的下一地址，出现有可能相等的情况，这是因为内存的申请使用一般都是连续分配的，所以很可能出现指针运算过后指向的下一个地址和相同类型的另一指针指向的当前位置相等！具体如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br> <br>  <span class="hljs-type">int</span> a1 = <span class="hljs-number">1</span>;<br>  <span class="hljs-type">int</span> a2 = <span class="hljs-number">2</span>;<br> <br>  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function">  </span>&#123;<br>      <span class="hljs-type">int</span>* p1 = &amp;a1;<br>      <span class="hljs-type">int</span>* p2 = &amp;a2;<br>      <span class="hljs-type">int</span>* p3;<br> <br>      std::cout&lt;&lt;<span class="hljs-string">&quot;*p1 = &quot;</span>&lt;&lt;*p1&lt;&lt;<span class="hljs-string">&quot;,地址为：p1 = &quot;</span>&lt;&lt;p1&lt;&lt;std::endl;<br>      std::cout&lt;&lt;<span class="hljs-string">&quot;*p2 = &quot;</span>&lt;&lt;*p2&lt;&lt;<span class="hljs-string">&quot;,地址为：p2 = &quot;</span>&lt;&lt;p2&lt;&lt;std::endl;<br>      p3 = ++p1;<br>      <span class="hljs-keyword">if</span>(p2 == p3)&#123;<br>      ¦   std::cout&lt;&lt;<span class="hljs-string">&quot;*p3 = &quot;</span>&lt;&lt;*p3&lt;&lt;<span class="hljs-string">&quot;,地址为：p3 = &quot;</span>&lt;&lt;p3&lt;&lt;std::endl;<br>      &#125;<br> <br>      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  &#125;<br></code></pre></td></tr></table></figure><p>运行图如下所示：</p><img src="/2022/11/01/%E5%88%A4%E6%96%AD%E4%B8%A4%E4%B8%AA%E6%8C%87%E9%92%88%E7%9B%B8%E7%AD%89%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/bg1.png" class=""><h4 id="关于指针和引用"><a href="#关于指针和引用" class="headerlink" title="关于指针和引用"></a>关于指针和引用</h4><p>引用并非对象，它只是为一个已经存在的对象所起的别名而已，所以引用只能使用对象进行初始化(不能使用字面量初始化)，<br>引用的初始化过程并非是将对象的值拷贝给引用，而是绑定，程序将引用和它的初始值绑定在一起，一旦初始化完成，引用<br>将和它的初始值对象一直捆绑在一起，也正是因为引用无法重新解绑到另外一个对象，所以引用必须进行初始化操作！因为<br>引用不是对象，没有实际的地址，所以不能定义指向引用的指针 ！</p><p><strong>指针和引用的区别：</strong><br>指针和引用同为复合类型，都与内存中实际存在的对象有联系。指针”指向”内存中的某个对象，而引用”绑定到”内存中的某<br>个对象，它们都实现了对其他对象的间接访问，二者的区别主要有两方面：</p><p><em><strong>第一，指针本身就是一个对象，允许对指针赋值和拷贝，而且在指针的生命周期内它可以指向几个不同的对象；引用不是一<br>个对象，无法令引用重新绑定到另外一个对象。<br><br>第二，指针无须在定义时赋初值，和其他内置类型一样，在块作用域内定义的指针如果没有被初始化，也将拥有一个不确定<br>的值；引用则必须在定义时赋初值。</strong></em></p>]]></content>
    
    
    <categories>
      
      <category>C/C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vimrc</title>
    <link href="/2022/10/24/%E4%B8%AA%E4%BA%BAvim%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/"/>
    <url>/2022/10/24/%E4%B8%AA%E4%BA%BAvim%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="配置如下"><a href="#配置如下" class="headerlink" title="配置如下"></a><center>配置如下</h1><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br></pre></td><td class="code"><pre><code class="hljs 1c"><span class="hljs-string">&quot; All system-wide defaults are set in $VIMRUNTIME/debian.vim and sourced by</span><br><span class="hljs-string">&quot; the call to :runtime you can find below.If you wish to change any of those</span><br><span class="hljs-string">&quot; settings, you should do it in this file (/etc/vim/vimrc), since debian.vim</span><br><span class="hljs-string">&quot; will be overwritten everytime an upgrade of the vim packages is performed.</span><br><span class="hljs-string">&quot; It is recommended to make changes after sourcing debian.vim since it alters</span><br><span class="hljs-string">&quot; the value of the &#x27;compatible&#x27; option.</span><br><br>runtime! debian.vim<br><br><span class="hljs-string">&quot; Vim will load $VIMRUNTIME/defaults.vim if the user does not have a vimrc.</span><br><span class="hljs-string">&quot; This happens after /etc/vim/vimrc(.local) are loaded, so it will override</span><br><span class="hljs-string">&quot; any settings in these files.</span><br><span class="hljs-string">&quot; If you don&#x27;t want that to happen, uncomment the below line to prevent</span><br><span class="hljs-string">&quot; defaults.vim from being loaded.</span><br><span class="hljs-string">&quot; let g:skip_defaults_vim = 1</span><br><br><span class="hljs-string">&quot; Uncomment the next line to make Vim more Vi-compatible</span><br><span class="hljs-string">&quot; NOTE: debian.vim sets &#x27;nocompatible&#x27;.  Setting &#x27;compatible&#x27; changes numerous</span><br><span class="hljs-string">&quot; options, so any other options should be set AFTER setting &#x27;compatible&#x27;.</span><br><span class="hljs-string">&quot;set compatible</span><br><br><span class="hljs-string">&quot; Vim5 and later versions support syntax highlighting. Uncommenting the next</span><br><span class="hljs-string">&quot; line enables syntax highlighting by default.</span><br>if has(<span class="hljs-string">&quot;syntax&quot;</span>)<br>  syntax on<br>endif<br><br><span class="hljs-string">&quot; If using a dark background within the editing area and syntax highlighting</span><br><span class="hljs-string">&quot; turn on this option as well</span><br><span class="hljs-string">&quot;set background=dark</span><br><br><span class="hljs-string">&quot; Uncomment the following to have Vim jump to the last position when</span><br><span class="hljs-string">&quot; reopening a file</span><br><span class="hljs-string">&quot;au BufReadPost * if line(&quot;</span>&#x27;\&quot;&quot;) &gt; 1 &amp;&amp; line(&quot;&#x27;\<span class="hljs-string">&quot;&quot;</span>) &lt;= line(<span class="hljs-string">&quot;$&quot;</span>) <span class="hljs-string">| exe &quot;</span>normal! g&#x27;\&quot;&quot; | endif<br><br>&quot; Uncomment the following to have Vim load indentation rules and plugins<br>&quot; according to the detected filetype.<br>&quot;filetype plugin indent on<br><br>&quot; The following are commented out as they cause vim to behave a lot<br>&quot; differently from regular Vi. They are highly recommended though.<br>&quot;set showcmd&quot; Show (partial) command in status line.<br>&quot;set showmatch&quot; Show matching brackets.<br>&quot;set ignorecase&quot; Do case insensitive matching<br>&quot;set smartcase&quot; Do smart case matching<br>&quot;set incsearch&quot; Incremental search<br>&quot;set autowrite&quot; Automatically save before commands like :next and :make<br>&quot;set hidden&quot; Hide buffers when they are abandoned<br>&quot;set mouse=a&quot; Enable mouse usage (all modes)<br><br>&quot; Source a global configuration file if available<br>if filereadable(&quot;/etc/vim/vimrc.local&quot;)<br>  source /etc/vim/vimrc.local<br>endif<br><br>&quot;个人配置==================================================================================================&gt;<br>&quot;打开文件的编码设置<br>set fileencodings=cs-bom,utf-8,utf-16,gbk,big5,gb<span class="hljs-number">1803</span>0,latin1<br>&quot;开启鼠标<br>&quot;set mouse=a <br>&quot;前缀键&lt;leader&gt;默认为\ 使用下面命令将前缀键定义为逗号<br>let mapleader=&quot;,&quot;<br>&quot;设置行号<br>set nu<br>&quot;设置缩进格式<br>set autoindent &quot;自动缩进<br>set cindent<br>set ts=4 &quot;表示一个tab在屏幕上打印多少个空格长度，默认为8<br>&quot;set softtabstop=4<br>set shiftwidth=4<br>set expandtab<br><br>&quot;set cursorcolumn<br>&quot;set cursorline<br>set hlsearch<br>hi Search term=bold,reverse cterm=bold ctermfg=15 ctermbg=2 gui=bold guifg=bg guibg=DarkGreen<br><br>&quot;设置引号和括号自动补全<br>inoremap &#x27; &#x27;&#x27;&lt;ESC&gt;i<br>inoremap <span class="hljs-string">&quot; &quot;&quot;&lt;ESC&gt;i</span><br>inoremap ( ()&lt;ESC&gt;i<br>inoremap [ []&lt;ESC&gt;i<br><span class="hljs-string">&quot;数组初始化使用补全</span><br>inoremap &#123; &#123;&#125;&lt;ESC&gt;i<br><span class="hljs-string">&quot;方法括号补全</span><br>inoremap &#123;&lt;CR&gt; &#123;&#125;&lt;ESC&gt;i&lt;CR&gt;&lt;ESC&gt;O<br><span class="hljs-string">&quot;跳出括号等</span><br>inoremap &lt;tab&gt;&lt;space&gt; &lt;ESC&gt;&lt;space&gt;a<br><span class="hljs-string">&quot;插入模式下注释当前行</span><br>inoremap <span class="hljs-comment">// &lt;ESC&gt;0i//&lt;ESC&gt;</span><br><span class="hljs-string">&quot;删除当前行注释</span><br>nnoremap &lt;leader&gt;/ <span class="hljs-number">0</span>xx<br><br><span class="hljs-string">&quot;将crtl+d映射为插入模式下的删除当前行</span><br>inoremap &lt;c-d&gt; &lt;ESC&gt;dd i<br><br><span class="hljs-string">&quot;插件管理-----------------------------------------&gt;</span><br>call plug<span class="hljs-meta">#begin(&#x27;~/.vim/plugged&#x27;)</span><br>Plug &#x27;vim-airline/vim-airline&#x27;<br>Plug &#x27;ludovicchabant/vim-gutentags&#x27;<br>Plug &#x27;ycm-core/YouCompleteMe&#x27;<br>Plug  &#x27;Yggdroot/indentLine&#x27;<br>Plug &#x27;skywind<span class="hljs-number">3000</span>/asyncrun.vim&#x27;<br>Plug &#x27;preservim/nerdtree&#x27;<br>Plug &#x27;iamcco/markdown-preview.nvim&#x27;, &#123; &#x27;do&#x27;: &#123; -&gt; mkdp<span class="hljs-meta">#util#install() &#125;, &#x27;for&#x27;: [&#x27;markdown&#x27;, &#x27;vim-plug&#x27;]&#125;</span><br><span class="hljs-string">&quot;Plug &#x27;puremourning/vimspector&#x27;</span><br><br><br>call plug<span class="hljs-meta">#end()</span><br><span class="hljs-string">&quot;-------------------------------------------------&gt;</span><br><br><span class="hljs-string">&quot;文件插件类型</span><br>filetype plugin indent on<br><br><span class="hljs-string">&quot;vim-gutentags插件设置----------------------------&gt;</span><br>set tags=./.tags;,.tags<br><span class="hljs-string">&quot;gutentags搜索工程目录的标志,碰到这些文件或者目录名就停止向上一级递归</span><br>let g:gutentags_project_root=[&#x27;.root&#x27;,&#x27;.svn&#x27;,&#x27;.git&#x27;,&#x27;.hg&#x27;,&#x27;.project&#x27;]<br><span class="hljs-string">&quot;所生成的数据的文件名称</span><br>let g:gutentags_ctags_tagfile=&#x27;.tags&#x27;<br><span class="hljs-string">&quot;将自动生成的tags文件全部放入~/.cache/tags/目录中，避免污染工程目录</span><br>let s:vim_tags=expand(&#x27;~/.cache/tags&#x27;)<br>let g:gutentags_cache_dir=s:vim_tags<br><span class="hljs-string">&quot;配置ctags的参数</span><br>let g:gutentags_ctags_extra_args=[&#x27;--fields=+niazS&#x27;,&#x27;--extra=+q&#x27;]<br>let g:gutentags_ctags_extra_args+=[&#x27;--c++-kinds=+px&#x27;]<br>let g:gutentags_ctags_extra_args+=[&#x27;--c-kinds=+px&#x27;]<br>let g:gutentags_ctags_extra_args+=[&#x27;--output-format=e-ctags&#x27;]<br><span class="hljs-string">&quot;检测~/.cache/tags,不存在就新建</span><br>if !isdirectory(s:vim_tags)<br>silent! call mkdir(s:vim_tags,&#x27;p&#x27;)<br>endif<br><br><span class="hljs-string">&quot;--------------------------------------------------&gt;</span><br><span class="hljs-string">&quot;YouCompleteMe代码补全插件设置-----------------------------------------&gt;</span><br><span class="hljs-string">&quot;设置补全窗口的背景色</span><br>highlight PMenu ctermfg=<span class="hljs-number">0</span> ctermbg=<span class="hljs-number">242</span> guifg=black guibg=darkgrey<br>highlight PMenuSel ctermfg=<span class="hljs-number">242</span> ctermbg=<span class="hljs-number">8</span> guifg=darkgrey guibg=black<br><br>let g:ycm_add_preview_to_completeopt = <span class="hljs-number">0</span><br>let g:ycm_show_diagnostics_ui = <span class="hljs-number">0</span><br>let g:ycm_server_log_level = &#x27;info&#x27;<br>let g:ycm_min_num_identifier_candidate_chars = <span class="hljs-number">2</span><br>let g:ycm_collect_identifiers_from_comments_and_strings = <span class="hljs-number">1</span><br>let g:ycm_complete_in_strings=<span class="hljs-number">1</span><br>let g:ycm_key_invoke_completion = &#x27;&lt;c-z&gt;&#x27;<br>set completeopt=menu,menuone<br><br>noremap &lt;c-z&gt; &lt;NOP&gt;<br><br>let g:ycm_semantic_triggers =  &#123;<br>\ &#x27;c,cpp,python,java,go,erlang,perl&#x27;: [&#x27;re!\w&#123;2&#125;&#x27;],<br>\ &#x27;cs,lua,javascript&#x27;: [&#x27;re!\w&#123;2&#125;&#x27;],<br>\ &#125;<br><br>let g:ycm_filetype_whitelist = &#123; <br>\ <span class="hljs-string">&quot;c&quot;</span>:<span class="hljs-number">1</span>,<br>\ <span class="hljs-string">&quot;cpp&quot;</span>:<span class="hljs-number">1</span>, <br>\ <span class="hljs-string">&quot;objc&quot;</span>:<span class="hljs-number">1</span>,<br>\ <span class="hljs-string">&quot;sh&quot;</span>:<span class="hljs-number">1</span>,<br>\ <span class="hljs-string">&quot;zsh&quot;</span>:<span class="hljs-number">1</span>,<br>\ <span class="hljs-string">&quot;zimbu&quot;</span>:<span class="hljs-number">1</span>,<br>\ &#125;<br><br><br><span class="hljs-string">&quot;-----------------------------------------------------------------------&gt;</span><br><br><span class="hljs-string">&quot;indentLine插件设置-----------------------------------------------------------------&gt;</span><br>let g:indentLine_char =  &#x27;¦&#x27;<span class="hljs-string">&quot; 设置缩进线字符，也可以为 &#x27;|&#x27;, &#x27;┆&#x27;, &#x27;┊&#x27; 等</span><br>let g:indentLine_conceallevel = <span class="hljs-number">2</span><span class="hljs-string">&quot; 使插件正常运行</span><br><br><span class="hljs-string">&quot;-----------------------------------------------------------------------------------&gt;</span><br><br><br><span class="hljs-string">&quot;asyncrun插件设置-----------------------------------------------------------------&gt;</span><br>let g:asyncrun_rootmarks = [&#x27;.svn&#x27;, &#x27;.git&#x27;, &#x27;.root&#x27;, &#x27;_darcs&#x27;, &#x27;build.xml&#x27;]<br>let g:asyncrun_open=<span class="hljs-number">10</span> <span class="hljs-string">&quot;自动打开quick window窗口，高度为10</span><br>let g:asyncrun_bell=<span class="hljs-number">1</span> <span class="hljs-string">&quot;任务结束响铃提醒</span><br><span class="hljs-string">&quot;设置F1打开关闭quickfix窗口</span><br>noremap &lt;F1&gt; :call asyncrun<span class="hljs-meta">#quickfix_toggle(6)&lt;cr&gt; </span><br><span class="hljs-string">&quot;设置F2单文件：编译(C文件)</span><br>nnoremap &lt;silent&gt; &lt;F2&gt; :AsyncRun! gcc -Wall -O2 <span class="hljs-string">&quot;$(VIM_FILEPATH)&quot;</span> -o <span class="hljs-string">&quot;$(VIM_FILEDIR)/$(VIM_FILENOEXT)&quot;</span> &lt;cr&gt;<br><span class="hljs-string">&quot;设置F3单文件：编译debug版本（C++）</span><br>nnoremap &lt;silent&gt; &lt;F3&gt; :AsyncRun! g++ -g <span class="hljs-string">&quot;$(VIM_FILEPATH)&quot;</span> -o <span class="hljs-string">&quot;$(VIM_FILEDIR)/$(VIM_FILENOEXT)&quot;</span>&lt;cr&gt;<br><span class="hljs-string">&quot;设置F4单文件：编译正常版本（C++）</span><br>nnoremap &lt;silent&gt; &lt;F4&gt; :AsyncRun! g++ -O3 <span class="hljs-string">&quot;$(VIM_FILEPATH)&quot;</span> -o <span class="hljs-string">&quot;$(VIM_FILEDIR)/$(VIM_FILENOEXT)&quot;</span>&lt;cr&gt;<br><span class="hljs-string">&quot;设置F5单文件：运行</span><br><span class="hljs-string">&quot;nnoremap &lt;silent&gt; &lt;F5&gt; :AsyncRun -raw -cwd=$(VIM_FILEDIR) \&quot;</span>$(VIM_FILEDIR)/$(VIM_FILENOEXT)<span class="hljs-string">&quot; &lt;cr&gt;</span><br>nnoremap &lt;silent&gt; &lt;F5&gt; :AsyncRun! -mode=term -pos=right -cols=<span class="hljs-number">60</span> <span class="hljs-string">&quot;$(VIM_PATHNOEXT)&quot;</span>&lt;cr&gt;<br><br><span class="hljs-string">&quot;设置F7项目：编译</span><br>nnoremap &lt;silent&gt; &lt;F7&gt; :AsyncRun! -cwd=&lt;root&gt; make &lt;cr&gt;<br><span class="hljs-string">&quot;设置F8项目：运行</span><br>nnoremap &lt;silent&gt; &lt;F8&gt; :AsyncRun! -cwd=&lt;root&gt; -raw make run &lt;cr&gt;<br><span class="hljs-string">&quot;退出运行时的终端窗口terminal</span><br>nnoremap &lt;leader&gt;w :exit&lt;cr&gt;<br><br><span class="hljs-string">&quot;--------------------------------------------------------------------------------&gt;&quot;</span><br><br><span class="hljs-string">&quot;NERDTree插件设置-----------------------------------------------------------------&gt;</span><br><span class="hljs-string">&quot;设置目录箭头</span><br>let g:NERDTreeDirArrowExpandable = &#x27;⇨⇨⇨&#x27;<br>let g:NERDTreeDirArrowCollapsible = &#x27;➤➤➤&#x27;<br><span class="hljs-string">&quot; 在 vim 启动的时候默认开启 NERDTree（autocmd 可以缩写为 au）</span><br><span class="hljs-string">&quot;autocmd VimEnter * NERDTree</span><br><span class="hljs-string">&quot;定位当前文件的位置，类似于eclipse的link with edited</span><br>nnoremap &lt;C-f&gt; :NERDTreeFind&lt;CR&gt;<br><span class="hljs-string">&quot;打开关闭目录树</span><br>nnoremap &lt;C-n&gt; :NERDTreeToggle&lt;CR&gt;<br><span class="hljs-string">&quot;如果 NERDTree 是唯一选项卡中剩下的唯一窗口，则退出 Vim</span><br>autocmd BufEnter * if tabpagenr(&#x27;$&#x27;) == <span class="hljs-number">1</span> <span class="hljs-meta">&amp;&amp; winnr(&#x27;$&#x27;) == 1 &amp;&amp; exists(&#x27;b:NERDTree&#x27;) &amp;&amp; b:NERDTree.isTabTree() | quit | endif</span><br><span class="hljs-string">&quot;如果 NERDTree 是其中唯一剩余的窗口，请关闭选项卡</span><br>autocmd BufEnter * if winnr(&#x27;$&#x27;) == <span class="hljs-number">1</span> <span class="hljs-meta">&amp;&amp; exists(&#x27;b:NERDTree&#x27;) &amp;&amp; b:NERDTree.isTabTree() | quit | endif</span><br><span class="hljs-string">&quot;关闭当前标签页</span><br>nnoremap &lt;leader&gt;c :tabc&lt;CR&gt;<br><span class="hljs-string">&quot;关闭其它标签页</span><br>nnoremap &lt;leader&gt;o :tabo&lt;CR&gt;<br><span class="hljs-string">&quot;前一个tab标签页</span><br>nnoremap &lt;leader&gt;m :tabp&lt;CR&gt;<br><span class="hljs-string">&quot;下一个标签页</span><br>nnoremap &lt;leader&gt;n :tabn&lt;CR&gt;<br><br><span class="hljs-string">&quot;---------------------------------------------------------------------------------&gt;&quot;</span><br><br><span class="hljs-string">&quot;vimspector插件设置-----------------------------------------------------------------&gt;</span><br><span class="hljs-string">&quot;F5 debugger/ Shift F5 stop debugger/ Ctrl+Shift+F5 restart debugger</span><br><span class="hljs-string">&quot;F6 pause debugger</span><br><span class="hljs-string">&quot;F9 Toggle line breakpoint on the current line</span><br><span class="hljs-string">&quot;Shift F9 Add a function breakpoint for the expression under cursor</span><br><span class="hljs-string">&quot;F10 Step Over</span><br><span class="hljs-string">&quot;F11 Step into</span><br><span class="hljs-string">&quot;Shift F11 Step out of current function scope</span><br><span class="hljs-string">&quot;let g:vimspector_enable_mappings = &#x27;VISUAL_STUDIO&#x27;</span><br><span class="hljs-string">&quot;nnoremap &lt;leader&gt;e :VimspectorReset&lt;CR&gt;</span><br><span class="hljs-string">&quot;---------------------------------------------------------------------------------&gt;&quot;</span><br><br><span class="hljs-string">&quot;vim8自带的Termdebug插件设置-----------------------------------------------------------------&gt;</span><br><span class="hljs-string">&quot;F6进入debug当前文件模式</span><br>nnoremap &lt;silent&gt; &lt;F6&gt; :packadd termdebug&lt;cr&gt;:Termdebug %:r&lt;cr&gt;<br><br><span class="hljs-string">&quot;---------------------------------------------------------------------------------&gt;&quot;</span><br><br><span class="hljs-string">&quot;vim8使用CGDB进行调试-----------------------------------------------------------------&gt;</span><br>nnoremap &lt;space&gt;cd :!cgdb %:r&lt;cr&gt;<br><span class="hljs-string">&quot;---------------------------------------------------------------------------------&gt;&quot;</span><br><br><br><span class="hljs-string">&quot;Markdownd插件设置----------------------------------------------------------------&gt;</span><br>imap &lt;C-s&gt; &lt;Plug&gt;MarkdownPreview<br><span class="hljs-string">&quot;---------------------------------------------------------------------------------&gt;&quot;</span><br><br><br><span class="hljs-string">&quot;---------------------------------------------------------------------------------&gt;&quot;</span><br><br><span class="hljs-string">&quot;---------------------------------------------------------------------------------&gt;&quot;</span><br><span class="hljs-string">&quot;====================================================================================================================&gt;</span><br><br><br></code></pre></td></tr></table></figure><img src="/2022/10/24/%E4%B8%AA%E4%BA%BAvim%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/vimrc1.png" class=""><img src="/2022/10/24/%E4%B8%AA%E4%BA%BAvim%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/vimrc2.png" class=""><img src="/2022/10/24/%E4%B8%AA%E4%BA%BAvim%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/vimrc3.png" class=""><img src="/2022/10/24/%E4%B8%AA%E4%BA%BAvim%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/vimrc4.png" class=""><img src="/2022/10/24/%E4%B8%AA%E4%BA%BAvim%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/vimrc5.png" class="">]]></content>
    
    
    <categories>
      
      <category>vim</category>
      
    </categories>
    
    
    <tags>
      
      <tag>个人配置</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
