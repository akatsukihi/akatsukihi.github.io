<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>2023/05/09</title>
    <link href="/2023/05/09/2023-05-09/"/>
    <url>/2023/05/09/2023-05-09/</url>
    
    <content type="html"><![CDATA[<p>短暂的相聚总是让人不舍  </p><img src="/2023/05/09/2023-05-09/1.jpg" class="">]]></content>
    
    
    <categories>
      
      <category>杂记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>生活</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2023/04/30</title>
    <link href="/2023/04/30/2023-04-30/"/>
    <url>/2023/04/30/2023-04-30/</url>
    
    <content type="html"><![CDATA[<p>临时起意，决定回家！时间虽然仓促了一些，但是，人生的面总是见一次会少一次，很多的东西应该也是没法用世俗<br>的东西来估量的吧。  </p><img src="/2023/04/30/2023-04-30/2.jpg" class=""><p></p><p></p>]]></content>
    
    
    <categories>
      
      <category>杂记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>生活</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>linux套接字（一）</title>
    <link href="/2023/04/15/linux%E5%A5%97%E6%8E%A5%E5%AD%97%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <url>/2023/04/15/linux%E5%A5%97%E6%8E%A5%E5%AD%97%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="阻塞套接字"><a href="#阻塞套接字" class="headerlink" title="阻塞套接字"></a>阻塞套接字</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;asm-generic/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;netinet/in.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;unistd.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;errno.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;arpa/inet.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> sfd, cfd;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">sockaddr_in</span> serv_addr, cli_addr;<br>    <span class="hljs-type">socklen_t</span> sin_size;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> port = <span class="hljs-number">10086</span>;<br>    <br>    std::cout&lt;&lt;<span class="hljs-string">&quot;Server Init&quot;</span>&lt;&lt;std::endl;<br>    sfd = <span class="hljs-built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span>(sfd == <span class="hljs-number">-1</span>)<br>    &#123;<br>        std::cout&lt;&lt;<span class="hljs-string">&quot;socket create fail!&quot;</span>&lt;&lt;std::endl;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    std::cout&lt;&lt;<span class="hljs-string">&quot;socket create success&quot;</span>&lt;&lt;std::endl;<br>    <span class="hljs-comment">/* 允许地址立即重用 */</span><br>    <span class="hljs-type">int</span> on = <span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">setsockopt</span>(sfd, SOL_SOCKET, SO_REUSEADDR, &amp;on, <span class="hljs-built_in">sizeof</span>(on));<br>    <span class="hljs-built_in">bzero</span>(&amp;serv_addr, <span class="hljs-built_in">sizeof</span>(<span class="hljs-keyword">struct</span> sockaddr_in));<br>    serv_addr.sin_family = AF_INET;<br>    serv_addr.sin_addr.s_addr = <span class="hljs-built_in">htonl</span>(INADDR_ANY);<br>    serv_addr.sin_port = <span class="hljs-built_in">htons</span>(port);<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">bind</span>(sfd, (<span class="hljs-keyword">struct</span> sockaddr*)(&amp;serv_addr), <span class="hljs-built_in">sizeof</span>(<span class="hljs-keyword">struct</span> sockaddr)) == <span class="hljs-number">-1</span>)<br>    &#123;<br>        std::cout&lt;&lt;<span class="hljs-string">&quot;socket bind fail!&quot;</span>&lt;&lt;std::endl;<br>        std::cout&lt;&lt;<span class="hljs-string">&quot;errno : &quot;</span>&lt;&lt;errno&lt;&lt;std::endl;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    std::cout&lt;&lt;<span class="hljs-string">&quot;socket bind success&quot;</span>&lt;&lt;std::endl;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">listen</span>(sfd, <span class="hljs-number">10</span>) == <span class="hljs-number">-1</span>)<br>    &#123;<br>        std::cout&lt;&lt;<span class="hljs-string">&quot;listen fail!&quot;</span>&lt;&lt;std::endl;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    std::cout&lt;&lt;<span class="hljs-string">&quot;socket listen ok&quot;</span>&lt;&lt;std::endl;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)<br>    &#123;<br>        sin_size = <span class="hljs-built_in">sizeof</span>(<span class="hljs-keyword">struct</span> sockaddr_in);<br>        cfd = <span class="hljs-built_in">accept</span>(sfd, (<span class="hljs-keyword">struct</span> sockaddr*)(&amp;cli_addr), &amp;sin_size);<br>        <span class="hljs-keyword">if</span>(cfd == <span class="hljs-number">-1</span>)<br>        &#123;<br>            std::cout&lt;&lt;<span class="hljs-string">&quot;socket accept fail!&quot;</span>&lt;&lt;std::endl;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>        &#125;<br>        std::cout&lt;&lt;<span class="hljs-string">&quot;socket accept ok&quot;</span>&lt;&lt;std::endl;<br>        std::cout&lt;&lt;<span class="hljs-string">&quot;client ip = &quot;</span>&lt;&lt;<span class="hljs-built_in">inet_ntoa</span>(cli_addr.sin_addr) &lt;&lt;<span class="hljs-string">&quot;, port = &quot;</span>&lt;&lt;<span class="hljs-built_in">ntohs</span>(cli_addr.sin_port)&lt;&lt; std::endl;<br>        <span class="hljs-built_in">write</span>(cfd, <span class="hljs-string">&quot;hello , from server&quot;</span>,<span class="hljs-number">32</span>);<br>        std::cout&lt;&lt;<span class="hljs-string">&quot;write over&quot;</span>&lt;&lt;std::endl;<br>        <span class="hljs-built_in">close</span>(cfd);<br>        <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;continue to listen(y/n)?&quot;</span>);<br>        <span class="hljs-type">char</span> input[<span class="hljs-number">2</span>];<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>, input, <span class="hljs-number">2</span>);<br>        <span class="hljs-keyword">if</span>(input[<span class="hljs-number">0</span>] != <span class="hljs-string">&#x27;y&#x27;</span>)<br>            <span class="hljs-keyword">break</span>;<br>    &#125;<br>    std::cout&lt;&lt;<span class="hljs-string">&quot;bye&quot;</span>&lt;&lt;std::endl;<br>    <span class="hljs-built_in">close</span>(sfd);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/socket.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;netinet/in.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;arpa/inet.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;unistd.h&quot;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> cfd, recbyte, sin_size;<br>    <span class="hljs-type">char</span> buf[<span class="hljs-number">1024</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">sockaddr_in</span> serv_addr;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> port = <span class="hljs-number">10086</span>;<br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span>* ip = <span class="hljs-string">&quot;172.22.68.99&quot;</span>;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Client sockeet\n&quot;</span>);<br>    cfd = <span class="hljs-built_in">socket</span>(AF_INET, SOCK_STREAM, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span>(cfd == <span class="hljs-number">-1</span>)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;client create socket fail!\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;client create socket success\n&quot;</span>);<br>    <span class="hljs-built_in">bzero</span>(&amp;serv_addr, <span class="hljs-built_in">sizeof</span>(<span class="hljs-keyword">struct</span> sockaddr_in));<br>    serv_addr.sin_addr.s_addr = <span class="hljs-built_in">inet_addr</span>(ip);<br>    serv_addr.sin_family = AF_INET;<br>    serv_addr.sin_port = <span class="hljs-built_in">htons</span>(port);<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">connect</span>(cfd, (<span class="hljs-keyword">struct</span> sockaddr*)(&amp;serv_addr), <span class="hljs-built_in">sizeof</span>(<span class="hljs-keyword">struct</span> sockaddr)) == <span class="hljs-number">-1</span>)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;client connect server fail!\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;client connect server success\n&quot;</span>);<br>    <span class="hljs-keyword">if</span>((recbyte = <span class="hljs-built_in">read</span>(cfd, buf, <span class="hljs-built_in">sizeof</span>(buf))) == <span class="hljs-number">-1</span>)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;receive data fail!\n&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;read data ok\n&quot;</span>);<br>    buf[recbyte] = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;from server data: %s \n&quot;</span>, buf);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;press any key quit&quot;</span>);<br>    <span class="hljs-built_in">getchar</span>();<br>    <span class="hljs-built_in">close</span>(cfd);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>socket</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2023/03/27~04/02</title>
    <link href="/2023/04/04/%E3%80%8A2023-03-27-04-02%E3%80%8B/"/>
    <url>/2023/04/04/%E3%80%8A2023-03-27-04-02%E3%80%8B/</url>
    
    <content type="html"><![CDATA[<p>又到了一年看樱花的季节。</p><img src="/2023/04/04/%E3%80%8A2023-03-27-04-02%E3%80%8B/1.jpg" class=""><p></p><p></p><img src="/2023/04/04/%E3%80%8A2023-03-27-04-02%E3%80%8B/2.jpg" class=""><p></p><p></p><img src="/2023/04/04/%E3%80%8A2023-03-27-04-02%E3%80%8B/3.jpg" class=""><p></p><p></p><img src="/2023/04/04/%E3%80%8A2023-03-27-04-02%E3%80%8B/4.jpg" class=""><p></p><p></p><img src="/2023/04/04/%E3%80%8A2023-03-27-04-02%E3%80%8B/5.jpg" class=""><p></p><p></p><img src="/2023/04/04/%E3%80%8A2023-03-27-04-02%E3%80%8B/6.jpg" class=""><p></p><p></p><img src="/2023/04/04/%E3%80%8A2023-03-27-04-02%E3%80%8B/7.jpg" class=""><p></p><p></p><img src="/2023/04/04/%E3%80%8A2023-03-27-04-02%E3%80%8B/8.jpg" class=""><p></p><p></p><img src="/2023/04/04/%E3%80%8A2023-03-27-04-02%E3%80%8B/9.jpg" class=""><p></p><p></p><img src="/2023/04/04/%E3%80%8A2023-03-27-04-02%E3%80%8B/10.jpg" class=""><p></p><p></p><img src="/2023/04/04/%E3%80%8A2023-03-27-04-02%E3%80%8B/11.jpg" class=""><p></p><p></p><img src="/2023/04/04/%E3%80%8A2023-03-27-04-02%E3%80%8B/12.jpg" class=""><p></p><p></p><img src="/2023/04/04/%E3%80%8A2023-03-27-04-02%E3%80%8B/13.jpg" class=""><p></p><p></p><img src="/2023/04/04/%E3%80%8A2023-03-27-04-02%E3%80%8B/14.jpg" class=""><p></p><p></p><img src="/2023/04/04/%E3%80%8A2023-03-27-04-02%E3%80%8B/15.jpg" class=""><p></p><p></p><img src="/2023/04/04/%E3%80%8A2023-03-27-04-02%E3%80%8B/16.jpg" class=""><p></p><p></p><img src="/2023/04/04/%E3%80%8A2023-03-27-04-02%E3%80%8B/17.jpg" class=""><p></p><p></p><img src="/2023/04/04/%E3%80%8A2023-03-27-04-02%E3%80%8B/18.jpg" class=""><p></p><p></p><img src="/2023/04/04/%E3%80%8A2023-03-27-04-02%E3%80%8B/19.jpg" class=""><p></p><p></p><img src="/2023/04/04/%E3%80%8A2023-03-27-04-02%E3%80%8B/20.jpg" class=""><p></p><p></p><img src="/2023/04/04/%E3%80%8A2023-03-27-04-02%E3%80%8B/21.jpg" class=""><p></p><p></p><img src="/2023/04/04/%E3%80%8A2023-03-27-04-02%E3%80%8B/22.jpg" class=""><p></p><p></p>]]></content>
    
    
    <categories>
      
      <category>杂记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>生活</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>linux多线程（四）</title>
    <link href="/2023/03/27/linux%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88%E5%9B%9B%EF%BC%89/"/>
    <url>/2023/03/27/linux%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88%E5%9B%9B%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="c-11-x2F-14下的线程同步"><a href="#c-11-x2F-14下的线程同步" class="headerlink" title="c++11&#x2F;14下的线程同步"></a>c++11&#x2F;14下的线程同步</h2><p>c++11&#x2F;14提供了两种方式进行线程同步，即互斥锁和条件变量。c++11中的条件变量在实际编程中用的不多。同posix<br>线程库一样，c++也提供了互斥锁来同步线程对共享资源的访问，而且是语言级别上的支持。c++中与互斥锁相关的类<br>（包括锁类型）和函数都声明在头文件<mutex>中，如果需要使用互斥锁和相关的类，就必须包含头文件<mutex>。<br>c++中的互斥锁有四种，对应着四种不同的类：   </p><blockquote><ul><li>(1) 基本互斥锁，对应的类为std::mutex。</li><li>(2) 递归互斥锁，对应的类为std::recursive_mutex。</li><li>(3) 定时互斥锁，对应的类为std::timed_mutex。</li><li>(4) 定时递归互斥锁，对应的类std::recursive_timed_mutex。</li></ul></blockquote><p>这些类都包含上锁的成员函数lock、try_lock以及解锁的成员函数unlock。   </p><h3 id="基本互斥锁-std-mutex"><a href="#基本互斥锁-std-mutex" class="headerlink" title="基本互斥锁 std::mutex"></a>基本互斥锁 std::mutex</h3><p>类std::mutex是最基本的互斥锁，用来同步线程对临界资源的互斥访问。它的成员函数如下所示：  </p><img src="/2023/03/27/linux%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88%E5%9B%9B%EF%BC%89/1.png" class=""><p></p>  <p>函数lock用来对一个互斥锁上锁，如果互斥锁当前没有被上锁，则当前线程（调用线程，调用该函数的线程）可以成<br>功对互斥锁上锁，即当前线程拥有互斥锁，直到当前线程调用解锁函数unlock。如果互斥锁已经被其它线程上锁了，<br>则当前线程挂起，直到互斥锁被其它线程解锁。如果互斥锁已经被当前线程上锁了，则再次调用该函数时将死锁，若<br>需要递归上锁，则可以调用成员函数recursive_mutex。lock函数声明如下：  </p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">lock</span>()</span>;<br></code></pre></td></tr></table></figure><p>函数unlock用来对一个互斥锁解锁，释放调用线程对其拥有的所有权。如果有其它线程因为要对互斥锁上锁而阻塞着<br>则互斥锁被调用线程解锁后，阻塞着的其它线程就可以继续往下执行了。即能对互斥锁上锁了。如果互斥锁当前没有<br>被调用线程上锁，则调用线程调用unlock后将产生不可预知的结果，函数unlock声明如下：  </p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">unlock</span>()</span>;<br></code></pre></td></tr></table></figure><p>注意：lock和unlock都要被调用线程配对使用。</p><p>示例：多线程累加到1000万   </p><img src="/2023/03/27/linux%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88%E5%9B%9B%EF%BC%89/2.png" class=""><p></p>  <h3 id="定时互斥锁std-timed-mutex"><a href="#定时互斥锁std-timed-mutex" class="headerlink" title="定时互斥锁std::timed_mutex"></a>定时互斥锁std::timed_mutex</h3><p>类std::timed_mutex是定时互斥锁，与基本互斥锁类似，不同点在于多了定时。</p><img src="/2023/03/27/linux%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88%E5%9B%9B%EF%BC%89/3.png" class=""><p></p>  <p>函数try_lock()尝试给互斥锁上锁，如果互斥锁被其它线程占有，则当前线程也不会阻塞，线程调用该函数会出现3<br>中情况：① 如果当前互斥锁没有被其它线程占有，则该线程锁住互斥锁，直到该线程调用unlock释放互斥锁；②如果<br>当前互斥锁被其它线程锁住，则当前调用线程返回false，而并不会被阻塞掉；③如果当前互斥锁被当前调用线程锁住<br>则会产生死锁。try_lock()声明如下：  </p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-built_in">bool</span> <span class="hljs-title">try_lock</span>()</span>;<br></code></pre></td></tr></table></figure><p>如果函数成功上锁，则返回true，否则返回false。该函数不会阻塞，不能上锁时将立即返回false。  </p><p>示例：使用非阻塞上锁方式累加到1000万</p><img src="/2023/03/27/linux%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88%E5%9B%9B%EF%BC%89/4.png" class=""><p></p>  <h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><p>线程池就是一堆已经创建好了的线程，初始都处于空闲等待状态，当有新的任务需要处理的时候，就从这堆线程中<br>取一个空闲等待的线程来处理该任务，当任务处理完毕后，就再次把该线程放回池中（一般就是将线程状态置为空闲）<br>以供后面的任务继续使用。当池子里的线程全都处于忙碌状态时，线程池中没有可用的空闲等待线程，此时根据需要<br>选择创建一个新的线程并置入池中，或者通知任务当前线程池里所有线程都在忙，稍后再进行尝试，这个过程如下：  </p><img src="/2023/03/27/linux%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88%E5%9B%9B%EF%BC%89/5.png" class=""><p></p>  <p>线程池的创建和销毁相对于进程的创建和销毁来说是轻量级的（开销比进程小），但是当任务需要进行大量线程的创<br>建和销毁操作时，这些开销合在一起就比较大了。比如，当设计一个压力性能测试框架的时候，需要连续产生大量的<br>并发操作。线程池在这种场合是非常适用的。线程池的好处就在于线程复用，某个线程在处理完一个任务后，可以继<br>续处理下一个任务，而不用销毁后再创建，这样可以避免无谓的开销，因此线程池尤其适用于连续产生大量并发任务<br>的场合。  </p><h3 id="一个简单的线程池"><a href="#一个简单的线程池" class="headerlink" title="一个简单的线程池"></a>一个简单的线程池</h3><img src="/2023/03/27/linux%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88%E5%9B%9B%EF%BC%89/6.png" class=""><img src="/2023/03/27/linux%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88%E5%9B%9B%EF%BC%89/7.png" class=""><img src="/2023/03/27/linux%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88%E5%9B%9B%EF%BC%89/8.png" class=""><img src="/2023/03/27/linux%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88%E5%9B%9B%EF%BC%89/9.png" class=""><p></p>   <p>测试类如下：   </p><img src="/2023/03/27/linux%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88%E5%9B%9B%EF%BC%89/10.png" class=""><img src="/2023/03/27/linux%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88%E5%9B%9B%EF%BC%89/11.png" class=""><img src="/2023/03/27/linux%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88%E5%9B%9B%EF%BC%89/12.png" class="">]]></content>
    
    
    <categories>
      
      <category>linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2023/03/18</title>
    <link href="/2023/03/18/%E3%80%8A2023-03-18%E3%80%8B/"/>
    <url>/2023/03/18/%E3%80%8A2023-03-18%E3%80%8B/</url>
    
    <content type="html"><![CDATA[<p>这周二的时候，国内宝钛的一个朋友发微信给我，托我帮他写一个excel公式，他说他们厂现在材料下料时都是靠人工<br>经验，能不能用excel函数写一个总宽度和不同分宽度个数的关系式，使材料利用率最高，他们每次输入一个总宽度，<br>再输入几个分宽度的规格数据，计算一下每个宽度分多少个时，材料的利用率是最高的，给一个最高分配率的方案，<br>他说最多五个规格参数。看到他的要求时，第一念头就否定了excel的函数，要用excel做的话只能写vba了，而且这是<br>个典型的动态规划问题，纯纯的算法问题。这个问题的大号版本有点像内存分配函数，不过这个问题远比内存简单的<br>多，可以使用贪心算法或者动态规划算法，也可以暴力破解，最简单的方法就是暴力破解，解出所有答案然后选择最<br>优的答案，因为最近比较忙，所以选了最简单的暴力破解，然后做了个控制台的程序，有一个配置文件，修改配置文<br>件中的总宽度和要截取的规格大小然后执行一下控制台的程序就可以给出一个最优解。<br>（算法参考了最近很火的ChatGPT，不得不说ChatGPT已经强大到可以替换掉很多人了）</p>]]></content>
    
    
    <categories>
      
      <category>杂记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>生活</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>linux多线程（三）</title>
    <link href="/2023/03/12/linux%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <url>/2023/03/12/linux%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88%E4%B8%89%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h2><p>并发和异步机制带来了线程间资源竞争的无序性。因此需要引入同步机制来消除这种复杂度以实现线程间正确有序的<br>共享数据。线程同步是多线程编程中的重要概念，它的基本思想是同步各个线程对资源（如全局变量、文件）的访问<br>如果不对资源访问进行线程同步，则会产生资源访问冲突的问题。然而对于多线程程序，访问冲突的问题是很普遍的<br>解决的办法是引入锁（如互斥锁、读写锁），获得锁的线程可以完成“读-修改-写”的操作，然后释放锁给其它线程<br>没有获得锁的线程只能等待而不能访问共享数据，这样“读-修改-写”的三步骤操作组成一个原子操作，要么都执行<br>要么都不执行，不会执行到中间被打断，也不会在其它处理器上并行做这个操作。<br>如果一个线程正在读取一个全局变量，虽然读取全局变量的这个语句在c&#x2F;c++源代码中是一条语句，但编译为机器代<br>码后，cpu在处理这个的时候，需要使用多条指令来处理读取变量的过程，如果这一系列指令被另一个线程打断了，<br>也就是说cpu还没执行完全部读取变量的所有指令，而去执行另一个线程了，另一个线程却要对这个全局变量进行修改<br>，这样修改完后又返回原先的线程，继续执行读取变量的剩余指令，此时变量的值就有可能已经被修改过了，这样第<br>一个线程的执行结果就是不可预料的结果了。    </p><p>以下是多线程访问共享变量造成竞争的例子，假设增量操作分为三个步骤：   </p><blockquote><ul><li>(1) 从内存单元读入寄存器。</li><li>(2) 在寄存器中进行变量值的增加。</li><li>(3) 把新的值写回内存单元。</li></ul></blockquote><p>那么当两个线程对同一个变量做增加操作时，就可能出现如下所示的情况：  </p><img src="/2023/03/12/linux%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88%E4%B8%89%EF%BC%89/1.png" class=""><p></p>  <p>如果两个线程在串行操作下分别对i进行了累加，那么i的值就应该是7了，但上图中的两个线程执行后的i值是6，因为<br>B线程并没有等A线程做完i+1后开始执行，而是A线程刚刚把i从内存读入寄存器后就开始执行了，所以B线程也是在i&#x3D;5<br>的时候开始执行，这样A执行的结果是6，B执行的结果也是6，因此在这种没有做同步的情况下，多个线程对全局变量<br>进行累加，最终结果是小于或等于它们的串行操作结果的。  </p><p>示例：未使用线程同步的多线程累加 </p><img src="/2023/03/12/linux%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88%E4%B8%89%EF%BC%89/2.png" class=""><img src="/2023/03/12/linux%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88%E4%B8%89%EF%BC%89/3.png" class=""><img src="/2023/03/12/linux%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88%E4%B8%89%EF%BC%89/4.png" class=""><p></p>  <p>上图可以看到都是大于10000000而小于20000000，该例子是累加被打断的情况。还有事务被打断的情况，事务被打断<br>的情况是指，一个事务需要多条语句完成，且不应打断，如果打断的话，其它需要这个事务结果的线程则可能会得到<br>非预料的结果。   </p><p>示例：卖货和清点货物金钱总合，一个线程代表卖货收钱的事务，另一个线程模拟验证总合的操作，抽象的看就是一<br>个线程对全局变量进行写操作，另一个线程对全局变量进行读操作。  </p><img src="/2023/03/12/linux%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88%E4%B8%89%EF%BC%89/5.png" class=""><img src="/2023/03/12/linux%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88%E4%B8%89%EF%BC%89/6.png" class=""><p></p>  <p>示例中的卖货线程会被对账线程打断，所以会出现账目不平的情况。  </p><p>临界资源，所谓的临界资源是一次仅允许一个线程使用的共享资源 。对于临界资源，各线程应该互斥地对齐访问。每<br>个线程中访问临界资源的那段代码称为临界区（Critical Section），又称临界段。因为临界资源要求每个线程互斥<br>地对其访问，所以每次只准许一个线程进入临界区，进入后其它进程不允许再进入，一直要等到临界区中的线程退出。<br>可以使用线程同步机制来互斥的进入临界区。一般进入临界区需要遵循以下原则：  </p><blockquote><ul><li>(1) 如果有若干线程要求进入空闲的临界区，一次仅允许一个线程进入。</li><li>(2) 任何时候，处于临界区内的线程不可多于一个，若已有线程进入自己的临界区，则其它所有试图进入临界区<br>的线程必须等待。</li><li>(3) 进入临界区的线程要在有限时间内退出，以便其它线程能及时进入自己的临界区。</li><li>(4) 如果进程不能进入自己的临界区，则应让出cpu（阻塞），避免进程出现“忙等”现象。</li></ul></blockquote><h2 id="利用posix函数进行线程同步"><a href="#利用posix函数进行线程同步" class="headerlink" title="利用posix函数进行线程同步"></a>利用posix函数进行线程同步</h2><p>posix提供了三种方式来进行线程同步：互斥锁、读写锁和条件变量。  </p><h3 id="1-互斥锁"><a href="#1-互斥锁" class="headerlink" title="1.互斥锁"></a>1.互斥锁</h3><p>互斥锁（也称互斥量）是线程同步的一种机制，用来保护多线程的共享资源。同一时刻，只允许一个线程对临界区进<br>行访问。互斥锁的工作流程是：初始化一个互斥锁，在进入临界区前把互斥锁加锁（防止其它线程进入临界区），退<br>出临界区的时候把互斥锁解锁（让其它线程有机会进入临界区），最后不用互斥锁的时候销毁它。posix库中用类型<br>pthread_mutex_t来定义一个互斥锁。pthread_mutex_t是一个联合体类型，定义在篇threadtypes.h中，具体如下：  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> _BITS_PTHREADTYPES_COMMON_H</span><br><span class="hljs-meta"># <span class="hljs-keyword">define</span> _BITS_PTHREADTYPES_COMMON_H    1</span><br><br><span class="hljs-comment">/* For internal mutex and condition variable definitions.  */</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/thread-shared-types.h&gt;</span></span><br><br><span class="hljs-comment">/* Thread identifiers.  The structure of the attribute type is not</span><br><span class="hljs-comment">   exposed on purpose.  */</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">int</span> <span class="hljs-type">pthread_t</span>;<br><br><br><span class="hljs-comment">/* Data structures for mutex handling.  The structure of the attribute</span><br><span class="hljs-comment">   type is not exposed on purpose.  */</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">union</span><br>&#123;<br>  <span class="hljs-type">char</span> __size[__SIZEOF_PTHREAD_MUTEXATTR_T];<br>  <span class="hljs-type">int</span> __align;<br>&#125; <span class="hljs-type">pthread_mutexattr_t</span>;<br><br><br><span class="hljs-comment">/* Data structure for condition variable handling.  The structure of</span><br><span class="hljs-comment">   the attribute type is not exposed on purpose.  */</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">union</span><br>&#123;<br>  <span class="hljs-type">char</span> __size[__SIZEOF_PTHREAD_CONDATTR_T];<br>  <span class="hljs-type">int</span> __align;<br>&#125; <span class="hljs-type">pthread_condattr_t</span>;<br><br><br><span class="hljs-comment">/* Keys for thread-specific data */</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> <span class="hljs-type">pthread_key_t</span>;<br><br><br><span class="hljs-comment">/* Once-only execution */</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> __ONCE_ALIGNMENT <span class="hljs-type">pthread_once_t</span>;<br><br><br><span class="hljs-keyword">union</span> <span class="hljs-title class_">pthread_attr_t</span><br>&#123;<br>  <span class="hljs-type">char</span> __size[__SIZEOF_PTHREAD_ATTR_T];<br>  <span class="hljs-type">long</span> <span class="hljs-type">int</span> __align;<br>&#125;;<br><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> __have_pthread_attr_t</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">union</span> <span class="hljs-title class_">pthread_attr_t</span> <span class="hljs-type">pthread_attr_t</span>;<br><span class="hljs-meta"># <span class="hljs-keyword">define</span> __have_pthread_attr_t 1</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">union</span><br>&#123;<br>  <span class="hljs-keyword">struct</span> <span class="hljs-title class_">__pthread_mutex_s</span> __data;<br>  <span class="hljs-type">char</span> __size[__SIZEOF_PTHREAD_MUTEX_T];<br>  <span class="hljs-type">long</span> <span class="hljs-type">int</span> __align;<br>&#125; <span class="hljs-type">pthread_mutex_t</span>;<br><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">union</span><br>&#123;<br>  <span class="hljs-keyword">struct</span> <span class="hljs-title class_">__pthread_cond_s</span> __data;<br>  <span class="hljs-type">char</span> __size[__SIZEOF_PTHREAD_COND_T];<br>  __extension__ <span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-type">int</span> __align;<br>&#125; <span class="hljs-type">pthread_cond_t</span>;<br><br><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> defined __USE_UNIX98 || defined __USE_XOPEN2K</span><br><span class="hljs-comment">/* Data structure for reader-writer lock variable handling.  The</span><br><span class="hljs-comment">   structure of the attribute type is deliberately not exposed.  */</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">union</span><br>&#123;<br>  <span class="hljs-keyword">struct</span> <span class="hljs-title class_">__pthread_rwlock_arch_t</span> __data;<br>  <span class="hljs-type">char</span> __size[__SIZEOF_PTHREAD_RWLOCK_T];<br>  <span class="hljs-type">long</span> <span class="hljs-type">int</span> __align;<br>&#125; <span class="hljs-type">pthread_rwlock_t</span>;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">union</span><br>&#123;<br>  <span class="hljs-type">char</span> __size[__SIZEOF_PTHREAD_RWLOCKATTR_T];<br>  <span class="hljs-type">long</span> <span class="hljs-type">int</span> __align;<br>&#125; <span class="hljs-type">pthread_rwlockattr_t</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> __USE_XOPEN2K</span><br><span class="hljs-comment">/* POSIX spinlock data type.  */</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> <span class="hljs-type">pthread_spinlock_t</span>;<br><br><br><span class="hljs-comment">/* POSIX barriers data type.  The structure of the type is</span><br><span class="hljs-comment">   deliberately not exposed.  */</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">union</span><br>&#123;<br>  <span class="hljs-type">char</span> __size[__SIZEOF_PTHREAD_BARRIER_T];<br>  <span class="hljs-type">long</span> <span class="hljs-type">int</span> __align;<br>&#125; <span class="hljs-type">pthread_barrier_t</span>;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">union</span><br>&#123;<br>  <span class="hljs-type">char</span> __size[__SIZEOF_PTHREAD_BARRIERATTR_T];<br>  <span class="hljs-type">int</span> __align;<br>&#125; <span class="hljs-type">pthread_barrierattr_t</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><p>使用的时候不需要包含该pthreadtypes.h头文件，只需要包含pthread.h文件即可，因为pthread.h中包含该头文件。<br>定义互斥锁变量：  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">pthread_mutex_t</span> mutex;<br></code></pre></td></tr></table></figure><h4 id="互斥锁初始化"><a href="#互斥锁初始化" class="headerlink" title="互斥锁初始化"></a>互斥锁初始化</h4><p>用于初始化互斥锁的函数是pthread_mutex_init，声明如下：  </p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-built_in">int</span> pthread<span class="hljs-constructor">_mutex_init(<span class="hljs-params">pthread_mutex_t</span> <span class="hljs-operator">*</span><span class="hljs-params">restrict</span> <span class="hljs-params">mutex</span>, <span class="hljs-params">const</span> <span class="hljs-params">pthread_mutexattr_t</span> <span class="hljs-operator">*</span><span class="hljs-params">restrict</span> <span class="hljs-params">attr</span>)</span>;<br></code></pre></td></tr></table></figure><p>其中，参数mutex是指向pthread_mutex_t变量的指针；attr是指向pthread_mutexattr_t的指针，标识互斥锁的属性，<br>如果赋值NULL，则使用默认的互斥锁属性，该参数通常使用NULL。如果函数执行成功就返回0，否则返回错误码。<br>注意：关键字restrict只用于限定指针，用于告知编译器所有修改该指针所指向内容的操作全部都是基于该指针的，<br>即不存在其它进行修改操作的途径，这样可以帮助编译器进行更好的代码优化，生成效率更高的汇编代码。（通俗讲<br>就是告诉编译器，两个指针不会指向同一数据）。<br>使用pthread_mutex_init初始化互斥锁属于动态方式，还可以用宏PTHREAD_MUTEX_INITIALIZER来静态初始化互斥锁<br>（这种方式叫常量初始化），这个宏定义在篇pthread.h中，定义如下：  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> PTHREAD_MUTEX_INITIALIZER &#123; &#123; 0, 0, 0, 0, 0, &#123; 0 &#125; &#125; &#125;</span><br></code></pre></td></tr></table></figure><p>它用一些初始化值来初始化一个互斥锁。使用PTHREAD_MUTEX_INITIALIZER来初始化一个互斥锁的方式如下：  </p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">pthread_mutex_t mutex <span class="hljs-operator">=</span> PTHREAD_MUTEX_INITIALIZER<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>需要注意的是，如果mutex是指针，则不能用这种静态方式初始化，而需要使用函数式初始化方式：   </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">pthread_mutex_t</span> *pmutex = (<span class="hljs-type">pthread_mutex_t</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">pthread_mutex_t</span>));<br>pmutex = PTHREAD_MUTEX_INITIALIZER;<span class="hljs-comment">//错误的初始化方式</span><br><span class="hljs-built_in">pthread_mutex_init</span>(pmutex, <span class="hljs-literal">NULL</span>);<span class="hljs-comment">//正确，动态初始化一个互斥锁</span><br></code></pre></td></tr></table></figure><p>PTHREAD_MUTEX_INITIALIZER相当于一组常量，只能对pthread_mutex_t类型的变量进行赋值，不能赋值给指针类型，<br>即使该指针已经分配了内存空间。也可以先定义变量，再调用初始化函数进行初始化：  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">pthread_mutex_t</span> mutex;<br><span class="hljs-built_in">pthread_mutex_init</span>(&amp;mutex, <span class="hljs-literal">NULL</span>);<br></code></pre></td></tr></table></figure><blockquote><ul><li>注意：静态初始化的互斥锁是不需要销毁的，而动态初始化的互斥锁是需要销毁的，销毁时使用销毁函数。</li></ul></blockquote><h4 id="互斥锁上锁与解锁"><a href="#互斥锁上锁与解锁" class="headerlink" title="互斥锁上锁与解锁"></a>互斥锁上锁与解锁</h4><p>一个互斥锁成功初始化后，就可以用于上锁和解锁了，上锁是为了防止其它线程进入临界区，解锁则允许其它线程进<br>入临界区。用于上锁的函数是pthread_mutex_lock或pthread_mutex_trylock。声明如下：  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pthread_mutex_lock</span><span class="hljs-params">(<span class="hljs-type">pthread_mutex_t</span> *mutex)</span></span>;<br></code></pre></td></tr></table></figure><p>其中，参数mutex是指向pthread_mutex_t变量的指针，应该是成功初始化后的变量。函数执行成功时返回0，否则返回<br>错误码。需要注意的是，如果调用该函数时互斥锁已经被其它线程上锁了，则调用该函数的线程将阻塞。<br>另一个上锁函数pthread_mutex_trylock在调用时，如果互斥锁已经上锁了，则不会阻塞，而是立即返回，并且函数返<br>回EBUSY，该函数声明如下：   </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pthread_mutex_trylock</span><span class="hljs-params">(<span class="hljs-type">pthread_mutex_t</span> *mutex)</span></span>;<br></code></pre></td></tr></table></figure><p>该函数执行成功时返回0，否则返回错误码。<br>当线程退出临界区后，要对互斥锁进行解锁，解锁函数是pthread_mutex_unlock，该函数声明如下：  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pthread_mutex_unlock</span><span class="hljs-params">(<span class="hljs-type">pthread_mutex_t</span> *mutex)</span></span>;<br></code></pre></td></tr></table></figure><p>其中mutex应该是指向已上锁的互斥锁。执行成功时返回0，否则返回错误码，上锁函数和解锁函数需要成对使用。  </p><h4 id="互斥锁销毁"><a href="#互斥锁销毁" class="headerlink" title="互斥锁销毁"></a>互斥锁销毁</h4><p>互斥锁使用完后，最终要销毁，用于销毁互斥锁的函数是pthread_mutex_destroy，该函数声明如下：  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pthread_mutex_destroy</span><span class="hljs-params">(<span class="hljs-type">pthread_mutex_t</span> *mutex)</span></span>;<br></code></pre></td></tr></table></figure><p>其中，mutex应该指向已经初始化后的互斥锁，函数执行成功返回0，否则返回错误码。  </p><p>示例：使用互斥锁的多线程累加  </p><img src="/2023/03/12/linux%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88%E4%B8%89%EF%BC%89/7.png" class=""><img src="/2023/03/12/linux%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88%E4%B8%89%EF%BC%89/8.png" class=""><img src="/2023/03/12/linux%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88%E4%B8%89%EF%BC%89/9.png" class=""><p></p>   <p>示例：使用互斥锁的卖货对账</p><img src="/2023/03/12/linux%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88%E4%B8%89%EF%BC%89/10.png" class=""><p></p>   <h3 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h3><p>使用互斥锁操纵临界资源时临界资源会有两种状态，要么是加锁状态，要么是不加锁状态，试想，假如一个线程a只是<br>想读一个共享变量i，因为不确定是否会有线程改变它，所以需要对它进行加锁以确保读到的数据正确，但是此时又有<br>一个线程b也有同样的需求，也需要读取共享变量i，发现该变量被锁住，那么b就不得不等到a释放了锁后才能获得锁<br>，然后再读取i的值，但是两个读操作即使是同时发生的，其实也不会改变共享变量i（不会像写操作那样造成竞争）<br>。因此在多个线程试图读取共享变量的值时，通常希望它们可以立即获取因为读而加的锁，而不需要等待前一个线程<br>释放。读写锁很好的解决了上述问题，它提供了比互斥锁更好的并行性，因为以读模式加锁后，当有多个线程试图再<br>以读模式加锁时，并不会造成这些线程阻塞在等待锁释放的情况下。<br>读写锁是多线程同步的另一种机制。在一些程序中存在读操作和写操作问题，也就是说，对某些资源的访问会存在两<br>种可能的情况：一种情况是访问必须是排他的，也就是独占的意思，这种操作称为写操作；另一种情况是访问方式是<br>可以共享的，就是可以有多个线程同时去访问某个资源，这种操作就称作读操作。这个问题模型是从对文件的读写操<br>作中引申出来的。把对资源的访问细分为读和写两种操作模式，这样可以大大增加并发效率。读写锁比互斥锁的使用<br>性更高，并行性也更高。需要注意的是，这里只是说并行效率比互斥锁高，并不是速度一定比互斥锁快，读写锁更复<br>杂，系统开销更大。并发性好对于用户体验非常重要，假如互斥锁需要0.5秒，使用读写锁需要0.8秒，在查询多的系<br>统中，如果有20个查询请求，使用互斥锁的话，则需要10秒钟才能满足请求，但如果使用读写锁的话，20个读请求可<br>以在1秒钟左右被满足，用户体验会足够好。读写锁有几个重要特点：   </p><blockquote><ul><li>(1) 如果一个线程用读锁锁定了临界区，那么其它线程也可以用读锁来进入临界区，这样就可以有多个线程并行<br>操作。这个时候如果再用写锁加锁就会发生阻塞，写锁请求阻塞后，后面继续有读锁来请求时，这些后来的读锁将会<br>被阻塞。这样避免了读锁长期占用资源，防止写锁饥饿。  </li><li>(2) 如果一个线程用写锁锁住了临界区，那么其它线程无论是读锁还是写锁都会发生阻塞。</li></ul></blockquote><p>posix库中用类型pthread_rwlock_t来定义一个读写锁，该类型是一个联合体类型，定义在pthreadtypes.h中，使用<br>时只需要包含pthread.h头文件即可。声明读写锁时如下：  </p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">pthread_rwlock_t rwlock<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><h4 id="读写锁初始化"><a href="#读写锁初始化" class="headerlink" title="读写锁初始化"></a>读写锁初始化</h4><p>读写锁的初始化方式和互斥锁相同，同样有常量初始化和函数初始化，常量初始化通过宏PTHREAD_RWLOCK_INITIALIZER<br>，该方式属于静态初始化方式，同样不能对一个读写锁指针初始化。函数初始化属于动态初始化方式，声明如下：  </p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-built_in">int</span> pthread<span class="hljs-constructor">_rwlock_init(<span class="hljs-params">pthread_rwlock_t</span> <span class="hljs-operator">*</span><span class="hljs-params">restrict</span> <span class="hljs-params">rwlock</span>, <span class="hljs-params">const</span> <span class="hljs-params">pthread_rwlockattr_t</span> <span class="hljs-operator">*</span><span class="hljs-params">restrict</span> <span class="hljs-params">attr</span>)</span>;<br></code></pre></td></tr></table></figure><p>其中，参数rwlock是指向pthread_rwlock_t类型变量的指针，表示一个读写锁；attr是指向pthread_rwlockattr_t类<br>型变量的指针，表示读写锁的属性，如果该参数为NULL，则使用默认的读写锁属性。函数执行成功返回0，否则返回错误<br>码。<br>静态初始化的读写锁是不需要销毁的，而动态初始化的读写锁是需要销毁的。读写锁初始化示例：  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">pthread_rwlock_t</span> *prwlock = (<span class="hljs-type">pthread_rwlock_t</span>*)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">pthread_rwlock_t</span>));<br><span class="hljs-built_in">pthread_rwlock_init</span>(prwlock, <span class="hljs-literal">NULL</span>);<br><br><span class="hljs-type">pthread_rwlock_t</span> rwlock;<br><span class="hljs-built_in">pthread_rwlock_init</span>(&amp;rwlock, <span class="hljs-literal">NULL</span>);<br></code></pre></td></tr></table></figure><h4 id="读写锁上锁解锁"><a href="#读写锁上锁解锁" class="headerlink" title="读写锁上锁解锁"></a>读写锁上锁解锁</h4><p>读写锁的上锁可分为读模式下的上锁和写模式下的上锁。读模式下的上锁函数有pthread_rwlock_rdlock和pthread_rwlock_tryrdlock<br>。前者声明如下：  </p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-built_in">int</span> pthread<span class="hljs-constructor">_rwlock_rdlock(<span class="hljs-params">pthread_rwlock_t</span> <span class="hljs-operator">*</span><span class="hljs-params">rwlock</span>)</span>;<br></code></pre></td></tr></table></figure><p>其中，参数rwlock是指向pthread_rwlock_t变量的指针，该参数应该是成功初始化后的。函数执行成功时返回0，否则<br>返回错误码。需要注意的是，如果调用该函数时，读写锁已经被其它线程在写模式下上了锁或者有一个线程在写模式等<br>待该锁，则调用该函数的线程将阻塞；如果其它线程在读模式下已经上锁，则可以获得该锁进入临界区。<br>另一个读模式下的上锁函数pthread_rwlock_tryrdlock在调用时，如果读写锁已经上锁了，则不会阻塞，而是立即返<br>回，并且函数返回EBUSY，该函数声明如下：  </p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-built_in">int</span> pthread<span class="hljs-constructor">_rwlock_tryrdlock(<span class="hljs-params">pthread_rwlock_t</span> <span class="hljs-operator">*</span><span class="hljs-params">rwlock</span>)</span>;<br></code></pre></td></tr></table></figure><p>函数执行成功返回0，否则返回错误码。    </p><p>相对于读模式下的上锁，写模式下的读写锁也有两个上锁函数：pthread_rwlock_wrlock、pthread_rwlock_trywrlock<br>前者声明如下：  </p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-built_in">int</span> pthread<span class="hljs-constructor">_rwlock_wrlock(<span class="hljs-params">pthread_rwlock_t</span> <span class="hljs-operator">*</span><span class="hljs-params">rwlock</span>)</span>;<br></code></pre></td></tr></table></figure><p>函数执行成功返回0，否则返回错误码。如果调用该函数时，读写锁已经被其它线程上锁（无论是读模式还是写模式）<br>则调用该函数的线程将阻塞。函数pthread_rwlock_trywrlock与pthread_rwlock_wrlock唯一的区别是读写锁不可用<br>时不会阻塞，而是返回一个错误值EBUSY。<br>除了上述上锁函数外，还有两个不常用的上锁函数，它们可以设定在规定的时间内等待读写锁，如果等不到，就返回<br>ETIMEDOUT，这两个函数声明如下：  </p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-built_in">int</span> pthread<span class="hljs-constructor">_rwlock_timedrdlock(<span class="hljs-params">pthread_rwlock_t</span> <span class="hljs-operator">*</span><span class="hljs-params">restrict</span> <span class="hljs-params">rwlock</span>, <span class="hljs-params">const</span> <span class="hljs-params">struct</span> <span class="hljs-params">timespec</span> <span class="hljs-operator">*</span><span class="hljs-params">restrict</span> <span class="hljs-params">abs_timeout</span>)</span>;<br><span class="hljs-built_in">int</span> pthread<span class="hljs-constructor">_rwlock_timedwrlock(<span class="hljs-params">pthread_rwlock_t</span> <span class="hljs-operator">*</span><span class="hljs-params">restrict</span> <span class="hljs-params">rwlock</span>, <span class="hljs-params">const</span> <span class="hljs-params">struct</span> <span class="hljs-params">timespec</span> <span class="hljs-operator">*</span><span class="hljs-params">restrict</span> <span class="hljs-params">abs_timeout</span>)</span>;<br></code></pre></td></tr></table></figure><p>当线程退出临界区后，要对写锁进行解锁，解锁的函数是pthread_rwlock_unlock,声明如下：  </p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-built_in">int</span> pthread<span class="hljs-constructor">_rwlock_unlock(<span class="hljs-params">pthread_rwlock_t</span> <span class="hljs-operator">*</span><span class="hljs-params">rwlock</span>)</span>;<br></code></pre></td></tr></table></figure><p>其中，rwlock应该指向已上锁的读写锁，函数执行成功时返回0，否则返回错误码，该函数应该与上锁函数成对使用。  </p><h4 id="读写锁的销毁"><a href="#读写锁的销毁" class="headerlink" title="读写锁的销毁"></a>读写锁的销毁</h4><p>读写锁使用完需要进行销毁，用于销毁读写锁的函数是pthread_rwlock_destroy，声明如下：  </p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-built_in">int</span> pthread<span class="hljs-constructor">_rwlock_destroy(<span class="hljs-params">pthread_rwlock_t</span> <span class="hljs-operator">*</span><span class="hljs-params">rwlock</span>)</span>;<br></code></pre></td></tr></table></figure><p>参数rwlock应该指向已经初始化后的读写锁，函数执行成功时返回0，否则返回错误码。  </p><p>示例：互斥锁与读写锁</p><img src="/2023/03/12/linux%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88%E4%B8%89%EF%BC%89/11.png" class=""><img src="/2023/03/12/linux%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88%E4%B8%89%EF%BC%89/12.png" class=""><img src="/2023/03/12/linux%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88%E4%B8%89%EF%BC%89/13.png" class=""><img src="/2023/03/12/linux%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88%E4%B8%89%EF%BC%89/14.png" class=""><img src="/2023/03/12/linux%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88%E4%B8%89%EF%BC%89/15.png" class=""><p></p>  <p>上例可以看出，即使是在读的情况下，读写锁依然会比互斥锁速度慢。虽然读写锁速度上可能不如互斥锁，但是它的<br>并发性好，而并发性对于用户体验是非常重要的，对于并发性要求高的地方，应该有限考虑读写锁。  </p><h3 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h3><p>线程间的同步有这样一种情况：线程a需要等某个条件成立才能继续往下执行，如果这个条件不成立，则线程a阻塞等<br>待该条件成立，而该条件成立与否的关键，是由线程b的执行决定的，b在执行过程中使该条件成立了，于是唤醒a线程<br>继续执行。在posix线程库中，同步机制之一的条件变量（Condition Variable）就是用在该场景下，它可以让一个线<br>程等待“条件变量的结果“而挂起，另一个线程在条件成立后挂起向挂起的线程发送条件成立的信号。这两种行为都是<br>通过条件变量相关的函数实现的。为了防止线程间竞争，使用条件变量时，需要联合互斥锁一起使用。条件变量常用在<br>多线程之间关于共享数据状态变化的通信中，当一个线程的行为依赖于另一个线程对共享数据状态的改变时，就可以使<br>用条件变量来同步它们。<br>先看一个经典问题—生产者-消费者问题。生产者-消费者（producer-consumer）问题也称作有界缓冲区（bounded-buffer）<br>问题，两个线程共享一个公共的固定大小的缓冲区。其中一个是生成者，用于将数据放入缓冲区；另一个是消费者，<br>于从缓冲区中读取数据，如此反复。问题出现在当缓冲区已经满了，而此时生产者还想向其中放入一个新的数据项的<br>时候，其解决方法是让生产者进行休眠，等待消费者从缓冲区中取出一个或者多个数据后再去唤醒它。同样地，当缓<br>冲区已经空了，而消费者还想去取数据时，也可以让消费者进行休眠，等待生产者放入一个或者多个数据时再唤醒它<br>。问题看似解决了，但其实在实现时会有一个死锁情况存在。为了跟踪缓冲区中的消息数目，需要要给全局变量count<br>如果缓冲区最多存放N个数据，则生产者的代码会首先检查count是否达到N，如果是，则生产者休眠，否则生产者向缓<br>冲区中放入一个数据，并增加count的值。消费者的代码也与此类似，首先检测count是否为0，如果是，则休眠，否则<br>从缓冲区中取出消息并递减count的值。同时，每个线程也需要检查是否需要唤醒另一个线程。下面看一段代码：  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/* 定义缓冲区大小 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> N 100</span><br><span class="hljs-comment">/* 定义一个互斥锁 */</span><br><span class="hljs-type">pthread_mutex_t</span> mutex;<br><span class="hljs-comment">/* 跟踪缓冲区的记录数 */</span><br><span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">/* 生产者线程 */</span><br><span class="hljs-function"><span class="hljs-type">void</span>* <span class="hljs-title">procedure</span><span class="hljs-params">(<span class="hljs-type">void</span>* arg)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> item;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)<br>    &#123;<br>        <span class="hljs-comment">/* 产生一个数据项 */</span><br>        item = <span class="hljs-built_in">produce_item</span>();<br>        <span class="hljs-comment">/* 缓冲区满则进行休眠 */</span><br>        <span class="hljs-keyword">if</span>(count == N)<br>        &#123;<br>            <span class="hljs-built_in">sleep</span>();<br>        &#125;<br>        <span class="hljs-built_in">pthread_mutex_lock</span>(&amp;mutex);<br>        <span class="hljs-comment">/* 放入缓冲区 */</span><br>        <span class="hljs-built_in">insert_item</span>(item);<br>        count = count + <span class="hljs-number">1</span>;<br>        <span class="hljs-built_in">pthread_mutex_unlock</span>(&amp;mutex);<br>        <span class="hljs-comment">/* count为1表明插入之前为空，消费者在等待 */</span><br>        <span class="hljs-keyword">if</span>(count == <span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-built_in">wakeup</span>(sonsumer);<span class="hljs-comment">//唤醒消费者</span><br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/* 消费者线程 */</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">consumer</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> item;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>)<br>    &#123;<br>        <span class="hljs-comment">/* 如果缓冲区为空，进入休眠 */</span><br>        <span class="hljs-keyword">if</span>(count == <span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-built_in">sleep</span>();<br>        &#125;<br>        <span class="hljs-built_in">pthread_mutex_lock</span>(&amp;mutex);<br>        item = <span class="hljs-built_in">remove_item</span>();<br>        count = count - <span class="hljs-number">1</span>;<br>        <span class="hljs-built_in">pthread_mutex_unlock</span>(&amp;mutex);<br>        <span class="hljs-comment">/* 缓冲区有空余 */</span><br>        <span class="hljs-keyword">if</span>( count == N<span class="hljs-number">-1</span>)<br>        &#123;<br>            <span class="hljs-built_in">wakeup</span>(producer)<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>上述代码中，当缓冲区为空时，消费线程读取的count值为0，该线程会准备开始休眠sleep，而如果此时刚好调度程序<br>决定暂停消费者线程并切换到生产者线程，则程序就会出现问题。生产者线程此时运行后，向缓冲区中加入一个数据<br>项，count加1.现在count的值由0变为1，于是生产者开始调用wakeup(consumer)来唤醒消费者。但是实际上，消费者<br>并没有休眠，所以wakeup的信号就丢失了。当调度程序再次且回到消费者线程时，它将会进入休眠语句，并开始休眠<br>。生产者线程下次再被调用的时候，会继续增加count的值，并且再也不会唤醒consumer了，一直到缓冲区填满生产<br>者也进入休眠，最后两个线程永久的进入休眠状态。产生该问题的主要原因是消费者解锁到休眠的这段代码有可能被<br>打断。然而，条件变量就是为杜绝此问题的，它的重要功能就是把释放互斥锁到休眠当作一个原子操作，不被打断。<br>posix库中用类型pthread_cond_t来定义一个条件变量，比如定义一个条件变量：   </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-type">pthread_cond_t</span> cond;<br></code></pre></td></tr></table></figure><h4 id="条件变量的初始化"><a href="#条件变量的初始化" class="headerlink" title="条件变量的初始化"></a>条件变量的初始化</h4><p>条件变量有两种初始化方式，即常量初始化和函数初始化。常量初始化通过宏PTHREAD_RWLOCK_INITIALIZER来给一个<br>条件变量赋值，比如：  </p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">pthread_cond_t cond <span class="hljs-operator">=</span> PTHREAD_COND_INITIALIER<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>这种方式属于静态初始化方式，不能对一个条件变量指针进行初始化，下面的使用会报错：  </p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">pthread_cond_t *pcond <span class="hljs-operator">=</span> (pthread_cond_t *)malloc(sizeof(pthread_cond_t))<span class="hljs-comment">;</span><br><span class="hljs-attribute">pcond</span> <span class="hljs-operator">=</span> PTHREAD_COND_INITIALIER<span class="hljs-comment">;//error</span><br></code></pre></td></tr></table></figure><p>函数初始化方式属于动态初始化方式，通过函数pthread_cond_init进行，该函数声明如下：  </p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-built_in">int</span> pthread<span class="hljs-constructor">_cond_init(<span class="hljs-params">pthread_condd_t</span> <span class="hljs-operator">*</span><span class="hljs-params">cond</span>, <span class="hljs-params">pthread_condattr_t</span> <span class="hljs-operator">*</span><span class="hljs-params">cond_attr</span>)</span>;<br></code></pre></td></tr></table></figure><p>其中，参数cond是指向pthread_cond_t变量的指针：attr是指向pthread_condattr_t变量的指针，表示条件变量的属<br>性，如果赋值NULL，则使用默认的条件变量属性，该参数通常使用NULL。如果函数执行成功就返回0，否则返回错误码。<br>静态初始化的条件变量是不需要销毁的，而动态初始化的条件变量是需要销毁的。  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp">两种常见条件变量初始化方法<br><span class="hljs-type">pthread_cond_t</span> *pcond = (<span class="hljs-type">pthread_cond_t</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">pthread_cond_t</span>));<br><span class="hljs-built_in">pthread_cond_init</span>(pcond, <span class="hljs-literal">NULL</span>);<br><br><span class="hljs-type">pthread_cond_t</span> cond;<br><span class="hljs-built_in">pthread_cond_init</span>(&amp;cond, <span class="hljs-literal">NULL</span>);<br></code></pre></td></tr></table></figure><p>静态初始化示例：  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;errors.h&gt;</span></span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">data</span>&#123;<br>    <span class="hljs-type">pthread_mutex_t</span> mutex;<span class="hljs-comment">/* 对变量进行保护 */</span> <br>    <span class="hljs-type">pthread_cond_t</span> cond; <span class="hljs-comment">/* 变量值发生改变会发出信号 */</span> <br>    <span class="hljs-type">int</span> value; <span class="hljs-comment">/* 被互斥锁保护的变量 */</span> <br>&#125; data_pro;<br><br>data_pro  testdata = &#123;PTHREAD_MUTEX_INITIALIZER, PTHREAD_COND_INITIALIZER, <span class="hljs-number">0</span>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的代码的初始化效果和用函数pthread_mutex_init与pthread_cond_init（都使用默认属性）进行初始化的效果是<br>一样的。  </p><h4 id="等待条件变量"><a href="#等待条件变量" class="headerlink" title="等待条件变量"></a>等待条件变量</h4><p>pthread_cond_wait和pthread_cond_timedwait用于等待条件变量，并且将线程阻塞在一个条件变量上。pthread_cond_wait<br>声明如下：  </p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-built_in">int</span> pthread<span class="hljs-constructor">_cond_wait(<span class="hljs-params">pthread_cond_t</span> <span class="hljs-operator">*</span><span class="hljs-params">restrict</span> <span class="hljs-params">cond</span>, <span class="hljs-params">pthread_mutex_t</span> <span class="hljs-operator">*</span><span class="hljs-params">restrict</span> <span class="hljs-params">mutex</span>)</span>;<br></code></pre></td></tr></table></figure><p>其中，参数cond指向pthread_cond_t类型变量的指针，表示一个已经初始化的条件变量；mutex指向一个互斥锁变量<br>的指针，用于同步线程对共享资源的访问。函数执行成功返回0，出错返回错误码。注意，之前提到过，为了防止多个<br>线程同时对pthread_cond_t请求形成竞争，因此条件变量必须和一个互斥锁联合使用。<br>如果条件不满足，调用pthread_cond_wait会发生一个原子操作：线程将mutex解锁、线程被条件变量cond阻塞。这是<br>一个原子操作，不会被打断。被阻塞的线程可以在以后某个时间通过其它线程执行函数pthread_cond_signal或者函数<br>pthread_cond_broadcast来唤醒。线程被唤醒后，如果条件还不满足，该线程将继续阻塞在这里，等待下一次被唤醒。<br>这个过程可以用while循环语句来实现，伪代码如下所示：  </p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">Lock</span><span class="hljs-params">(mutex)</span></span><br><span class="hljs-function"><span class="hljs-title">while</span><span class="hljs-params">(condition is false)</span></span>&#123;<br>    <span class="hljs-built_in">pthread_cond_wait</span>(cond, mutex, timeout)<br>&#125;<br><span class="hljs-function"><span class="hljs-title">DoSomething</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-title">Unlock</span><span class="hljs-params">(mutex)</span></span><br></code></pre></td></tr></table></figure><p>使用while还有一个原因是，等待在条件变量上的线程被唤醒有可能不是由于条件满足而是由于虚假唤醒（Spurious Wakeups）<br>虚假唤醒在posix标准里是默认允许的，wait返回只是代表共享数据有可能被改变，因此必须重新判断。在多核处理<br>下，pthread_cond_signal可能会激活多于一个线程（阻塞在条件变量上的线程）。当一个线程调用pthread_cond_signal()<br>函数后，结果是，多个调用pthread_cond_wait()或pthread_cond_timedwait()的线程返回。当函数等到条件变量时，<br>将对mutex上锁并唤醒本线程。这也是一个原子操作。由于pthread_cond_wait需要释放锁，因此当调用该函数的时候<br>，互斥锁必须已经被调用线程锁定。由于收到信号时要对mutex上锁，因此等到信号时，除了信号来到外，互斥锁也应<br>该已经解锁了，只有两个条件都满足，该函数才会返回。<br>函数pthread_cond_timedwait是计时等待条件变量，声明如下：   </p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-built_in">int</span> pthread<span class="hljs-constructor">_cond_timedwait(<span class="hljs-params">pthread_cond_t</span> <span class="hljs-operator">*</span><span class="hljs-params">restrict</span> <span class="hljs-params">cond</span>, <span class="hljs-params">pthread_mutex_t</span> <span class="hljs-operator">*</span><span class="hljs-params">restrict</span> <span class="hljs-params">mutex</span>, <span class="hljs-params">const</span> <span class="hljs-params">struct</span> <span class="hljs-params">timespec</span> <span class="hljs-operator">*</span><span class="hljs-params">restrict</span> <span class="hljs-params">abstime</span>)</span>;<br></code></pre></td></tr></table></figure><p>其中，参数cond与mutex与wait函数参数一样；abstime指向结构体timespec变量，表示等待的时间，如果等于或者超<br>过这个时间，则返回ETIME。该结构体定义如下：  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">timespec</span>&#123;<br>    <span class="hljs-type">time_t</span> tv_sec;<span class="hljs-comment">//秒 </span><br>    <span class="hljs-type">long</span> tv_nsex;<span class="hljs-comment">//纳秒 </span><br>&#125;<span class="hljs-type">timespec_t</span>;<br></code></pre></td></tr></table></figure><p>这里的秒和纳秒数是自1970&#x2F;1&#x2F;1 00：00：00开始，函数执行成功返回0，失败返回错误码。  </p><h4 id="唤醒等待条件变量的线程"><a href="#唤醒等待条件变量的线程" class="headerlink" title="唤醒等待条件变量的线程"></a>唤醒等待条件变量的线程</h4><p>pthread_cond_signal用于唤醒一个等待条件变量的线程，该函数声明如下：  </p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-built_in">int</span> pthread<span class="hljs-constructor">_cond_signal(<span class="hljs-params">pthread_cond_t</span> <span class="hljs-operator">*</span><span class="hljs-params">cond</span>)</span>;<br></code></pre></td></tr></table></figure><p>其中，参数cond指向一个已经阻塞线程的条件变量。函数执行成功返回0，失败则返回错误码。<br>pthread_cond_signal只唤醒一个等待该条件变量的线程，pthread_cond_broadcast函数则将唤醒所有等待该条件变量<br>的线程，该函数声明如下：  </p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-built_in">int</span> pthread<span class="hljs-constructor">_cond_broadcast(<span class="hljs-params">pthread_cond_t</span> <span class="hljs-operator">*</span><span class="hljs-params">cond</span>)</span>;<br></code></pre></td></tr></table></figure><h4 id="条件变量的销毁"><a href="#条件变量的销毁" class="headerlink" title="条件变量的销毁"></a>条件变量的销毁</h4><p>当不再使用条件变量的时候，应该将其销毁。用于销毁条件变量的函数是pthread_cond_destroy。该函数声明如下：  </p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-built_in">int</span> pthread<span class="hljs-constructor">_cond_destroy(<span class="hljs-params">pthread_cond_t</span> <span class="hljs-operator">*</span><span class="hljs-params">cond</span>)</span>;<br></code></pre></td></tr></table></figure><p>其中，参数cond指向一个不再使用的条件变量，函数执行成功返回0，出错则返回错误码。  </p><p>示例：条件变量的使用，找出1-20中能整除3的整数  </p><img src="/2023/03/12/linux%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88%E4%B8%89%EF%BC%89/16.png" class=""><img src="/2023/03/12/linux%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88%E4%B8%89%EF%BC%89/17.png" class=""><img src="/2023/03/12/linux%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88%E4%B8%89%EF%BC%89/18.png" class=""><p></p>  <p>示例中，线程1在累加i的过程中，如果i能整除3，就唤醒等待条件变量cond的线程。线程2在循环中，如果i不能整除<br>3，则阻塞线程，等待条件变量。需要注意的是，由于pthread_cond_wait需要释放锁，因此当调用pthread_cond_wait<br>的时候，互斥锁必须已经被调用线程锁定，线程2中的pthread_cond_wait函数前会先加锁pthread_mutex_lock(&amp;mutex)。<br>并且，pthread_cond_wait收到条件变量信号时，要对互斥锁加锁，因此在线程1中的pthread_cond_signal后面解锁后，<br>才会让线程2中的pthread_cond_wait返回，并执行它后面的语句。并且pthread_cond_wait可以对mutex上锁，当用完<br>i的时候，再对mutex解锁，这样可以让线程1继续进行。当线程1打印一个非整除3的i后，就休眠了，此时将切换到线程<br>2的执行，线程发现i不能整除3，就阻塞。   </p>]]></content>
    
    
    <categories>
      
      <category>linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>linux多线程（二）</title>
    <link href="/2023/03/07/linux%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <url>/2023/03/07/linux%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="C-中的线程类"><a href="#C-中的线程类" class="headerlink" title="C++中的线程类"></a>C++中的线程类</h2><p>c++11新标准中引入了5个头文件来支持多线程编程，分别是atomic、thread、mutex、condition_variable和future。  </p><blockquote><ul><li>atomic:该头文件主要声明了两个类，即：std::atomic和std::atomic_flag，另外还声明了一套C风格的原子类型和与C兼容的原子操作的函数。  </li><li>thread:该头文件主要声明了std::thread类，另外std::this_thread命名空间也在该头文件中。</li><li>mutex:该头文件主要声明了互斥锁（mutex）相关的类，包括std::mutex系列类、std::lock_guard、std::unique_lock以及其它的类型和函数。  </li><li>condition_variable:该头文件主要声明了与条件变量相关的类，包括std::condition_variable和std::condition_variable_any。</li><li>future:该头文件主要声明了std::promise、std::package_task两个Provider类，以及std::future和std::shared_future两个Future类，另外一些与之相关<br>的类型和函数，std::async函数就声明在此头文件中。</li></ul></blockquote><p>其中，std::thread类是很重要的类，以下是这个类的一些成员函数：   </p><img src="/2023/03/07/linux%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88%E4%BA%8C%EF%BC%89/1.png" class=""><p></p>  <h2 id="线程的创建"><a href="#线程的创建" class="headerlink" title="线程的创建"></a>线程的创建</h2><p>在c++11中，创建线程的方式是使用类std::thread的构造函数，std::thread在#include<thread>头文件中声明，因此<br>使用std::thread时需要包含头文件thread，即#include<thread>。std::thread的构造函数有3种形式：不带参数的默<br>认构造函数、初始化构造函数、移动构造函数。<br>虽然类thread的初始化可以提供很丰富和方便的形式，但其实现的底层依然是创建一个pthread线程并运行，有些实现<br>甚至是直接调用pthread_create来创建。   </p><h3 id="1-默认构造函数"><a href="#1-默认构造函数" class="headerlink" title="1.默认构造函数"></a>1.默认构造函数</h3><p>默认构造函数是不带参数的，声明如下：  </p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-built_in">thread</span>();<br></code></pre></td></tr></table></figure><p>默认构造函数刚定义的thread对象，其线程是不会马上运行的。   </p><p>示例：创建批量线程  </p><img src="/2023/03/07/linux%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88%E4%BA%8C%EF%BC%89/2.png" class=""><p></p>  <p>上例定义了5个线程对象，刚定义的时候并不会执行线程，之后将另外初始化构造函数创建的返回值赋给它们就开始<br>运行。创建的线程都是可连接线程，所以使用join等待它们结束，多次运行该程序会发现输出的内容有变动，这和CPU<br>的调度有关系。   </p><h3 id="2-初始化构造函数"><a href="#2-初始化构造函数" class="headerlink" title="2.初始化构造函数"></a>2.初始化构造函数</h3><p>初始化构造函数的意思是把线程函数的指针和线程函数的参数传入到线程类的构造函数中。这种形式最常用，由于传<br>入了线程函数，因此在定义线程对象的时候，就会开始执行线程函数，如果线程函数需要参数，可以在构造函数中传<br>入。初始化构造函数的形式如下：  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">template</span>&lt;<span class="hljs-keyword">class</span> Fn, <span class="hljs-keyword">class</span>...Args&gt;</span><br><span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">thread</span><span class="hljs-params">(Fn&amp;&amp; fn, Args&amp;&amp;... args)</span></span>;<br></code></pre></td></tr></table></figure><p>其中，fn是线程函数指针；args是可选的，是要传入线程函数的参数。线程对象定义后，主线程会继续执行后面的代<br>码，此时就可能会出现刚创建的子线程还没执行完主线程就结束了，比如控制台程序，主线程一旦结束就意味着进程<br>结束了。这种情况时需要让主线程等待，等待子线程全部运行结束后再继续执行主线程。另一种情况是主线程是为了<br>统计各个子线程工作的结果而需要等待子线程结束后再继续执行。类thread提供了成员函数join来等待子线程结束，<br>即子线程的线程函数执行完毕后，join才返回，因此join是一个阻塞函数。函数join会让主线程挂起（休眠，让出CPU）<br>直到子线程退出，同时join能让子线程所占的资源得到释放。子线程退出后，主线程会接收到系统的信号，从休眠中<br>恢复。这一过程和POSIX类似，只是函数形式不同而已。join函数声明如下：  </p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">join</span>()</span>;<br></code></pre></td></tr></table></figure><p>需要注意的是，这样创建的线程是可连接线程，所以线程对象必须在销毁时调用join函数，或者将其设置为可分离的。  </p><p>示例：传递结构体和多个参数给线程函数  </p><img src="/2023/03/07/linux%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88%E4%BA%8C%EF%BC%89/3.png" class=""><p></p>   <p>默认创建的线程都是可连接线程，可连接线程需要调用join函数来等待其结束并释放资源。上面的例子使用了join函<br>数来等待其结束。除了使用join方式来等待结束外，还可以把可连接线程进行分离，即调用detach成员函数，变成可<br>分离线程，线程自己结束后就可以被系统自动回收资源了。而且主线程并不需要等待子线程结束，主线成可以自己先<br>结束。将线程进行分离的成员函数是detach，声明如下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">detach</span>()</span>;<br></code></pre></td></tr></table></figure><p>示例：将可连接线程转为分离线程</p><img src="/2023/03/07/linux%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88%E4%BA%8C%EF%BC%89/4.png" class=""><p></p>  <p>上例中，调用detach来分离线程，这样做主线程可以不用等子线程结束而先于子线程结束。在主线程中调用了<br>pthread_exit(NULL)来结束主线程，之前提到过，在main线程中调用pthread_exit(NULL)的时候，将结束main线程，<br>但进程并不会立即退出，要等所有的线程全部结束后才会结束，所以能看到子线程函数打印的内容。主线程中先打印<br>p的值，这是因为打印p的时候，线程还没有切换到子线程。   </p><h3 id="3-移动（move）构造函数"><a href="#3-移动（move）构造函数" class="headerlink" title="3.移动（move）构造函数"></a>3.移动（move）构造函数</h3><p>通过移动构造函数的方式来创建线程是c++11创建线程的另一种常用方式。它通过向thread构造函数中传入一个c++对象<br>来创建线程。这种形式的构造函数定义如下：  </p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey"><span class="hljs-keyword">thread</span>(<span class="hljs-keyword">thread</span>&amp;&amp; t)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>调用成功之后，t不代表任何thread对象。  </p><p>示例：使用移动构造函数  </p><img src="/2023/03/07/linux%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88%E4%BA%8C%EF%BC%89/5.png" class=""><p></p>    <p>上例中，td1并不会执行，执行的是td2，因为td1的线程函数所有权已经被转移给td2了。  </p><h2 id="线程的标识符"><a href="#线程的标识符" class="headerlink" title="线程的标识符"></a>线程的标识符</h2><p>线程的标识符（ID）可以用来唯一标识某个thread对象所对应的线程，这样就可以用来区别不同的线程。<br>两个标识符相同的thread对象，意味着所代表的线程是同一个线程，或者代表着这两个对象都还没有线程。两个标识<br>符不同的thread对象代表着不同的线程，或者一个thread对象已经有线程了，而另一个还没有。类thread提供了成员<br>函数getid来获取线程id，该函数声明如下：  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">thread::id <span class="hljs-title">get_id</span><span class="hljs-params">()</span></span>;<br></code></pre></td></tr></table></figure><p>其中，id是线程标识符的类型，它是类thread的成员，用来唯一标识某个线程。  </p><p>示例：线程判断  </p><img src="/2023/03/07/linux%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88%E4%BA%8C%EF%BC%89/6.png" class=""><p></p>  <p>示例中，this_thread是一个命名空间（namespace），用来标识当前线程。它的主要作用是提供一些函数来访问当前<br>线程，一共有4个函数：get_id、yield、sleep_until、sleep_for。  </p><h2 id="当前线程this-thread"><a href="#当前线程this-thread" class="headerlink" title="当前线程this_thread"></a>当前线程this_thread</h2><p>实际线程开发中，经常需要访问当前线程。c++11提供了一个命名空间this_thread来引用当前线程，该命名空间集合<br>了4个有用的函数，get_id、yield、sleep_until、sleep_for。函数get_id和类thread的成员函数get_id是同一个意<br>思，都是用来获取线程id的。  </p><h3 id="1-让出CPU时间"><a href="#1-让出CPU时间" class="headerlink" title="1.让出CPU时间"></a>1.让出CPU时间</h3><p>调用函数yield的线程将让出属于自己的cpu时间片，以便其它线程有机会运行，该函数声明如下：  </p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">yield</span>()</span>;<br></code></pre></td></tr></table></figure><p>调用该函数的线程放弃执行，回到就绪状态。  </p><p>示例：创建10个线程，每个线程都是让一个变量从1累加到一百万，谁先完成就打印它的编号，以此排名。为了公平<br>起见，创建线程的时候，先不让它们占用cpu时间，直到main线程改变全局变量值，各个子线程才一起开始累加。  </p><img src="/2023/03/07/linux%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88%E4%BA%8C%EF%BC%89/7.png" class=""><p></p>  <p>多次运行示例会发现每次结果都是不同的。线程刚刚启动的时候，一直在while循环中让出属于自己的cpu时间片，这<br>就是yield的作用，this_thread在子线程中使用，代表这个子线程本身。一旦跳出while，就开始给变量累加直到100<br>万，最后输出该线程的序号，先跑完一百万累加的序号先被输出。atomic用来定义在全局变量ready上的操作都是原子<br>的，它确保了在同一时刻只有唯一的线程对这个资源进行访问。   </p><h3 id="2-线程暂停一段时间"><a href="#2-线程暂停一段时间" class="headerlink" title="2.线程暂停一段时间"></a>2.线程暂停一段时间</h3><p>命名空间this_thread还有两个函数，即sleep_until、sleep_for，用来阻塞线程，暂停执行一段时间。函数sleep_until<br>和sleep_for声明如下：  </p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">template&lt;<span class="hljs-keyword">class</span> Clock, <span class="hljs-keyword">class</span> Duration&gt;<br>void sleep<span class="hljs-constructor">_until(<span class="hljs-params">const</span> <span class="hljs-params">chrono</span>::<span class="hljs-params">time_point</span>&lt;Clock, Duration&gt;&amp; <span class="hljs-params">abs_time</span>)</span>;<br><br>template&lt;<span class="hljs-keyword">class</span> Rep, <span class="hljs-keyword">class</span> Period&gt;<br>void sleep<span class="hljs-constructor">_for(<span class="hljs-params">const</span> <span class="hljs-params">chrono</span>::<span class="hljs-params">duration</span>&lt;Rep, Period&gt;&amp; <span class="hljs-params">rel_time</span>)</span>;<br></code></pre></td></tr></table></figure><p>其中，参数abs_time标识函数阻塞线程到abs_time时间点，到了这个时间点后再继续执行。函数sleep_for的功能类似，只<br>是它是挂起线程一段时间，时间长度由参数决定，参数rel_time标识线程挂起的时间段，在这段时间内线程暂停执行。  </p><p>示例：暂停线程到下一分钟  </p><img src="/2023/03/07/linux%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88%E4%BA%8C%EF%BC%89/8.png" class=""><p></p>  <p>示例中main线程从sleep_until处开始挂起，然后到下一个整分时间继续执行。  </p><p>示例：暂停10秒  </p><img src="/2023/03/07/linux%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88%E4%BA%8C%EF%BC%89/9.png" class=""><p></p>]]></content>
    
    
    <categories>
      
      <category>linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vscode搭建Garmin开发环境</title>
    <link href="/2023/02/26/vscode%E6%90%AD%E5%BB%BAGarmin%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/"/>
    <url>/2023/02/26/vscode%E6%90%AD%E5%BB%BAGarmin%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/</url>
    
    <content type="html"><![CDATA[<h2 id="0x01"><a href="#0x01" class="headerlink" title="0x01"></a>0x01</h2><p>之前买了块跑步用的手表佳明245M，最近想给它装一个可以记录踢球的app，在商店里面搜了半天，感觉都不是自己<br>想要的那种，有两款收费的app，也不清楚它们的功能怎么样，所以也不想花冤枉钱，于是就想着自己折腾一下，之<br>前使用eclipse搭建过佳明sdk的环境，后来工作忙也就一直没上心，现在又有点需求了，所以就暂且记录一下吧。。</p><h2 id="0x02"><a href="#0x02" class="headerlink" title="0x02"></a>0x02</h2><p>首先在佳明的官网注册一个账号，然后下载符合自己系统的SDK，解压后运行里面sdkmanager.exe,这时候会要求登录<br>刚才注册的账号，登录完毕后如下图所示：  </p><img src="/2023/02/26/vscode%E6%90%AD%E5%BB%BAGarmin%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/1.png" class=""><p></p>  下载所需版本的sdk即可，我下载的是最新的4.1.7版本。然后打开vscode，在插件扩展里面搜索Monkey，如下图所示，选中后安装插件。    <img src="/2023/02/26/vscode%E6%90%AD%E5%BB%BAGarmin%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/2.png" class=""><p></p>   插件安装完毕后，在键盘上输入Shift+Ctrl+p快捷键，然后在命令框中输入Generate关键字，选择生成一个开发者key，如下图所示，存储该key的目录后面要用，所以记录以下：      <img src="/2023/02/26/vscode%E6%90%AD%E5%BB%BAGarmin%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/3.png" class=""><p></p>key生成之后，找到刚才的插件，然后选择扩展插件的设置，主要设置两个目录，一个就是上一步中key所在的目录，另一个就是java的安装目录，如下图所示：         <img src="/2023/02/26/vscode%E6%90%AD%E5%BB%BAGarmin%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/4.png" class=""><p></p>这步设置完成后，接下来设置刚才下载的sdk的环境变量。下载的sdk默认是在当前用户的AppData下面的Roaming下，找到红框所示文件，并复制里面的路径，如下图所示：      <img src="/2023/02/26/vscode%E6%90%AD%E5%BB%BAGarmin%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/5.png" class=""><img src="/2023/02/26/vscode%E6%90%AD%E5%BB%BAGarmin%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/6.png" class=""><p></p>  将复制的路径添加到环境变量中，如下图所示：     <img src="/2023/02/26/vscode%E6%90%AD%E5%BB%BAGarmin%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/7.png" class=""><img src="/2023/02/26/vscode%E6%90%AD%E5%BB%BAGarmin%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/8.png" class=""><p></p>环境变量设置完成后可以在cmd中使用connectiq、monkeyc和monkeydo进行验证。如下图所示即配置完成了：   <img src="/2023/02/26/vscode%E6%90%AD%E5%BB%BAGarmin%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/9.png" class=""><img src="/2023/02/26/vscode%E6%90%AD%E5%BB%BAGarmin%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/10.png" class=""><img src="/2023/02/26/vscode%E6%90%AD%E5%BB%BAGarmin%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/11.png" class=""><p></p>环境变量配置完成之后，回到vscode，使用shift+ctrl+p快捷键调出输入框，然后输入verify关键字，如下图所示就一切准备就绪了：    <img src="/2023/02/26/vscode%E6%90%AD%E5%BB%BAGarmin%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/12.png" class=""><p></p>接下来就可以创建一个简单的demo来验证一下开发环境了。首先使用shift+ctrl+p调出输入框，输入new project,如下图示例：    <img src="/2023/02/26/vscode%E6%90%AD%E5%BB%BAGarmin%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/13.png" class=""><p></p>然后输入项目名：garmin_demo     <img src="/2023/02/26/vscode%E6%90%AD%E5%BB%BAGarmin%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/14.png" class=""><p></p>然后选择要创建的项目类型，这里我选择简单的表盘类型：    <img src="/2023/02/26/vscode%E6%90%AD%E5%BB%BAGarmin%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/15.png" class=""><p></p>接下来选择simple：     <img src="/2023/02/26/vscode%E6%90%AD%E5%BB%BAGarmin%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/16.png" class=""><p></p>然后选择可兼容的最低版本api，这里我选择最低版,然后选择创建工程的路径：       <img src="/2023/02/26/vscode%E6%90%AD%E5%BB%BAGarmin%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/17.png" class=""><p></p>demo创建好后，就可以尝试运行该demo，选择非调试模式运行，如下图示：     <img src="/2023/02/26/vscode%E6%90%AD%E5%BB%BAGarmin%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/18.png" class=""><p></p>如果报错，如下图所示,则是因为没有指定设备，此时调出输入框，输入monkey，选择命令行edit products，指定 设备后重新运行即可：      <img src="/2023/02/26/vscode%E6%90%AD%E5%BB%BAGarmin%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/19.png" class=""><img src="/2023/02/26/vscode%E6%90%AD%E5%BB%BAGarmin%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/20.png" class=""><img src="/2023/02/26/vscode%E6%90%AD%E5%BB%BAGarmin%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/21.png" class=""><img src="/2023/02/26/vscode%E6%90%AD%E5%BB%BAGarmin%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/22.png" class=""><p></p>  如上所示，用于开发佳明手表app的环境就算搭建好了，也可以使用eclipse搭建该环境。]]></content>
    
    
    <categories>
      
      <category>Garmin</category>
      
    </categories>
    
    
    <tags>
      
      <tag>app</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2023/02/23</title>
    <link href="/2023/02/23/%E6%A8%B1%E8%8A%B1%E5%BC%80%E4%BA%86/"/>
    <url>/2023/02/23/%E6%A8%B1%E8%8A%B1%E5%BC%80%E4%BA%86/</url>
    
    <content type="html"><![CDATA[<p>今天是休日，早上十点多才起来，然后出门买了个菜，回来之后看了会技术资料。中午吃完饭小睡了半小时，<br>起来后写了会代码就到下午五点多了，发现最近好像没怎么跑步，然后就决定六点多出去跑一会，沿着河边<br>一直跑到小松川公园时，猛然发现河边的几株樱花树都开花了，又到了一年的樱花季，时间可真是快呀。</p>]]></content>
    
    
    <categories>
      
      <category>杂记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>生活</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>linux多线程（一）</title>
    <link href="/2023/02/20/linux%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <url>/2023/02/20/linux%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="线程概述"><a href="#线程概述" class="headerlink" title="线程概述"></a>线程概述</h2><p>在多核时代，如何充分利用每个cpu的计算能力是绕不开的话题，从为成千上万的用户同时提供服务，到同时开启成<br>百上千链接的web应用程序，从需要支持并发访问的数据库系统，到手机上一个拥有良好响应能力的app，为了充分利<br>用每个cpu内核，都会想到是否可以使用多线程技术。多线程编程作为现代软件开发的流行技术，正确、恰当的使用多<br>线程可以使程序拥有更加出色的性能。  </p><h4 id="（1）使软件拥有灵敏的响应"><a href="#（1）使软件拥有灵敏的响应" class="headerlink" title="（1）使软件拥有灵敏的响应"></a>（1）使软件拥有灵敏的响应</h4><p>在单线程软件中，当软件中有多个任务时，如读写文件、更新用户界面、网络连接、打印等操作，如果按照先后次序<br>执行，当某个任务执行时间较长时（如读写较大文件），那么用户界面将长时间无法更新，看起来就像软件卡死了一<br>样，用户体验极其不友好。当采用多线程技术处理时，多个任务由不同的线程去执行，不同线程各自占用一段cpu时间<br>即使线程任务没完成，也会相互让出cpu使其它任务有机会得以执行，这样从用户角度看起来，界面会有更新的变化，<br>且其它任务也似乎在并行前进，大大的改善了用户的体验，提高了软件的响应速度和友好程度。</p><h4 id="（2）充分利用多核处理器"><a href="#（2）充分利用多核处理器" class="headerlink" title="（2）充分利用多核处理器"></a>（2）充分利用多核处理器</h4><p>随着多核处理器的普及，单线程程序愈发成为性能瓶颈。比如计算机有2个cpu核，单线程程序在任意时刻只能使用一<br>个核的运算能力，而另一个核始终处于空闲状态，无法发挥多核计算机的性能。如果此时是两个线程的程序，则任意<br>时刻都是两个核在同时运行，程序的运行效率将会提升一倍。</p><h4 id="（3）更高效的通信"><a href="#（3）更高效的通信" class="headerlink" title="（3）更高效的通信"></a>（3）更高效的通信</h4><p>对于同一进程的线程来说，它们共享该进程的地址空间，可以访问相同的数据。通过数据共享的方式使得线程之间的<br>通信比进程之间的通信更加高效和方便。</p><h4 id="（4）线程的开销比进程更小"><a href="#（4）线程的开销比进程更小" class="headerlink" title="（4）线程的开销比进程更小"></a>（4）线程的开销比进程更小</h4><p>创建线程和线程切换等操作所带来的系统开销比进程类似的操作要小得多。由于线程共享进程资源，因此创建线程时<br>不需要再为其分配内存空间等资源，因此床架时间也更短。比如在solaris2操作系统上，创建进程的时间大约是线程<br>创建的30倍；线程作为进程的基本执行单元，当从同一个进程的某个线程切换到另外一个线程时，需要载入的信息比<br>进程间切换时更少，切换速度更快，在solaris2操作系统中，线程的切换比进程快大约5倍左右。  </p><h2 id="操作系统与多线程"><a href="#操作系统与多线程" class="headerlink" title="操作系统与多线程"></a>操作系统与多线程</h2><p>想要在应用程序中实现多线程，必须要有操作系统的支持，linux32位或64位操作系统对应用程序提供了多线程的支持<br>windows NT&#x2F;2000&#x2F;XP&#x2F;7&#x2F;8&#x2F;10&#x2F;11都支持多线程。根据进程与线程的支持情况，可以将操作系统分为以下几类：  </p><blockquote><ul><li>(1) 单进程、单线程，MS-DOS基本是这种操作系统。</li><li>(2) 多进程、单线程，多数unix（以及类unix的linux）是这种操作系统。</li><li>(3) 多进程、多线程，Win32（windows NT&#x2F;2000&#x2F;XP&#x2F;7&#x2F;8&#x2F;10&#x2F;11等）、Solaris2.x和OS&#x2F;2都是这种操作系统。</li><li>(4) 单进程、多线程，Vxworks是这种操作系统。</li></ul></blockquote><p>现代操作系统大多数都支持多线程概念，每个进程中至少有一个线程，该线程称为主线程，可以说cpu中执行的就是线<br>程，线程是程序的最小执行单位，是操作系统分配cpu时间片的最小实体。一个进程的执行说到底是从主线程开始的，<br>如果需要，可以在程序的任何地方开辟新的线程，其它线程都是由主线程创建的。一个进程的所有线程共享该进程的<br>公共资源，比如虚拟地址空间、全局变量等。每个线程也可以拥有自己私有的资源，如堆栈、在堆栈中定义的静态变<br>量、cpu寄存器的状态等。线程总是在某个进程环境中创建，并且会在该进程内部销毁，它与进程的关系是：线程是<br>属于进程的，线程运行在进程空间内，同一进程所产生的线程共享同一内存空间，当进程退出时，该进程所产生的线<br>程都会被强制退出并清除。线程可与属于同一进程的其它线程共享进程所拥有的全部资源，但是其本身基本少不拥有<br>系统资源，只拥有一点在运行中不可缺少的信息（如程序计数器、一组寄存器和线程栈，线程栈用于维护线程在执行<br>代码时需要的所有函数参数和局部变量）。相对于进程而言，线程所占用的资源更少，比如创建进程，系统要为它分<br>配很大的私有空间，占用的资源较多，而对于多线程程序来说，由于多个线程共享一个进程地址空间，因此占用的资<br>源较少。此外，进程间切换时，需要交换整个地址空间，而线程之间切换时，只是切换线程的上下文环境，因此效率<br>更高。在操作系统中引入线程的好处众多：  </p><blockquote><ul><li>(1) 在进程内创建、终止线程比创建、终止进程要快。</li><li>(2) 同一进程内线程间的切换比进程间的切换要快，尤其是用户级线程间的切换。</li><li>(3) 每个进程具有独立的地址空间，而该进程内的所有线程共享该地址空间，因此线程的出现可以解决父子<br>进程模型中子进程必须复制父进程地址空间的问题。</li><li>(4) 线程对解决客户端&#x2F;服务器模型非常有效。</li></ul></blockquote><p>具体到linux c++的开发环境，linux提供了一套POSIX API函数来管理线程，用户既可以使用这些API函数，也可以使<br>用c++自带的线程类。  </p><h2 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h2><p>一个线程从创建到结束是一个生命周期，总是处于以下4个状态中的一个。  </p><h4 id="（1）就绪态"><a href="#（1）就绪态" class="headerlink" title="（1）就绪态"></a>（1）就绪态</h4><p>线程能够运行的条件已经满足，只是在等待处理器（处理器要根据调度策略来把就绪态的线程调度到处理器中运行）<br>处于就绪态的原因可能是线程刚刚被创建（刚创建的线程不一定马上运行，一般先处于就绪态），可能是刚刚从阻塞<br>态中恢复，也可能是被其它线程抢占而处于就绪态。  </p><h4 id="（2）运行态"><a href="#（2）运行态" class="headerlink" title="（2）运行态"></a>（2）运行态</h4><p>运行态表示线程正在处理器中运行，正占用着处理器。  </p><h4 id="（3）阻塞态"><a href="#（3）阻塞态" class="headerlink" title="（3）阻塞态"></a>（3）阻塞态</h4><p>由于在等待处理器之外的其它条件而无法运行的状态叫做阻塞态，这里的其它条件包括I&#x2F;O操作、互斥锁的释放、条件<br>变量的改变等。</p><h4 id="（4）终止态"><a href="#（4）终止态" class="headerlink" title="（4）终止态"></a>（4）终止态</h4><p>终止态就是线程的线程函数运行结束或被其它线程取消后处于的状态。处于终止态的线程虽然已经结束了，但其所占<br>资源还没有被回收，而且还可以被重新复活。因此不应该让线程长时间处于这种状态。线程处于终止态后应该及时进<br>行资源回收。   </p><h2 id="线程函数与线程标识符"><a href="#线程函数与线程标识符" class="headerlink" title="线程函数与线程标识符"></a>线程函数与线程标识符</h2><p>线程函数就是线程创建后进入运行态后要执行的函数。执行线程，说到底就是执行线程函数。这个函数是用户自定义<br>的，然后在创建线程时将自定义的该函数作为参数传入线程创建函数。同理，中断线程的执行就是中断线程函数的执<br>行，以后再恢复线程的时候，就会在前面线程函数暂停的地方开始继续执行下面的代码。结束线程也就是不再运行线<br>程函数。线程的函数可以是一个全局函数或类的静态函数，比如在POSIX线程库中，它通常这样声明：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> *<span class="hljs-title">ThreadProc</span><span class="hljs-params">(<span class="hljs-type">void</span> *argv)</span></span>;<br></code></pre></td></tr></table></figure><p>其中，参数argv指向要传递给线程的数据，这个参数是在创建线程的时候作为参数传入线程创建函数中的。函数的返<br>回值应该表示线程函数运行的结果：成功还是失败。注意函数名ThreadProc可以是自定义的函数名，这个函数是用户<br>先定义好，然后由系统来调用。   </p><p>在创建线程的时候，系统会为线程分配一个唯一的ID作为线程的标识，这个ID号从线程创建开始存在，一直伴随着线<br>程的结束才消失。线程结束后，该ID就自动不存在，不需要显式的去清除它。通常线程创建成功后就会返回该线程ID</p><h2 id="使用POSIX多线程API"><a href="#使用POSIX多线程API" class="headerlink" title="使用POSIX多线程API"></a>使用POSIX多线程API</h2><p>在使用POSIX多线程函数前，先要熟悉常用的一些API函数，常见的与线程相关的API函数如下：</p><img src="/2023/02/20/linux%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89/1.png" class=""><p></p>使用这些API函数时需要包含头文件pthread.h，并且在编译时需要加上库pthread，表示包含多线程库文件。<hr><h3 id="1-线程的创建"><a href="#1-线程的创建" class="headerlink" title="1.线程的创建"></a>1.线程的创建</h3><p>在POSIX的API中，创建线程的函数是：pthread_create，该函数声明如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pthread_create</span><span class="hljs-params">(<span class="hljs-type">pthread_t</span> *pid, <span class="hljs-type">const</span> <span class="hljs-type">pthread_attr_t</span> *attr, <span class="hljs-type">void</span> *(*start_routine)(<span class="hljs-type">void</span> *), <span class="hljs-type">void</span> *arg)</span></span>;<br></code></pre></td></tr></table></figure><p>其中，参数pid是一个指针，指向创建成后的线程的ID，pthread_t其实就是unsigned long int；attr是指向线程属性<br>结构pthread_attr_t的指针，如果为NULL，则使用默认属性；start_routine指向线程函数的地址，线程函数就是线程<br>创建后要执行的函数；arg指向要传给线程函数的参数，如果执行成功，函数返回0。   </p><p>pthread_create创建完子线程后，主线程会继续执行pthread_create之后的代码，所以这就可能出现创建的子线程还<br>没执行完，主线程就已经结束了，如控制台程序，主线程结束就意味着进程结束了。在这种情况下，我们就需要让主<br>线进行等待，等待子线程全部运行结束后再继续执行主线程。还有一种情况，主线程为了统计各个子线程工作的结果<br>而需要等待子线程结束后再继续执行，此时主线程就要等待了。    </p><p>POSIX提供了函数pthread_join来等待子线程结束，即子线程的线程函数执行完毕后，pthread_join才返回，它是一个<br>阻塞函数，会让主线程挂起（休眠，让出CPU），直到子线程都退出，同时pthread_join能让子线程所占资源得到释放<br>子线程退出后，主线程会接收到系统的信号，从休眠中恢复。函数pthread_join声明如下：  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pthread_join</span><span class="hljs-params">(<span class="hljs-type">pthread_t</span> pid, <span class="hljs-type">void</span> **value_ptr)</span></span>;<br></code></pre></td></tr></table></figure><p>其中参数pid是所等待线程的id号；value_ptr通常可设为NULL，如果不为NULL，则pthread_join复制一份线程退出值<br>到一个内存区域，并让*value_ptr指向该内存区域，因此pthread_join还有一个重要功能就是能获得子线程的返回值<br>。pthread_join执行成功就返回0，否则返回错误码。  </p><p>以下是一些简单的线程api函数的简单使用示例：  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"> <span class="hljs-number">1</span> <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br> <span class="hljs-number">2</span> <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br> <span class="hljs-number">3</span> <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br> <span class="hljs-number">4</span><br> <span class="hljs-number">5</span> <span class="hljs-function"><span class="hljs-type">void</span> * <span class="hljs-title">tdfunc</span><span class="hljs-params">(<span class="hljs-type">void</span> *argv)</span></span><br><span class="hljs-function"> 6 </span>&#123;<br> <span class="hljs-number">7</span>     <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;线程自定义函数\n&quot;</span>);<br> <span class="hljs-number">8</span>     <span class="hljs-keyword">return</span> (<span class="hljs-type">void</span>*)<span class="hljs-number">0</span>;<br> <span class="hljs-number">9</span> &#125;<br><span class="hljs-number">10</span> <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function">11 </span>&#123;<br><span class="hljs-number">12</span>     <span class="hljs-type">pthread_t</span> tid;<br><span class="hljs-number">13</span>     <span class="hljs-type">int</span> ret = <span class="hljs-built_in">pthread_create</span>(&amp;tid, <span class="hljs-literal">NULL</span>, tdfunc, <span class="hljs-literal">NULL</span>);<br><span class="hljs-number">14</span>     <span class="hljs-keyword">if</span>(ret)&#123;<br><span class="hljs-number">15</span>     ¦   <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;线程创建失败\n&quot;</span>);<br><span class="hljs-number">16</span>     ¦   <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br><span class="hljs-number">17</span>     &#125;<br><span class="hljs-number">18</span>     <span class="hljs-built_in">sleep</span>(<span class="hljs-number">3</span>);<br><span class="hljs-number">19</span>     <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;线程成功创建并运行，这是主线程\n&quot;</span>);<br><span class="hljs-number">20</span>     <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><span class="hljs-number">21</span> &#125;<br></code></pre></td></tr></table></figure><p> 编译运行：<br> <figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs elixir">akatsuki<span class="hljs-variable">@312hours</span><span class="hljs-symbol">:~/akatsuki_info/linuxio</span><span class="hljs-variable">$ </span>./test_createthread<br>线程自定义函数<br>线程成功创建并运行，这是主线程<br>akatsuki<span class="hljs-variable">@312hours</span><span class="hljs-symbol">:~/akatsuki_info/linuxio</span>$<br></code></pre></td></tr></table></figure></p><p>给线程传入参数：  </p><img src="/2023/02/20/linux%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89/2.png" class="">  <p></p>  <hr><p>给线程传入结构体：  </p><img src="/2023/02/20/linux%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89/3.png" class="">  <h3 id="2-线程的属性"><a href="#2-线程的属性" class="headerlink" title="2.线程的属性"></a>2.线程的属性</h3><p>POSIX标准规定线程具有多个属性。线程主要的属性包括分离状态（detached state）、调度策略和参数（scheduling<br>policy and parameters）、作用域（scope）、栈尺寸（stack size）、栈地址（stack address）、优先级（priority）<br>等。linux为线程属性定义了一个联合体pthread_attr_t（不是结构体），定义在&#x2F;usr&#x2F;include&#x2F;bits&#x2F;pthreadtypes.h<br>中，代码如下：  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">union</span> <span class="hljs-title class_">pthread_attr_t</span>&#123;<br><br>    <span class="hljs-type">char</span> __sieze[__SIZEOF_PTHREAD_ATTR_T];<br>    <span class="hljs-type">long</span> <span class="hljs-type">int</span> __align;<br>&#125;;<br></code></pre></td></tr></table></figure><p>从定义可以看出，属性值都是存放在数组__size中的，这样很不方便存取。但是，linux已经准备了一组专门用于存<br>取属性值的函数。如果要获取线程的属性，首先要用函数pthread_getattr_np来获取属性值，再用相应的函数来具体<br>获得某个属性值。函数pthread_getattr_np声明如下：  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _GNU_SOURCE</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pthread_getattr_np</span><span class="hljs-params">(<span class="hljs-type">pthread_t</span> thread, <span class="hljs-type">pthread_attr_t</span> *attr)</span></span>;<br></code></pre></td></tr></table></figure><p>其中，参数thread是线程ID，attr返回线程属性的内容。如果函数执行成功就返回0，否则返回错误码。需要注意的是<br>使用该函数需要定义宏_GNU_SOURCE，而且要在pthread.h前定义。当函数pthread_getattr_np获得的属性变量不再需<br>要的时候，应该用函数pthread_attr_destroy进行销毁。<br>在上文使用函数pthread_create创建线程示例程序的时候，属性联合体指针参数用了NULL，此时创建的线程具有默认<br>属性，即为非分离、大小为1MB的堆栈，与父线程有同样级别的优先级。如果要创建非默认属性的线程，可以在创建线<br>程之前用函数pthread_attr_init来初始化一个线程属性联合体，然后再调用相应API函数来设置相应的属性，接着把<br>属性联合体的地址作为参数传入pthread_create。其中函数pthread_attr_init声明如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pthread_attr_init</span><span class="hljs-params">(<span class="hljs-type">pthread_attr_t</span> *attr)</span></span>;<br></code></pre></td></tr></table></figure><p>其中，参数attr为指向线程属性的指针。函数执行成功返回0，否则返回一个错误码。   </p><p>需要注意的一点是，在使用线程属性创建完线程后，需要使用pthread_attr_destroy函数将其销毁，从而释放相关资<br>源。函数pthread_attr_destroy声明如下：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-built_in">int</span> pthread<span class="hljs-constructor">_attr_destroy(<span class="hljs-params">pthread_attr_t</span> <span class="hljs-operator">*</span><span class="hljs-params">attr</span>)</span>;<br></code></pre></td></tr></table></figure><p>其中，参数attr为指向属性的指针。函数执行成功返回0，否则返回一个错误码。   </p><p>除了可以创建指定属性的线程外，也可以通过一些其它的api函数来改变已创建完成的线程的默认属性。下面来看线程<br>的一些具体属性。</p><h5 id="（1）分离状态"><a href="#（1）分离状态" class="headerlink" title="（1）分离状态"></a>（1）分离状态</h5><p>分离状态（detached state）是线程一个很重要的属性。POSIX线程的分离状态决定一个线程以什么样的方式来终止自<br>己。此状态和上文所说的线程状态不是同一个概念，上文所说的线程的状态是不同操作系统上的线程都有的状态（也<br>即线程活动状态的说明），而这里所讲的分离状态是可连接，即创建线程时如果使用默认属性，则分离状态属性就是<br>可连接的，因此，默认属性下创建的线程是可连接线程。<br>POSIX下的线程要么是分离的，要么是非分离状态的（也称可连接的，joinable）。前者用宏PTHREAD_CREATE_DETACHED<br>表示，后者用宏PTHREAD_CREATE_JOINABLE表示。默认情况下创建的线程是可连接的，一个可连接的线程是可以被其它<br>线程收回资源和杀死（或称取消）的，它并不会主动释放资源（如栈空间），且必须等待其它线程来收回资源。因此<br>要在主线程中使用pthread_join函数，该函数是一个阻塞函数，它会等到子线程的资源被释放后才返回。<em><strong>注意：如<br>果是可连接的线程，当线程函数自己返回结束时或者调用pthread_exit结束时，都不会释放线程所占用的堆栈和线程<br>描述符，只有调用pthread_join且返回后，这些资源才会被释放。</strong></em>这对于父进程长时间运行的程序来说，其结果<br>会是灾难性的，因为如果父进程没有调用pthread_join并且长时间的运行，那么这些可连接的线程资源就一直不会被<br>释放，相当于变成了僵尸线程，僵尸线程越来越多，直到最后没有资源可以再用。<br>如果父线程先于子线程退出，且没有调用pthread_join函数，此时是不会造成资源泄露的，因为子线程将会被init进<br>程所收养，这个时候init进程就是它的父进程，将会调用wait系列函数来为其回收资源。<br>为了避免内存泄漏，可连接的线程在创建时，要么被设为DETACHED（可分离），要么使用pthread_join来回收其资源。<br>另外需要注意，一个线程不能被多个线程等待，否则第一个接收到信号的线程成功返回，而其余调用pthread_join的<br>线程将得到错误代码ESRCH。   </p><p>可连接的线程与之对应的是可分离的线程，这种线程运行结束时，其资源将立刻被系统回收。可以理解为这种线程能<br>独立（分离）出去，可以自生自灭，父线程不用管。将一个线程设置为可分离状态有两种方式：一种是调用api函数<br>pthread_detach，将线程转换为可分离线程；另一种是在创建线程时就将它设置为可分离状态，基本过程是首先初始<br>化一个线程属性的联合体变量（通过函数pthread_attr_init)，然后将其设置为可分离状态（通过函数pthread_attr_setdetachstate)，<br>最后将该结构变量的地址作为参数传入线程创建函数pthread_create，这样所创建的线程就是处于可分离状态的线程</p><p>函数pthread_attr_setdetachstate用来设置线程的分离状态属性，声明如下：  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pthread_attr_setdetachstate</span><span class="hljs-params">(<span class="hljs-type">pthread_attr_t</span> *attr, <span class="hljs-type">int</span> detachstate)</span></span>;<br></code></pre></td></tr></table></figure><p>其中，参数attr是要设置的属性联合体；detachstate是要设置的分离状态值，可以取值PTHREAD_CREATE_DETACHED或<br>PTHREAD_CREATE_JOINABLE。如果函数执行成功就返回0，否则返回非零的错误码。   </p><p>示例：创建一个分离线程 </p><img src="/2023/02/20/linux%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89/4.png" class=""><p></p>上图示例中，分离线程设置成功后，让主线程休眠1秒，以使得子线程有机会执行。因为如果main线程较早退出将会导致整个进程退出，子线程将不会有机会执行。在可连接线程中，可以使用阻塞函数pthread_join来等待子线程的结束但是可分离线程中却不存在这种函数。试想如果子线程长时间执行，那么sleep应该设置多久才合适呢？实际上，对于可分离线程：可以采用让主线程退出而进程不退的方式，一直等到子线程退出后进程才退出的方法来替代sleep。即在主线程中调用函数pthread_exit，在main线程中如果调用了pthread_exit函数，那么此时终止的只是main线程，而系统为该进程分配的资源此时对其它线程仍然保持打开的状态，直到其它线程全部都终止。需要注意的是，如果在非主线程main中（其它子线程）调用pthread_exit就不会有这样的效果，只会退出当前子线程。   <hr><p>示例：创建一个主线程先退出的可分离线程</p><img src="/2023/02/20/linux%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89/5.png" class=""><p></p>    <p>至此，可以总结一下可连接线程和可分离线程的重要区别：在任何一个时间点上，线程是可连接的（joinable），或者<br>是分离的（detached）。一个可连接的线程在自己退出时或pthread_exit时都不会释放线程所占用堆栈和线程描述符<br>需要通过其它线程调用pthread_join之后，这些资源才会被释放；相反的是，一个分离的线程是不能被其它线程回收<br>或杀死的，它所占用的资源在终止时由系统自动释放。  </p><hr><p>除了可以直接创建分离线程外，还可以把可连接线程转为可分离线程，这样做的一个好处是，当把一个可连接线程转<br>为可分离线程后，当它自己退出或调用pthread_exit后就可以由系统回收释放其资源了。调用函数pthread_detach就<br>可将一个连接线程转为分离线程，该函数声明如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pthread_detach</span><span class="hljs-params">(<span class="hljs-type">pthread_t</span> thread)</span></span>;<br></code></pre></td></tr></table></figure><p>其中，参数thread是要设置为分离状态的线程id。函数执行成功返回0，否则返回一个错误码，比如错误码EINVAL表示<br>目标线程不是一个可连接的线程，ESRCH表示该ID的线程没有找到。<em><strong>需要注意的是：如果一个线程已经被其它线程<br>连接了，那么pthread_detach不会产生任何作用，并且被连接的线程继续处于可连接的状态；同时，如果一个线程成<br>功的进行了pthread_detach后，其它线程再想要连接它则一定会失败。</strong></em>   </p><p>函数pthread_attr_getdetachstate用于获取线程的分离状态属性。该函数声明如下：  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pthread_attr_getdetachstate</span><span class="hljs-params">(<span class="hljs-type">pthread_attr_t</span> *attr, <span class="hljs-type">int</span> *detachstate)</span></span>;<br></code></pre></td></tr></table></figure><p>其中，参数attr为属性结构体指针，detachstate返回分离状态。函数执行成功返回0，否则返回错误码。  </p><p>示例：取得当前线程属性的分离状态  </p><img src="/2023/02/20/linux%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89/6.png" class=""><img src="/2023/02/20/linux%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89/7.png" class=""><p></p>从上图可以看出，默认属性创建的线程属性是可连接状态的。    <hr><p>示例：可连接线程转为可分离线程  </p><img src="/2023/02/20/linux%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89/8.png" class=""><img src="/2023/02/20/linux%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89/9.png" class=""><p></p>  <hr><h5 id="（2）栈尺寸"><a href="#（2）栈尺寸" class="headerlink" title="（2）栈尺寸"></a>（2）栈尺寸</h5><p>除了分离状态属性外，线程的另一个重要属性就是栈尺寸。这个属性对于在线程函数中开设栈上的内存空间非常重要<br>。局部变量、函数参数、返回地址等都存放在栈空间里，而动态分配的内存（比如用malloc）或全局变量等都属于堆<br>空间。在线程函数中使用局部变量时（如数组），需要了解默认栈尺寸的大小，以避免超过默认的栈空间。获取线程<br>栈尺寸属性的函数是pthread_attr_getstacksize，该函数声明如下：  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pthread_attr_getstacksize</span><span class="hljs-params">(<span class="hljs-type">pthread_attr_t</span> *attr, <span class="hljs-type">size_t</span> *stacksize)</span></span>;<br></code></pre></td></tr></table></figure><p>其中，参数attr指向属性结构体，stacksize用于获得栈尺寸（单位是字节），指向size_t类型的变量。如果函数执行<br>成功就返回0，否则返回错误码。  </p><p>示例：获取 线程默认栈尺寸、最小尺寸  </p><img src="/2023/02/20/linux%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89/10.png" class=""><p></p>  <h5 id="（3）调度策略"><a href="#（3）调度策略" class="headerlink" title="（3）调度策略"></a>（3）调度策略</h5><p>线程中另外一个重要的属性就是线程的调度策略。当进程中有了多个线程后，就要管理这些线程如何去占用CPU，这就<br>是线程调度。线程调度通常由操作系统来安排，不同操作系统的调度方法（即调度策略）不同，如有的操作系统采用<br>轮询法来调度。要理解线程的调度，需要了解什么是实时和非实时。实时就是指操作系统对一些中断等的响应时效性<br>非常高，非实时则正好相反。windows和linux都属于非实时操作系统，也叫分时操作系统；VxWorks则属于实时操作系<br>统。实时性的表现主要是抢占，抢占通过优先级来控制，优先级高的任务最先占用CPU。linux虽然是一个非实时操作<br>系统，但其线程也有实时和非实时之分，具体的调度策略可以分为三种：SCHED_OTHER（分时调度策略）、SCHED_FIFO<br>（先来先服务调度策略）、SCHED_RR（实时调度策略，时间片轮转）。在创建线程的时候可以指定其调度策略，默认<br>的调度策略是SCHED_OTHER(即分时调度策略)。SCHED_FIFO和SCHED_RR只用于实时线程。   </p><blockquote><p>(1) SCHED_OTHER</p><blockquote><p>SCHED_OTHER表示分时调度策略（也可称轮转策略），是一种非实时调度策略，系统会为每个线程分配一段<br>运行时间，称为时间片。该调度策略是不支持优先级的，如果去获取该调度策略下的最高和最低优先级，可以<br>发现是0。该调度策略有点像排队取钱，前面的人占用了atm，如果前面的人不离开的话是无法轮到后面的人的，<br>而且不能强行驱离（不支持优先级，无vip特权）。  </p></blockquote><p>(2) SCHED_FIFO</p><blockquote><p>SCHED_FIFO表示先来先服务调度策略，支持优先级抢占。SCHED_FIFO策略下，CPU让一个先来的线程执行<br>完再调度下一个线程，顺序就是按照创建线程的先后。线程一旦占用CPU就会一直运行，直到有更高优先级的<br>任务到达或自己放弃CPU。如果有和正在运行的线程具有同样优先级的线程已经就绪，就必须等待正在运行的<br>线程主动放弃后才可以运行这个就绪的线程。SCHED_FIFO策略下，可设置的优先级范围是1-99。   </p></blockquote><blockquote><p>(3)SCHED_RR<br>SCHED_RR表示时间片轮转（轮询）调度策略，但支持优先级抢占，因此也是一种实时调度策略。SCHED_RR<br>策略下，CPU会分配给每个线程一个特定的时间片，当线程的时间片用完时，系统将重新分配时间片，并将线程<br>置于实时线程就绪队列的尾部，这样就保证了所有具有相同优先级的线程能够被公平的调度。  </p></blockquote></blockquote><p>使用函数sched_get_priority_min和sched_get_priority_max可以获取以上三种调度策略能设置的最小和最大优先级<br>函数声明如下：  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sched.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sched_get_priority_min</span><span class="hljs-params">(<span class="hljs-type">int</span> policy)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sched_get_priority_max</span><span class="hljs-params">(<span class="hljs-type">int</span> policy)</span></span>;<br></code></pre></td></tr></table></figure><p>以上函数用来获取实时线程可设置的最低和最高优先级值。其中，参数policy为调度策略，可以取值为SCHED_FIFO和<br>SCHED_RR，或者SCHED_OTHER。对于SCHED_OTHER，由于是分时策略，因此返回为0。另外两个策略的返回值最低优先级<br>为1，最高优先级为99。   </p><p>查看三种调度策略的优先级：  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"> <span class="hljs-number">1</span> <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br> <span class="hljs-number">2</span> <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sched.h&gt;</span></span><br> <span class="hljs-number">3</span> <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br> <span class="hljs-number">4</span><br> <span class="hljs-number">5</span> <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"> 6 </span>&#123;<br> <span class="hljs-number">7</span>     std::cout&lt;&lt;<span class="hljs-string">&quot;SCHED_OTHER: min = &quot;</span>&lt;&lt;<span class="hljs-built_in">sched_get_priority_min</span>(SCHED_OTHER)&lt;&lt;<span class="hljs-string">&quot;, max = &quot;</span>&lt;&lt;<span class="hljs-built_in">sched_get_priority_max</span>(SCHED_OTHER)&lt;&lt;std::endl;<br> <span class="hljs-number">8</span>     std::cout&lt;&lt;<span class="hljs-string">&quot;SCHED_FIFO: min = &quot;</span>&lt;&lt;<span class="hljs-built_in">sched_get_priority_min</span>(SCHED_FIFO)&lt;&lt;<span class="hljs-string">&quot;, max = &quot;</span>&lt;&lt;<span class="hljs-built_in">sched_get_priority_max</span>(SCHED_FIFO)&lt;&lt;std::endl;<br> <span class="hljs-number">9</span>     std::cout&lt;&lt;<span class="hljs-string">&quot;SCHED_RR: min = &quot;</span>&lt;&lt;<span class="hljs-built_in">sched_get_priority_min</span>(SCHED_RR)&lt;&lt;<span class="hljs-string">&quot;, max = &quot;</span>&lt;&lt;<span class="hljs-built_in">sched_get_priority_max</span>(SCHED_RR)&lt;&lt;std::endl;<br><span class="hljs-number">10</span>     <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><span class="hljs-number">11</span> &#125;<br></code></pre></td></tr></table></figure><p> 编译运行：  </p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs elixir">akatsuki<span class="hljs-variable">@312hours</span><span class="hljs-symbol">:~/akatsuki_info/linuxio</span><span class="hljs-variable">$ </span>./test_schedthread<br><span class="hljs-symbol">SCHED_OTHER:</span> min = <span class="hljs-number">0</span>, max = <span class="hljs-number">0</span><br><span class="hljs-symbol">SCHED_FIFO:</span> min = <span class="hljs-number">1</span>, max = <span class="hljs-number">99</span><br><span class="hljs-symbol">SCHED_RR:</span> min = <span class="hljs-number">1</span>, max = <span class="hljs-number">99</span><br>akatsuki<span class="hljs-variable">@312hours</span><span class="hljs-symbol">:~/akatsuki_info/linuxio</span>$<br></code></pre></td></tr></table></figure><p>对于SCHED_FIFO和SCHED_RR调度策略，由于支持优先级抢占，因此具有高优先级的可运行的（即在就绪状态）线程总<br>是先运行。如果一个正在运行的线程在未完成其时间片时，出现一个更高优先级的线程就绪，那么正在运行的这个线<br>程就可能在未完成其时间片前被抢占。甚至一个线程会在未开始其时间片前就被抢占了，只能等待下一次的被选择运<br>行。当linux系统切换线程时，将会执行一个上下文转换的操作，即保存正在运行的线程相关的状态，装载另一个线程<br>的状态，并开始新线程的执行。虽然linux支持实时调度策略（如SCHED_FIFO和SCHED_RR)，但它依旧属于非实时操作<br>系统，这是因为实时操作系统对响应时间有者苛刻的要求，而linux作为一个通用操作系统达不到这一要求（通用操作<br>系统要求能支持一些较差的硬件，从硬件角度就达不到实时要求）。此外，linux的线程优先级是动态的，也就是说即<br>使高优先级线程还没有完成，低优先级线程还是会得到一定的时间片。宇宙飞船常用的操作系统Vxworks就是一个RTOS<br>（Real-Time Operating System，实时操作系统）。</p><h3 id="3-线程的结束"><a href="#3-线程的结束" class="headerlink" title="3.线程的结束"></a>3.线程的结束</h3><p>线程安全退出是编写多线程时一个重要事项。在Linux下，线程的结束通常有以下原因：  </p><blockquote><ul><li>(1) 在线程函数中调用pthread_exit函数。</li><li>(2) 线程所属的进程结束了，如调用了exit。</li><li>(3) 线程函数执行结束后返回（return）了。</li><li>(4) 线程被同一进程中的其它线程通知结束或取消。</li></ul></blockquote><p>第一种方式，与windows下的线程退出函数ExitThread不同，pthread_exit不会导致C++对象被析构，所以可以放心使<br>用。第二种方式最好不用，因为线程函数如果有C++对象，则C++对象不会被销毁。第三种方式推荐使用，线程函数执行<br>到return后结束是最安全的方式，所以尽可能将线程设计成这样的形式。最后一种方式通常用于其它线程要求目标线程<br>结束运行的情况，譬如目标线程在执行一个耗时的复杂计算，但用户需要中途终止它，此时就可以向目标线程发送取<br>消信号。（1）和（3）属于线程自己主动终止，（2）和（4）属于被动结束，即外部希望其终止。<br>一般情况下，进程中各个线程的运行是相互独立的。线程的终止并不会相互通知，也不会影响其它线程。对于可连接<br>线程，它终止后，所占用的资源并不会随着线程的终止而归还系统，而是仍被线程所在的进程持有，需要调用函数<br>pthread_join来同步并释放资源。    </p><h5 id="（1）线程主动结束"><a href="#（1）线程主动结束" class="headerlink" title="（1）线程主动结束"></a>（1）线程主动结束</h5><p>线程主动结束一般是在线程函数中使用return语句或者调用pthread_exit函数。函数pthread_exit声明如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pthread_exit</span><span class="hljs-params">(<span class="hljs-type">void</span> *retval)</span></span>;<br></code></pre></td></tr></table></figure><p>其中，参数retval就是线程退出时返回给主线程的值。注意，线程函数的返回类型是void*。另外，在main线程中调<br>用”pthread_exit(NULL)“的时候，将结束main线程，但进程并不立即退出(目的是让子线程有执行的机会)。  </p><p>示例：获取线程退出时的返回值  </p><img src="/2023/02/20/linux%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89/11.png" class=""><p></p>从上例可以看到，线程返回值有两种方式传递：一种是调用函数pthread_exit；另一种是直接return。pthread_exit函数的参数为void* ，因此需要通过指针的形式传递。接收线程函数返回值时使用了pthread_join函数，该函数有两个作用，其一是等待线程结束，其二是获取线程结束时的返回值。它的第二个参数是void**二级指针，所以需要传递给它的是指针的地址。还需要注意示例线程函数内部使用的是static变量，这是因为需要确保线程函数返回结束时该变量依旧存在未被释放。如果不使用static定义变量，那么函数内部的变量将开辟到栈区，在函数调用结束的时候，此内存空间必然是被释放不存在了。     <h5 id="（2）线程被动结束"><a href="#（2）线程被动结束" class="headerlink" title="（2）线程被动结束"></a>（2）线程被动结束</h5><p>函数pthread_kill和pthread_cancel可以结束同进程中的其它线程。使用方法是同进程中的一个线程向目标线程使用<br>pthread_kill发送信号。注意：该函数不是杀死线程，而是向目标线程发送信号，接收信号的目标线程必须先用函数<br>sigaction注册该信号的处理函数。pthread_kill声明如下：  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pthread_kill</span><span class="hljs-params">(<span class="hljs-type">pthread_t</span> threadid, <span class="hljs-type">int</span> signal)</span></span>;<br></code></pre></td></tr></table></figure><p>其中，参数threadid是目标线程的id，signal是信号类型，通常是大于0的值，如果等于0则是用来检测线程是否存在。<br>函数执行成功就返回0，否则返回错误码，如ESRCH表示线程不存在，EINVAL表示信号不合法.  </p><ul><li>注意：向指定该id的线程发送signal信号，如果线程代码内不做处理，则按照信号默认的行为影响整个进程，<br>也就是说，如果给一个线程发送了SIGQUIT，但该线程却没有实现对该信号处理的signal函数，则整个进程将会退出，<br>所以，如果pthread_kill()函数的第二个参数如果不为0，那么一定要实现目标线程对该信号的处理函数，否则将会<br>影响到整个进程。</li></ul><p>示例:向目标线程发送结束信号</p><img src="/2023/02/20/linux%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89/12.png" class=""><p></p>主线程等待15秒后向子线程发送了终止信号，可以看到子线程在收到信号后随即终止了在运行中的子线程。  <hr><p>示例：判断线程是否已经结束  </p><img src="/2023/02/20/linux%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89/13.png" class=""><p></p>上图在main线程休眠10秒后，测试子线程是否还存活，如果仍旧存活就发送终止信号，结束子线程。  <hr><p>除了使用pthread_kill函数发送信号来结束线程外，还可以使用函数pthread_cancel来取消目标线程的执行。所谓取<br>消目标线程的执行，也就是发送取消请求，请求目标线程终止其运行。*** 需要注意的是，就算请求发送成功，也<br>不一定意味着目标线程就停止运行了。*** 函数pthread_cancel声明如下：  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pthread_cancel</span><span class="hljs-params">(<span class="hljs-type">pthread_t</span> threadid)</span></span>;<br></code></pre></td></tr></table></figure><p>其中，参数threadid表示要被取消的目标线程id，如果发送取消请求成功，则函数返回0，否则返回错误码。发送取消<br>请求成功并不意味着目标线程立即停止运行，即系统并不会马上关闭被取消线程，只有在被取消线程接下来调用一些系<br>统函数如pthread_testcancel(让内核去检测是否需要取消当前线程)，或者C库函数（如printf）时，才会真正的结束<br>目标线程。这种在线程执行过程中检测是否有未响应的取消信号的地方叫作取消点，常见的取消点有printf、read&#x2F;write<br>、sleep、pthread_testcancel等函数调用的地方。如果被取消线程停止成功，就将自动返回常数PTHREAD_CANCELED<br>（这个值是-1），可以使用pthread_join取得该退出值。<br>函数pthread_testcancel让内核去检测是否需要取消当前线程，声明如下：  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pthread_testcancel</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>;<br></code></pre></td></tr></table></figure><p>该函数作为锚点让内核有机会去检测是否有取消请求过来。   </p><p>示例：使用取消线程函数（不设置取消点）</p><img src="/2023/02/20/linux%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89/14.png" class=""><p></p>上图发送取消信号后，实际线程并未结束，因为没有锚定取消点，所以内核无法终止该线程。     <hr><p>示例：使用取消线程函数（设置取消点）  </p><img src="/2023/02/20/linux%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89/15.png" class=""><p></p>使用pthread_testcancel()设置取消点后，就可以终止该线程（使用sleep和printf等效果相同）。编译该代码时可能会报错，需要添加参数，如下所示：       <img src="/2023/02/20/linux%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89/16.png" class=""><p></p>  <hr><h3 id="线程资源释放"><a href="#线程资源释放" class="headerlink" title="线程资源释放"></a>线程资源释放</h3><p>线程的主动结束可以认为是线程的正常终止，这种方式是可预见的。被动结束是其它线程要求目标线程结束，这种退<br>出方式不可预知，属于是一种异常终止。不论是可预见的线程终止还差异常终止，都会存在资源释放的问题。在不考<br>虑因运行出错而退出的前提下，保证线程终止时能顺利释放掉自己所占用的资源，尤其是锁资源，一个是必须要解决<br>的问题。<br>需要经常面对的是资源独占锁的使用情形：线程为了访问临界资源而为其加上锁，但在访问过程中被外界取消，如果<br>取消成功了，且还没来得及执行解锁，则该临界资源将永远处于锁定状态而得不到释放。因为外界取消操作是不可预<br>见的，因此需要有一个机制来简化用于资源释放的编程处理，也就是需要一个在线程退出时执行清理的机会。  </p><p>示例代码：   </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> * <span class="hljs-title">threadfunc</span><span class="hljs-params">(<span class="hljs-type">void</span> * argv)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">pthread_mutex_lock</span>(&amp;mutex);<br>    sock = <span class="hljs-built_in">accept</span>(.....);<br>    <span class="hljs-built_in">pthread_mutex_unlock</span>(&amp;mutex);<br>&#125;<br></code></pre></td></tr></table></figure><p>该示例中，线程在执行accept时会阻塞等待客户端的连接，当有连接或者出现故障时返回，如果在此过程中有其它线<br>程调用 pthread_cancel或者类似函数请求该线程立即退出，该线程在收到信号后，会从accept中退出，然后终止线程。<br>但是此时还没有执行解锁函数pthread_mutex_unlock(&amp;mutex)，该锁资源没有被释放从而会造成其它线程的死锁问题，<br>即其它等待该锁资源的线程将永远不会得到该锁。所以必须在线程接收到cancel后，用其它方式保证异常退出时可以<br>清理锁资源等。<br>POSIX线程库提供了函数pthread_cleanup_push和pthread_cleanup_pop来处理线程异常退出时的资源清理。这两个函<br>数采用先入后出的栈结构，前者用来把清理资源的函数入栈；后者用来弹出栈顶清理资源的函数，并根据参数来决定<br>是否执行该清理函数。<br>pthread_cleanip_push函数声明如下:</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs delphi">#inclede &lt;pthread.h&gt;<br>void pthread_cleanup_push(void <span class="hljs-comment">(*routine)(void*)</span>, void *arg);<br></code></pre></td></tr></table></figure><p>其中，参数routine是一个函数指针，arg是该函数的参数。<br>由pthread_cleanup_push压栈的清理函数在遇到下面三种情况时会执行：  </p><blockquote><ul><li>(1) 线程主动结束时，比如return或者调用pthread_exit的时候。  </li><li>(2) 线程被其它线程取消时，也就是有其它线程对该线程调用了pthread_cancel函数。  </li><li>(3) 调用函数pthread_cleanup_pop，且其参数为非0时。</li></ul></blockquote><p>函数pthread_cleanup_pop声明如下：  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pthread.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pthread_cleanup_pop</span><span class="hljs-params">(<span class="hljs-type">int</span> execute)</span></span>;<br></code></pre></td></tr></table></figure><p>其中，参数execute用来决定在弹出栈顶清理函数的同时是否执行该清理函数，取0时则表示不执行该清理函数，非0则<br>代表执行该清理函数。需要注意的是函数pthread_cleanup_pop与pthread_cleanup_push需要成对的出现在同一个函数<br>中，否则会出现语法错误。<br>有了上述这两个函数后，上述示例的可能引起死锁的线程就可以改为：  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> * <span class="hljs-title">threadfunc</span><span class="hljs-params">(<span class="hljs-type">void</span> * argv)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">pthread_cleanup_push</span>(clean_func, ...);<span class="hljs-comment">/*压栈一个清理函数clean_func*/</span><br>    <span class="hljs-built_in">pthread_mutex_lock</span>(&amp;mutex);<span class="hljs-comment">/*加锁*/</span><br>    socket = <span class="hljs-built_in">accept</span>(....);<span class="hljs-comment">/*调用阻塞函数*/</span><br>    <span class="hljs-built_in">pthread_mutex_unlock</span>(&amp;mutex);<span class="hljs-comment">/*解锁*/</span><br>    <span class="hljs-built_in">pthread_cleanup_pop</span>(<span class="hljs-number">0</span>);<span class="hljs-comment">/*弹出清理函数，参数为0，不执行*/</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>；<br>&#125;<br></code></pre></td></tr></table></figure><p>上述修改之后的代码，如果accept被其它线程cancel然后退出，就会自动调用clean_func函数，在该清理函数中可以<br>处理释放资源；如果accept未被cancel退出，那么线程就继续执行下来的代码，当执行到pthread_mutex_unlock(&amp;mutex)时<br>线程自己正确的释放了锁资源，再执行到pthread_cleanup_pop(0)时，会将未执行的清理函数出栈，并且不会执行它。<br>这样该线程函数就变为了一个较安全的函数了。   </p><p>示例：线程主动退出，调用清理函数：  </p><img src="/2023/02/20/linux%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89/17.png" class=""><p></p><p>上图示例中，无论是return还是pthread_exit都回引起清理函数的执行，需要注意的是，pthread_cleanup_push和pop<br>函数必须成对出现，否则编译不过。   </p><p>示例：使用pthread_cleanup_pop调用清理函数   </p><img src="/2023/02/20/linux%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89/18.png" class=""><p></p>       <p>上例可以看出，连续压栈的话，先入栈的函数最后出栈，后入栈的函数在栈顶会先出栈。因此pthread_cleanup_pop(1)<br>执行的是后压入在栈顶的n，所以输出数值应该是2。pthread_exit退出线程时，引发执行的清理函数是先压栈的m，所<br>以后输出1。  </p><p>示例：取消线程时调用清理函数  </p><img src="/2023/02/20/linux%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89/19.png" class=""><img src="/2023/02/20/linux%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89/20.png" class=""><p></p>     <p>从上例可以看出，子线程循环打印i值，一直到被取消。由于循环中存在系统调用printf，因此可以取消成功，取消<br>成功的时候将会调用清理函数，清理函数将会输出循环i的最终值。</p>]]></content>
    
    
    <categories>
      
      <category>linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>线程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>linux进程通信（消息队列）</title>
    <link href="/2023/02/15/linux%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1%EF%BC%88%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%EF%BC%89/"/>
    <url>/2023/02/15/linux%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1%EF%BC%88%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h2><p>消息队列也是进程间常用的通信方法。从多方面看，消息队列类似于有名管道，但是却没有打开和关闭管道的复杂关<br>联性，同样的，消息队列也无法解决类似于管道上的阻塞问题。消息队列提供了非亲缘关系的进程间通信，与有名管道<br>相比，它的优点在于独立于发送与接收的进程，这减少了在打开与关闭有名管道之间同步的困难性。消息队列提供了一<br>种由一个进程向另一个进程发送数据块的方法，每一个数据块被看作有一个类型，而接收进程可以独立接收具有不同<br>类型的数据块。消息队列的好处是几乎可以完全避免同步问题，并且可以通过发送消息屏蔽有名管道的问你，而且某<br>些情况可以使用紧急方式发送消息。缺点就是，每一个数据块也有最大尺寸的限制，同时在系统中所有消息队列的块<br>尺寸也有一个上限。linux系统有两个定义：MSGMAX和MSGMNB，分别用于定义单个消息与一个队列的最大尺寸。这些<br>宏定义可能在其它系统上不存在或者不相同。linux提供一组消息队列函数供使用，声明如下：  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/msg.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">msgctl</span><span class="hljs-params">(<span class="hljs-type">int</span> msqid , <span class="hljs-type">int</span> cmd , <span class="hljs-keyword">struct</span> msqid_ds *buf)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">msgget</span><span class="hljs-params">(<span class="hljs-type">key_t</span> key , <span class="hljs-type">int</span> msgflg)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">msgrcv</span><span class="hljs-params">(<span class="hljs-type">int</span> msqid , <span class="hljs-type">void</span> *msg_ptr , <span class="hljs-type">size_t</span> msg_sz , <span class="hljs-type">long</span> <span class="hljs-type">int</span> msgtype , <span class="hljs-type">int</span> msgflg)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">msgsnd</span><span class="hljs-params">(<span class="hljs-type">int</span> msqid , <span class="hljs-type">const</span> <span class="hljs-type">void</span> *msg_ptr , <span class="hljs-type">size_t</span> msg_sz , <span class="hljs-type">int</span> msgflg)</span></span>;<br></code></pre></td></tr></table></figure><p>与信息号和共享内存一样，头问价sys&#x2F;types.h与sys&#x2F;ipc.h通常也是需要包含的。  </p><h2 id="创建、打开消息队列"><a href="#创建、打开消息队列" class="headerlink" title="创建、打开消息队列"></a>创建、打开消息队列</h2><p>函数msgget用于得到一个已存在的消息队列标识符或创建一个消息队列对象，声明如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/ipc.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/msg.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">msgget</span><span class="hljs-params">(<span class="hljs-type">key_t</span> key , <span class="hljs-type">int</span> msgflg)</span></span>;<br></code></pre></td></tr></table></figure><p>其中，参数key表示消息队列的键值（类似于数据库表中的键值概念），用于标识一个消息队列，函数将它与已有的消<br>息队列对象的关键字进行比较，以此来判断消息队列对象是否已经创建，如果宏取IPC_PRIVATE（数值为0）表示创建<br>一个私有队列，在理论上只可以被当前进程所访问，key_t是一个32位的整型；参数msgflg表示创建或访问消息队列的<br>具体方式，常取值如下：   </p><blockquote><ul><li>IPC_CREAT: 如果消息队列对象不存在，则创建消息队列对象，否则进行打开操作。要创建一个新的消息队列，<br>IPC_CREAT特殊位必须与其它的权限位进行或操作。如果消息队列已经存在，IPC_CREAT标记只是简单地被忽略。</li><li>IPC_EXCL: 和IPC_CREAT一起使用（使“|”连接），如果消息对象不存在，则创建，否则产生一个错位并返回。</li></ul></blockquote><p>如果函数执行成功，则返回一个正数作为消息队列标识符，失败则返回-1。错误原因存于error中，一些常见的错误码<br>如下：  </p><blockquote><ul><li>EACCES: 指定的消息队列已存在，但调用进程没有权限访问它。</li><li>EEXIST: key指定的消息队列已经存在，而msgflg中同时指定IPC_CREAT和IPC_EXCL标志。</li><li>ENOENT: key指定的消息队列不存在，同时msgflg中没有指定IPC_CREAT标志。</li><li>ENOMEM: 需要建立消息队列，但内存不足。</li><li>ENOSPC: 需要建立消息队列，但已达到系统的限制。</li></ul></blockquote><p>函数之所以需要键值key是因为进程间的通信必须有一个公共的标识来确保两个进程处于同一个信道（这个信道就是<br>消息队列），再将这个公共标识与该信道绑定，任何进程只要使用同一个标识，内核就可以通过该标识找到对应的信<br>道（即队列），而这个公共标识就是键值key。</p><h2 id="获取和设置消息队列的属性"><a href="#获取和设置消息队列的属性" class="headerlink" title="获取和设置消息队列的属性"></a>获取和设置消息队列的属性</h2><p>函数msgctl用于获取和设置消息队列的属性。该函数声明如下：  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/ipc.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/msg.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">msgctl</span><span class="hljs-params">(<span class="hljs-type">int</span> msqid, <span class="hljs-type">int</span> cmd, <span class="hljs-type">int</span> cmd, <span class="hljs-keyword">struct</span> msqid_ds *buf )</span></span>;<br></code></pre></td></tr></table></figure><p>其中，参数msqid是消息队列标识符；cmd代表要对消息队列进行的操作，它的取值可以是：   </p><blockquote><ul><li>IPC_STAT: 读取消息队列的msqid_ds数据，并将其存储在buf指定的地址中。</li><li>IPC_SET: 设置消息队列的属性，要设置的属性需先存储在buf中，可设置的属性包括：msg_perm.uid、<br>msg_perm.gid、msg_perm.mode以及msg_qbytes。</li><li>IPC_EMID: 将队列从系统内核中删除。</li></ul></blockquote><p>参数buf指向消息队列管理结构体msqid_ds，该结构体定义如下：  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">msqid_ds</span>&#123;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">ipc_perm</span> msg_perm;                   <br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">msg</span> *msg_first;              <span class="hljs-comment">/* first message on queue,unused*/</span><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">msg</span> *msg_last;               <span class="hljs-comment">/* last message in queue,unused*/</span><br>    <span class="hljs-type">__kernel_time_t</span> msg_stime;         <span class="hljs-comment">/* last msgsnd time*/</span><br>    <span class="hljs-type">__kernel_time_t</span> msg_rtime;         <span class="hljs-comment">/* last msgrcv time*/</span><br>    <span class="hljs-type">__kernel_time_t</span> msg_ctime;         <span class="hljs-comment">/* last change time*/</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> msg_lcbytes;         <span class="hljs-comment">/* reuse junk fields for 32 bit*/</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> msg_lqbytes;         <span class="hljs-comment">/* ditto*/</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> msg_cbytes;         <span class="hljs-comment">/* current number of bytes on queue*/</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> msg_qnum;           <span class="hljs-comment">/* number of messages in queue*/</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> msg_qbytes;         <span class="hljs-comment">/* max number of bytes on queue*/</span><br>    <span class="hljs-type">__kernel_ipc_pid_t</span> msg_lspid;      <span class="hljs-comment">/* pid of last msgsnd*/</span><br>    <span class="hljs-type">__kernel_ipc_pid_t</span> msg_lrpid;      <span class="hljs-comment">/* last receive pid*/</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>如果函数执行成功就返回0，失败返回-1，错误原因可以通过错误码errno获得，常见的错误码如下：  </p><blockquote><ul><li>EACCESS: 参数cmd为IPC_STAT，无权限读取该消息队列。</li><li>EFAULT： 参数buf指向无效的内存地址。</li><li>EIDRM：  标识符为msqid的消息队列已被删除。</li><li>EINVAL： 无效的参数cmd或msqid。</li><li>EPERM：  参数cmd为IPC_SET或IPC_RMID，却无足够的权限执行。</li></ul></blockquote><h2 id="将消息送入消息队列"><a href="#将消息送入消息队列" class="headerlink" title="将消息送入消息队列"></a>将消息送入消息队列</h2><p>msgsnd函数用来将消息送入消息队列。该函数声明如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/ipc.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/msg.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">msgsnd</span><span class="hljs-params">(<span class="hljs-type">int</span> msqid, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *msgp, <span class="hljs-type">size_t</span> msgsz, <span class="hljs-type">int</span> msgflg)</span></span>;<br></code></pre></td></tr></table></figure><p>其中，参数msqid是消息队列对象的标识符（由msgget函数得到），第二个参数msgp指向消息缓冲区的指针，该缓冲区<br>用来暂时存储要发送的消息，通常可用一个通用结构来表示信息：  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">msgbuf</span>&#123;<br>    <span class="hljs-type">long</span> mtype;       <span class="hljs-comment">/* 消息类型，必须大于0*/</span><br>    <span class="hljs-type">char</span> mtext[<span class="hljs-number">1</span>];    <span class="hljs-comment">/* 消息数据*/</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>第三个参数msgsz是要发送信息的长度（字节数），可以用以下公式计算： </p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp">msgsz = <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> mymsgbuf) - <span class="hljs-keyword">sizeof</span>(<span class="hljs-built_in">long</span>);<br></code></pre></td></tr></table></figure><p>第四个参数msgflg是控制函数行为的标志，可以取以下的值：  </p><blockquote><ul><li>0: 表示阻塞方式，线程将被阻塞直到消息可以被写入。</li><li>IPC_NOWAIT: 表示非阻塞方式，如果消息队列已满或其它情况无法送入消息，函数立即返回。</li></ul></blockquote><p>函数成功执行返回0，失败则返回-1，出错原因可以从errno获得，常用值如下：</p><blockquote><ul><li>EACCES: 调用进程在消息队列上没有写权限，同时没有CAP_IPC_OWNER权限。</li><li>EAGAIN：由于消息队列的msg_qbytes限制和msgflg中指定IPC_NOWAIT标志，因此消息不能被发送。</li><li>EFAULT：msgp指针指向的内存空间不可访问。</li><li>EIDRM：消息队列已被删除。</li><li>EINTR：等待消息队列孔家可用时被信号中断。</li><li>EINVAL：参数无效。</li><li>ENOMEM：系统内存不足，无法将msgp指向的消息复制进来。</li></ul></blockquote><h2 id="从消息队列中读取一条新消息"><a href="#从消息队列中读取一条新消息" class="headerlink" title="从消息队列中读取一条新消息"></a>从消息队列中读取一条新消息</h2><p>函数msgrcv用于从消息队列中读出一条新信息。该函数声明如下： </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/ipc.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/msg.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">ssize_t</span> <span class="hljs-title">msgrcv</span><span class="hljs-params">(<span class="hljs-type">int</span> msqid, <span class="hljs-type">void</span> *msgp, <span class="hljs-type">size_t</span> msgsz, <span class="hljs-type">long</span> msgtyp, <span class="hljs-type">int</span> msgflg)</span></span>;<br></code></pre></td></tr></table></figure><p>其中，参数msqid表示消息队列的标识符，msgp指向要读出消息的缓冲区。通常消息缓冲区结构为： </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">msgbuf</span>&#123;<br>    <span class="hljs-type">long</span> mtype;   <span class="hljs-comment">/* 消息类型，必须大于0*/</span><br>    <span class="hljs-type">char</span> mtext[<span class="hljs-number">1</span>];  <span class="hljs-comment">/* 消息数据*/</span><br>&#125;<br></code></pre></td></tr></table></figure><p>msgsz表示消息数据的长度，msgtyp表示从消息队列内读取的消息形态。如果值为0，则表示消息队列中的所有消息都<br>会被读取。参数msgflg是控制函数行为的标志，可以取以下的值：  </p><blockquote><ul><li>(1) 0: 表示阻塞方式，当消息队列为空时，一直等待。</li><li>(2) IPC_NOWAIT: 表示非阻塞方式，消息队列为空时，不等待，马上返回-1，并设定错误码为ENOMSG。如果函数<br>执行成功，msgrcv返回复制到mtext数组的实际字节数，若失败则返回-1，errno被设为以下的某个值：<blockquote><ul><li>E2BIG: 消息文本长度大于msgsz，并且msgflg中没有指定。</li><li>G_NOERROREACCES: 调用进程没有读权限，同时没有CAP_IPC_OWNER权限</li><li>EAGAIN: 消息队列为空，并且msgflg中没有指定IPC_NOWAIT。</li><li>EFAULT: msgp指向的空间不可访问。</li><li>EIDRM: 当进程睡眠等待接收消息时，消息已被删除。</li><li>EINTR: 当进程睡眠等待接收消息时，被信号中断。</li><li>EINVAL: 参数无效。</li><li>ENOMSG: msgflg中指定了IPC_NOWAIT,同时所请求类型的消息不存在。</li></ul></blockquote></li></ul></blockquote><h2 id="键值生成"><a href="#键值生成" class="headerlink" title="键值生成"></a>键值生成</h2><p>系统建立IPC通信（如消息队列、共享内存）时，必须指定一个键值。键值可以使用ftok函数取得，该函数声明如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/ipc.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">key_t</span> <span class="hljs-title">ftok</span><span class="hljs-params">(<span class="hljs-type">char</span> *fname, <span class="hljs-type">int</span> id)</span></span>;<br></code></pre></td></tr></table></figure><p>其中，参数fname是指定的文件名，这个文件必须是存在的而且可以访问的。id是子序号，它是一个8bit的整数，即范<br>围为0-255，可以根据自己的约定随意设置，没有什么限制条件。若函数执行成功，则会返回key_t键值，否则返回-1.<br>在一般的unix中，通常是将文件的索引节点取出，然后在前面加上子序号就得到key_t值。ftok根据路径名提取文件信<br>息，再根据这些信息及参数id合成key，该路径可以随便设置，但必须是存在的路径，ftok只是根据文件inode在系统内<br>的唯一性来取一个数值，和文件的权限无关。<br><em><strong>需要注意的是，在使用ftok()函数时，返回值key是和指定文件fname的索引节点号和子序列号id有关的，但并不意<br>味着fname和id不变key就不会改变。例如：在访问同一共享内存的多个进程先后调用ftok()的时间段中，如果fname<br>指向的文件或者目录被删除而且又重新创建，那么文件系统会赋予这个同名文件新的inode节点信息，于是这些进程<br>调用的ftok()虽然都能正常返回，但是返回的键值key却未必是相同的了。由此可能导致的结果是，原本这些进程意<br>图访问同一个共享内存对象，然而由于它们各自得到的键值不同，实际上进程指向的共享内存段并不相同！</strong></em>   </p><p>示例：生成键值  </p><img src="/2023/02/15/linux%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1%EF%BC%88%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%EF%BC%89/1.png" class="">  <p></p>  <p>通过上图执行结果可以看到，ftok获取的键值是由ftok函数的第二个参数的后8位、st_dev的后8位以及st_ino的后16<br>位组成的。</p><hr><p>示例：使用消息队列进行通信</p><img src="/2023/02/15/linux%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1%EF%BC%88%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%EF%BC%89/2.png" class=""><img src="/2023/02/15/linux%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1%EF%BC%88%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%EF%BC%89/3.png" class=""><img src="/2023/02/15/linux%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1%EF%BC%88%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%EF%BC%89/4.png" class=""><img src="/2023/02/15/linux%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1%EF%BC%88%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%EF%BC%89/5.png" class=""><img src="/2023/02/15/linux%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1%EF%BC%88%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%EF%BC%89/6.png" class="">   <p></p>使用消息队列的程序，并没有必要提供自己的同步机制，这是相比于管道来说一个巨大的优点。  ]]></content>
    
    
    <categories>
      
      <category>linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>消息队列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>linux进程通信（管道）</title>
    <link href="/2023/02/14/linux%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1%EF%BC%88%E7%AE%A1%E9%81%93%EF%BC%89/"/>
    <url>/2023/02/14/linux%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1%EF%BC%88%E7%AE%A1%E9%81%93%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h2><p>所谓管道，是指用于连接都进程和写进程，以实现它们之间通信的共享文件，故又称作管道文件。这种进程通信方式<br>首创于unix系统，它能传送大量的数据并且十分有效，很多操作系统都引入了这种通信方式，linux同样也支持管道。<br>管道是一种以先进先出的方式保存一定数量数据的特殊文件，而且管道一般是单向的。写进程将数据写入管道的一端<br>读进程从管道另一端读取数据，以便腾出空间使写进程可以继续写入新发数据，所以所有的数据只能读取一次。linux<br>下管道的大小有一定的限制。实际上，管道是一个固定大小的缓冲区，在linux中，该缓冲区的大小为一个页面，即4kb<br>。<br>为了协调进程之间的通信，管道通信机制必须能够提供读写进程之间的同步机制。如果一个进程试图写入一个已满的<br>管道，在默认情况下，系统会自动阻塞该进程，直到管道能够有空间接收数据。同样，如果试图读一个空的管道，进<br>程也会被阻塞，直到管道有可读的数据。此外，如果一个进程以读方式打开一个管道，而没有另外的进程以写方式打<br>开该管道，则同样会造成该进程阻塞（因为没有数据会写到这个管道里）。同样，当一个进程试图对没有读进程的管<br>道进行写操作时，则会出现异常，导致进程终止。管道是一个进程连结数据流到另一个进程的通道，它通常用作把一<br>个进程的输出通过管道连接到另一个进程的输入。在shell中，可以通过使用符号”|“来使用管道。如：   </p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs tap">akatsuki@312hours:~/akatsuki_info/linuxio$ ls -l | grep test<br>-rwxr-xr-x<span class="hljs-number"> 1 </span>akatsuki akatsuki<span class="hljs-number"> 16256 </span>Feb<span class="hljs-number"> 13 </span>18:49 test_kill<br>-rw-r--r--<span class="hljs-number"> 1 </span>akatsuki akatsuki  <span class="hljs-number"> 885 </span>Feb<span class="hljs-number"> 13 </span>18:58 test_kill.cpp<br>-rwxr-xr-x<span class="hljs-number"> 1 </span>akatsuki akatsuki<span class="hljs-number"> 16240 </span>Feb<span class="hljs-number"> 14 </span>12:10 test_sigaction<br>-rw-r--r--<span class="hljs-number"> 1 </span>akatsuki akatsuki <span class="hljs-number"> 1028 </span>Feb<span class="hljs-number"> 14 </span>12:10 test_sigaction.cpp<br>-rwxr-xr-x<span class="hljs-number"> 1 </span>akatsuki akatsuki<span class="hljs-number"> 16424 </span>Feb<span class="hljs-number"> 14 </span>15:54 test_sigmask<br>-rw-r--r--<span class="hljs-number"> 1 </span>akatsuki akatsuki <span class="hljs-number"> 1413 </span>Feb<span class="hljs-number"> 14 </span>17:06 test_sigmask.cpp<br>-rwxr-xr-x<span class="hljs-number"> 1 </span>akatsuki akatsuki<span class="hljs-number"> 16096 </span>Feb<span class="hljs-number"> 14 </span>17:31 test_signal<br>-rw-r--r--<span class="hljs-number"> 1 </span>akatsuki akatsuki  <span class="hljs-number"> 317 </span>Feb<span class="hljs-number"> 14 </span>17:32 test_signal.cpp<br>akatsuki@312hours:~/akatsuki_info/linuxio$<br></code></pre></td></tr></table></figure><p>ls进程会把当前目录中的文件或者文件夹都列出来，现在将本来要输出到屏幕上的数据通过管道输出到grep进程中，<br>作为grep进程的输入，然后grep进程对输入的信息进行筛选，把存在test字符串的那行打印在屏幕上。  </p><h2 id="管道读写的特点"><a href="#管道读写的特点" class="headerlink" title="管道读写的特点"></a>管道读写的特点</h2><p>管道读写是通过标准的无缓冲的输入系统调用函数read()和输出系统调用函数write()实现的。系统调用read()将从一<br>个由管道文件描述符所指的管道中读取指定的字节数到缓冲区中。如果调用成功，函数将返回实际所读的字节数。如<br>果失败，将返回-1。由于管道文件有特殊性，所以读取时有其自身的特点：  </p><blockquote><ul><li>(1) 所有的读取操作总是从管道当前位置开始读，不支持文件指针的移动。</li><li>(2) 如果管道没有被其它进程以写方式打开，那么read()系统调用将返回0，也就是遇到文件末端的条件。</li><li>(3) 如果管道中没有数据，也就是管道为空，默认情况下read()系统调用将会阻塞，直到有数据被写进该管道或<br>者该管道被关闭。也可以通过fcntl()系统调用对管道进行设置，如在管道为空的情况下让read()系统调用立即返回。</li></ul></blockquote><p>数据通过系统调用write()函数写入管道。write()系统调用将数据从缓冲区向管道文件描述符所指的管道中写入。如<br>果该系统调用成功，将返回实际所写的字节数，否则返回-1。同理，管道的写操作也有其自身的特点：  </p><blockquote><ul><li>(1) 每一次的写请求操作总是附加在管道的末端。</li><li>(2) 当有多个对同一管道的写请求发生时，系统保证小于或等于4kb大小的写请求操作不会交叉进行。</li><li>(3) 如果试图对一个没有被任何进程以读方式打开的管道进行写操作，则将会产生SIGPIPE信号。默认情况下（假<br>如SIGPIPE信号没有被捕获），该进程将会被系统终止。</li><li>(4) 默认情况下，对管道的写操作请求会导致进程阻塞，因为如果设备处于忙状态，write()系统调用会被阻塞并<br>且将被延迟写入，当然也可以通过fcntl()系统调用对管道进行设置。</li></ul></blockquote><h2 id="管道局限性"><a href="#管道局限性" class="headerlink" title="管道局限性"></a>管道局限性</h2><p>管道有以下的几个局限性：  </p><blockquote><ul><li>(1) 数据自己读却不能自己写。</li><li>(2) 数据一旦被读走，便不在管道中存在，不可反复读取。</li><li>(3) 由于管道采用半双工通信方式，因此数据只能在一个方向上流动。</li><li>(4) 只能在有公共祖先的进程间使用管道。</li></ul></blockquote><h2 id="管道函数pipe"><a href="#管道函数pipe" class="headerlink" title="管道函数pipe"></a>管道函数pipe</h2><p>管道是一种基本的IPC机制，由pipe函数创建，该函数声明如下：  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pipe</span><span class="hljs-params">(<span class="hljs-type">int</span> filedes[<span class="hljs-number">2</span>])</span></span>;<br></code></pre></td></tr></table></figure><p>其中，参数filedes表示两个文件描述符，filedes[0]指向管道的读端，filedes[1]指向管道的写端。如果函数调用<br>成功返回0，调用失败则返回-1。<br>调用pipe函数时，在内核中开辟一块缓冲区（称为管道）用于通信，它有一个读端和一个写端，然后通过filedes参数<br>传出给用户程序两个文件描述符，filedes[0]指向管道的读端，filedes[1]指向管道的写端。所以管道在用户程序中<br>看起来就像一个打开的文件，通过read(filedes[0])和write(filedes[1])向这个文件读写数据其实是在读写内核缓冲<br>区。需要注意的是，管道创建时默认打开了文件描述符，且默认是以阻塞（block）模式打开的。  </p><h2 id="读写管道read-x2F-write函数"><a href="#读写管道read-x2F-write函数" class="headerlink" title="读写管道read&#x2F;write函数"></a>读写管道read&#x2F;write函数</h2><p>读写管道的函数和读写文件的函数一样，都是read和write。使用这两个函数读写管道时有两点需要注意：  </p><blockquote><ul><li>(1) 当没有数据可读时，read调用阻塞，即进程暂停执行，一直等到有数据到来为止。</li><li>(2) 当管道满的时候，write调用阻塞，直到有进程读取数据。</li></ul></blockquote><h2 id="等待子进程中断或结束的函数wait"><a href="#等待子进程中断或结束的函数wait" class="headerlink" title="等待子进程中断或结束的函数wait"></a>等待子进程中断或结束的函数wait</h2><p>wait函数用于等待子进程中断或结束，进程一旦调用了wait，就立即阻塞自己，由wait自动分析当前进程的某个子进<br>程是否已经退出，如果让它找到了一个已经变成僵尸的子进程，wait就会收集这个子进程的信息，并把它彻底销毁后<br>返回；如果没有找到这样一个子进程，wait就会一直阻塞在这里，直到有一个出现为止，该函数声明如下：  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/wait.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">pid_t</span> <span class="hljs-title">wait</span><span class="hljs-params">(<span class="hljs-type">int</span> *status)</span></span>;<br></code></pre></td></tr></table></figure><p>子进程的结束状态值会由参数status返回，如果不在意结束状态值，则参数status可以设置为NULL。如果执行成功，<br>则返回子进程识别码（PID），如果有错位发生，则返回-1。失败原因存于errno中。   </p><p>管道创建成功后，创建该管道的进程（父进程）同时掌握着管道的读端和写端。为了使用管道实现父子进程间的通信<br>通常可以采用以下方式：  </p><img src="/2023/02/14/linux%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1%EF%BC%88%E7%AE%A1%E9%81%93%EF%BC%89/1.png" class=""><img src="/2023/02/14/linux%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1%EF%BC%88%E7%AE%A1%E9%81%93%EF%BC%89/2.png" class=""><blockquote><p>第一步，父进程调用pipe函数创建管道，得到两个文件描述符fd[0]、fd[1]，分别指向管道的读端和写端。<br>第二步，父进程调用fork创建子进程，此时子进程也拥有了两个指向同一管道的文件描述符。<br>第三步，父进程关闭管道读端，子进程关闭管道写端。此时父进程可以向管道中写入数据，子进程可以将管道中的<br>数据读出。由于管道是利用环形队列实现的，因此数据从写端流入管道，从读端流出。  </p></blockquote><p>示例：父子进程使用管道通信  </p><img src="/2023/02/14/linux%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1%EF%BC%88%E7%AE%A1%E9%81%93%EF%BC%89/3.png" class=""><img src="/2023/02/14/linux%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1%EF%BC%88%E7%AE%A1%E9%81%93%EF%BC%89/4.png" class=""><h2 id="使用管道的特殊情况"><a href="#使用管道的特殊情况" class="headerlink" title="使用管道的特殊情况"></a>使用管道的特殊情况</h2><p>使用管道需要注意以下四种特殊情况（假设都是阻塞I&#x2F;O操作，没有设置O_NONBLOCK标志）：   </p><blockquote><ul><li>(1) 如果所有指向管道写端的文件描述符都关闭了（管道写端引用计数为0），而仍然有进程从管道的读端读数据<br>那么管道中剩余的数据都被读取后，再次read会返回0，就像读到文件末尾一样。  </li><li>(2) 如果有指向管道写端的文件描述符没关闭（管道写端引用计数大于0），而持有管道写端的进程也没有向管道<br>中写数据，这是有进程从管道读端读数据，那么管道中剩余的数据都被读取后，再次read会阻塞，直到管道中有<br>数据可读了才读取数据并返回。</li><li>(3) 如果所有指向管道读端的文件描述符都关闭了（管道读端引用计数为0），这时有进程向管道的写端write，<br>那么该进程会收到信号SIGPIPE，通常会导致进程异常终止。当然，也可以对SIGPIPE信号实施捕捉，不终止进程。</li><li>(4) 如果有指向管道读端的文件描述符没关闭（管道读端引用计数大于0），而持有管道读端的进程也没有从管道<br>中读数据，这时有进程向管道写端写数据，那么在管道被写满时，再次write会阻塞，直到管道中有空位置了才写<br>入数据并返回。</li></ul></blockquote><h2 id="有名管道"><a href="#有名管道" class="headerlink" title="有名管道"></a>有名管道</h2><p>有名管道与无名管道最大的区别是有名管道可以用于非亲缘关系间的进程通信，而无名管道多用于亲缘关系间的通讯；<br>有名管道通讯时需要创建一个特殊的管道文件来作为非亲缘进程通讯的载体，通讯时需要使用open函数取得该载体的<br>文件描述符，在通讯进程完全结束退出后，该管道文件仍然会存在于用户空间。创建管道文件的函数声明如下：   </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">mkfifo</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *pathname , <span class="hljs-type">mode_t</span> mode)</span></span>;<br></code></pre></td></tr></table></figure><p>其中pathname为将要创建的管道文件路径名称，mode为文件权限，创建的权限仍然与umask相关联。函数成功时返回0，<br>失败时返回-1。mkfifo函数先在用户空间创建管道文件，此时并没有在内核中创建管道，只有当open函数打开该管道文<br>件时，此时才会调用系统函数开始在内核中创建管道。   </p><p>示例：使用有名管道实现非亲缘进程间通信  </p><img src="/2023/02/14/linux%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1%EF%BC%88%E7%AE%A1%E9%81%93%EF%BC%89/5.png" class=""><img src="/2023/02/14/linux%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1%EF%BC%88%E7%AE%A1%E9%81%93%EF%BC%89/6.png" class=""><img src="/2023/02/14/linux%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1%EF%BC%88%E7%AE%A1%E9%81%93%EF%BC%89/7.png" class=""><img src="/2023/02/14/linux%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1%EF%BC%88%E7%AE%A1%E9%81%93%EF%BC%89/8.png" class=""><p></p>可以看到，非亲缘关系的进程test_wfifo和test_rfifo使用了mkfifo所创建的管道文件完成了互相通信。]]></content>
    
    
    <categories>
      
      <category>linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>管道</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>linux进程通信（信号）</title>
    <link href="/2023/02/12/linux%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1%EF%BC%88%E4%BF%A1%E5%8F%B7%EF%BC%89/"/>
    <url>/2023/02/12/linux%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1%EF%BC%88%E4%BF%A1%E5%8F%B7%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>为了能使一项任务可以协同工作，linux中的进程彼此之间必须能够进行通信。对于一个操作系统来说，进程间的通信<br>是不可或缺的。linux支持多种不同方式的进程间通信机制，如信号、管道、FIFO和Syste V IPC机制，其中IPC机制包<br>括：信号量、消息队列和共享内存三种机制。linux中的这些进程间的通信机制是从unix平台进程间通信机制继承和发<br>展而来的，而其中常用的进程间的通信方式主要有三种：信号、管道和消息队列。   </p><h2 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h2><p>信号是最早引入类unix系统中的进程间通信方式之一，linux同样支持这种通信方式。信号是很短的信息，可以被发送<br>到一组进程或者一个进程，发送给进程的这个唯一信息通常是标识信号的ID。信号的来源可以是键盘中断，也可以是<br>非法访问虚拟内存时的系统错误，这些都可以产生信号。信号也可以被shell程序用来向其子进程发送任务控制命令等<br>信号异步的发生，也就是说没有确定的时序。而收到信号的进程则采取某种处理行为或者将其忽略，大多数的信号可<br>以被阻塞，以便能够在稍后的时间里再进行处理。信号机制是在软件上对中断机制的模拟。linux使用信号主要有两个<br>目的：一是让进程意识到已经发生了一个特定的事件；二是迫使进程执行包含在其自身代码中的信号处理程序。对于<br>每一个信号，进程可以采取以下三种行为：  </p><blockquote><ul><li>(1)忽略信号。进程将忽略这个信号的出现。但有两个信号不能被忽略：SIGKILL和SIGSTOP。</li><li>(2)调用相应的信号处理函数来捕获信号并处理。进程可以事先登记特殊的信号处理函数，当进程收到信号时，信<br>号处理函数则被调用执行，当信号处理函数执行完毕返回后，被中断的进程则从刚才的断点处接着继续开始执行。</li><li>(3)执行与这个信号相关的默认操作。默认的操作由内核预定义，并且根据信号的类型不同，默认的操作也不同，<br>默认操作可以是以下类型：忽略信号，内核将信号丢弃，信号对进程没有任何影响（进程永远不知道曾经出现过<br>该信号）；终止（杀死）进程，有时是指进程异常终止，而不是进程因调用exit而发生的正常终止；产生核心转<br>储文件，同时进程终止，核心转储文件包含对进程虚拟内存的镜像，可将其加载到调试器中以检查进程终止时的<br>状态；停止进程（不是终止），使进程暂时停止执行；执行之前被暂停的进程。</li></ul></blockquote><p>linux支持posix标准信号和实时信号，但内核不使用实时信号。可以使用命令kill -l来显示linux支持的信号列表：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">akatsuki</span>@<span class="hljs-number">312</span>hours:~/akatsuki_info/linuxio$ kill -l<br> <span class="hljs-attribute">1</span>) SIGHUP       <span class="hljs-number">2</span>) SIGINT       <span class="hljs-number">3</span>) SIGQUIT      <span class="hljs-number">4</span>) SIGILL       <span class="hljs-number">5</span>) SIGTRAP<br> <span class="hljs-attribute">6</span>) SIGABRT      <span class="hljs-number">7</span>) SIGBUS       <span class="hljs-number">8</span>) SIGFPE       <span class="hljs-number">9</span>) SIGKILL     <span class="hljs-number">10</span>) SIGUSR1<br><span class="hljs-attribute">11</span>) SIGSEGV     <span class="hljs-number">12</span>) SIGUSR2     <span class="hljs-number">13</span>) SIGPIPE     <span class="hljs-number">14</span>) SIGALRM     <span class="hljs-number">15</span>) SIGTERM<br><span class="hljs-attribute">16</span>) SIGSTKFLT   <span class="hljs-number">17</span>) SIGCHLD     <span class="hljs-number">18</span>) SIGCONT     <span class="hljs-number">19</span>) SIGSTOP     <span class="hljs-number">20</span>) SIGTSTP<br><span class="hljs-attribute">21</span>) SIGTTIN     <span class="hljs-number">22</span>) SIGTTOU     <span class="hljs-number">23</span>) SIGURG      <span class="hljs-number">24</span>) SIGXCPU     <span class="hljs-number">25</span>) SIGXFSZ<br><span class="hljs-attribute">26</span>) SIGVTALRM   <span class="hljs-number">27</span>) SIGPROF     <span class="hljs-number">28</span>) SIGWINCH    <span class="hljs-number">29</span>) SIGIO       <span class="hljs-number">30</span>) SIGPWR<br><span class="hljs-attribute">31</span>) SIGSYS      <span class="hljs-number">34</span>) SIGRTMIN    <span class="hljs-number">35</span>) SIGRTMIN+<span class="hljs-number">1</span>  <span class="hljs-number">36</span>) SIGRTMIN+<span class="hljs-number">2</span>  <span class="hljs-number">37</span>) SIGRTMIN+<span class="hljs-number">3</span><br><span class="hljs-attribute">38</span>) SIGRTMIN+<span class="hljs-number">4</span>  <span class="hljs-number">39</span>) SIGRTMIN+<span class="hljs-number">5</span>  <span class="hljs-number">40</span>) SIGRTMIN+<span class="hljs-number">6</span>  <span class="hljs-number">41</span>) SIGRTMIN+<span class="hljs-number">7</span>  <span class="hljs-number">42</span>) SIGRTMIN+<span class="hljs-number">8</span><br><span class="hljs-attribute">43</span>) SIGRTMIN+<span class="hljs-number">9</span>  <span class="hljs-number">44</span>) SIGRTMIN+<span class="hljs-number">10</span> <span class="hljs-number">45</span>) SIGRTMIN+<span class="hljs-number">11</span> <span class="hljs-number">46</span>) SIGRTMIN+<span class="hljs-number">12</span> <span class="hljs-number">47</span>) SIGRTMIN+<span class="hljs-number">13</span><br><span class="hljs-attribute">48</span>) SIGRTMIN+<span class="hljs-number">14</span> <span class="hljs-number">49</span>) SIGRTMIN+<span class="hljs-number">15</span> <span class="hljs-number">50</span>) SIGRTMAX-<span class="hljs-number">14</span> <span class="hljs-number">51</span>) SIGRTMAX-<span class="hljs-number">13</span> <span class="hljs-number">52</span>) SIGRTMAX-<span class="hljs-number">12</span><br><span class="hljs-attribute">53</span>) SIGRTMAX-<span class="hljs-number">11</span> <span class="hljs-number">54</span>) SIGRTMAX-<span class="hljs-number">10</span> <span class="hljs-number">55</span>) SIGRTMAX-<span class="hljs-number">9</span>  <span class="hljs-number">56</span>) SIGRTMAX-<span class="hljs-number">8</span>  <span class="hljs-number">57</span>) SIGRTMAX-<span class="hljs-number">7</span><br><span class="hljs-attribute">58</span>) SIGRTMAX-<span class="hljs-number">6</span>  <span class="hljs-number">59</span>) SIGRTMAX-<span class="hljs-number">5</span>  <span class="hljs-number">60</span>) SIGRTMAX-<span class="hljs-number">4</span>  <span class="hljs-number">61</span>) SIGRTMAX-<span class="hljs-number">3</span>  <span class="hljs-number">62</span>) SIGRTMAX-<span class="hljs-number">2</span><br><span class="hljs-attribute">63</span>) SIGRTMAX-<span class="hljs-number">1</span>  <span class="hljs-number">64</span>) SIGRTMAX<br><span class="hljs-attribute">akatsuki</span>@<span class="hljs-number">312</span>hours:~/akatsuki_info/linuxio$<br></code></pre></td></tr></table></figure><p>上面的列表中，编号为1<del>31的信号为传统unix支持的信号，是不可靠信号（非实时的）；编号为32</del>64的信号是后来扩<br>充的，称作可靠信号（实时信号）。不可靠信号和可靠信号的区别在于前者不支持排队，可能会造成信号丢失，而后<br>者不会。  </p><p><strong>（1）SIGHUP</strong><br>本信号在用户终端连接结束时（正常或非正常）发生，通常是在终端的控制进程结束时，通知同一session内的各个作<br>业，这时它们与控制终端不再关联。登录linux时，系统会分配给登录用户一个终端（session），在这个终端运行的<br>所有程序，包括前台进程和后台进程组，一般都属于这个session，当用户退出linux的登录时，前台进程组和后台进<br>程组有对终端进行输出的那些进程将会收到SIGHUP信号，这个信号的默认操作为终止进程，因此前台进程组和后台进<br>程组有终端输出的进程就会终止。该信号可以被捕获，比如wget能捕获SIGHUP信号，并忽略它，这样即使推出了linux<br>登录，wget也能继续下载。此外，对于与终端脱离关系的守护进程，这个信号用于通知它重新读取配置文件。<br><strong>（2）SIGINT</strong><br>程序终止（interrupt）信号，在用户输入INTR字符时（通常是Ctrl+C）发出，用于通知前台进程组终止进程。<br><strong>（3）SIGQUIT</strong><br>和SIGINT类似，但由QUIT字符来控制。进程因收到SIGQUIT退出时会产生core文件，在这个意义上类似于一个程序错误<br>信号。<br><strong>（4）SIGILL</strong><br>执行了非法指令，通常是因为可执行文件本身出现错误，或者试图执行数据段，堆栈溢出时也有可能产生这个信号。<br><strong>（5）SIGTRAP</strong><br>由断点指令或其它trap指令产生，由debugger使用。<br><strong>（6）SIGABRT</strong><br>调用abort函数生成的信号。<br><strong>（7）SIGBUS</strong><br>非法地址，包括内存地址对齐（alignment）出错。比如访问一个4个字长的整数，但其地址不是4的倍数。它与SIGSEGV<br>的区别在于，后者是由于对合法存储地址的非法访问触发的（如访问不属于自己存储空间或只读内存空间的数据）。<br><strong>（8）SIGFPE</strong><br>在发生致命的算术运算错误时发出。不仅包括浮点运算错误，还包括溢出及除数为0等其它所有的算术错误。<br><strong>（9）SIGKILL</strong><br>用来立即结束程序的运行。本信号不能被阻塞、处理和忽略。如果管理员发现某个进程终止不了，可尝试发送该信号。<br><strong>（10）SIGUSR1</strong><br>留给用户使用<br><strong>（11）SIGSEGV</strong><br>试图访问未分配给自己的内存，或试图往没有写权限的内存地址写数据。<br><strong>（12）SIGUSR2</strong><br>留给用户使用。<br><strong>（13）SIGPIPE</strong><br>管道破裂。这个信号通常发生在进程间通信，比如彩荣FIFO（管道）通信的两个进程，读管道没打开或者意外终止就<br>往管道写，写进程会收到SIGPIPE信号。此外，用socket通信的两个进程，写进程在写socket的时候，读进程已经终止。<br><strong>（14）SIGALRM</strong><br>时钟定时信号，计算的是实际时间或时钟时间，alarm函数使用该信号。<br><strong>（15）SIGTERM</strong><br>程序结束（terminate）信号，与SIGKILL不同的是，该信号可以被阻塞和处理。通常用来要求程序自己正常退出，使<br>用shell的命令kill默认产生这个信号。如果进程终止不了，我们才会尝试SIGKILL。<br><strong>（16）SIGSTKFLT</strong><br>linux专用，数学协议处理器的栈异常。<br><strong>（17）SIGCHLD</strong><br>子进程结束时，父进程会收到这个信号。如果父进程没有处理这个信号，也没有等待（wait）子进程，子进程虽然终止<br>，但是还会在内核进程表中占有表项，这时的子进程称为僵尸进程。这种情况我们应该避免，父进程或者忽略SIGCHILD<br>信号，或者捕捉它，或者等待它派生的子进程，或者父进程先终止，这时子进程的终止自动由init进程来接管。<br><strong>（18）SIGCONT</strong><br>让一个停止（stopped）的进程继续执行。本信号不能被阻塞，可以用一个handler来让程序在由停止状态变为继续执<br>行时完成特定的工作，例如重新显示提示符。<br><strong>（19）SIGSTOP</strong><br>停止进程的执行。注意它和terminate以及interrupt的区别；该进程还未结束，只是暂停执行，本信号不饿能被阻塞<br>、处理或忽略。<br><strong>（20）SIGTSTP</strong><br>停止进程的运行，但该信号可以被处理和忽略，用户输入SUSP字符时（通常是CTRL+Z）发出这个信号。<br><strong>（21）SIGTTIN</strong><br>当后台作业要从用户终端读取数据时，该作业中的所有进程会收到SIGTTIN信号。默认是这些进程都会停止执行。<br><strong>（22）SIGTTOU</strong><br>类似于SIGTTIN，但在写终端（或修改终端模式）时收到。<br><strong>（23）SIGURG</strong><br>有“紧急”数据或带外数据（out-of-band）到达socket时产生。<br><strong>（24）SIGXCPU</strong><br>超过CPU时间资源限制。这个限制可以由getrlimit&#x2F;setrlimit来读取&#x2F;改变。<br><strong>（25）SIGXFSZ</strong><br>进程企图扩大文件，以至于超过文件大小资源限制。<br><strong>（26）SIGVTALRM</strong><br>虚拟时钟信号。类似于SIGALRM，但是计算的是该进程占用的CPU时间。<br><strong>（27）SIGPROF</strong><br>类似于SIGALRM&#x2F;SIGVTALRM，但包括该进程用的CPU时间以及系统调用的时间。<br><strong>（28）SIGWINCH</strong><br>窗口大小改变时发出。<br><strong>（29）SIGIO</strong><br>文件描述符准备就绪，可以开始进行输入&#x2F;输出操作。<br><strong>（30）SIGPWR</strong><br>电源失败。<br><strong>（31）SIGSYS</strong><br>非法的系统调用。  </p><p>以上列出的信号中：  </p><blockquote><ul><li>程序不可捕获、阻塞和忽略的信号有：SIGKILL和SIGSTOP；   </li><li>不能恢复至默认动作的信号有：SIGILL和SIGTRAP；</li><li>默认会导致进程夭折的信号有：SIGABRT、SIGBUS、SIGFPE、SIGILL、SIGIOT、SIGQUIT、SIGSEGV、SIGTRAP、SIGXCPU、SIGXFSZ；</li><li>默认会导致进程退出的信号有：SIGALRM、SIGHUP、SIGINT、SIGKILL、SIGPIPE、SIGPOLL、SIGPROF、SIGSYS、SIGTERM、SIGUSR1、SIGUSR2、SIGVTALRM；</li><li>默认会导致进程停止的信号有：SIGSTOP、SIGTSTP、SIGTTIN、SIGTTOU；</li><li>默认进程忽略的信号有：SIGCHLD、SIGPWR、SIGURG、SIGWINCH；</li></ul></blockquote><p>这些信号可以归纳为下列5种方式：  </p><blockquote><p>(1)硬件异常产生信号。比如无效的内存访问将产生SIGSEGV信号，而除数为0时将产生SIGFPE信号等。这些条件通常<br>由硬件检测到，并将其通知给内核，内核为该条件发生时正在运行的进程产生适当的信号。<br>(2)软件条件触发信号。当内核检测到某种软件条件已经发生，并将其通知给有关进程时，也产生信号，比如进程所<br>设置的定时器到期。<br>(3)用户按某些终端键位时产生信号。比如用户在键盘终端上按Ctrl+C键位将产生SIGINT信号。<br>(4)用户使用kill命令将信号发送给进程。kill命令的语法是：kill [参数] [进程号]。其中，参数通常取如下几项</p><blockquote><ul><li>-l:使用“-l”参数会列出全部的信号名称。    </li><li>-a:当处理当前进程时，不限制命令名和进程号的对应关系。  </li><li>-p:指定kill命令只打印相关进程的进程号，而不发送任何信号。  </li><li>-s:指定发送信号。  </li><li>-u:指定用户。</li></ul></blockquote><p>  一般可以用该命令终止一个失控的后台进程，比如希望尽快终止一个进程，可以使用命令：kill -9 pid号。    </p><p>(5)进程使用系统调用函数kill将信号发送给一个进程或一组进程。注意，这个系统调用kill不是杀死进程，而是一<br>个进程发送信号给另一个进程。其中，要求接收信号进程和发送信号进程的所有者相同，或者发送信号进程的所有者<br>是超级用户。  </p></blockquote><p>linux内核中并没有专门的机制来区分不同信号的相对优先级，也就是说，当有多个信号在同一时刻发出时，进程可能<br>会以任意的顺序接收到信号并进行处理。此外，当进程调用信号处理函数处理某个信号时，一般会自动阻塞相同的信号<br>，直到信号处理结束。linux通过存储在进程task_struct结构中的信息来实现信号，它维护着挂起的信号（已经产生<br>但还没有被接收的信号）、阻塞信号的掩码和进程处理每个可能信号的信息等。信号并非一产生就立刻交付给进程，<br>而是必须等到进程再次运行时才交付给进程。进程在系统调用退出之前，它都会检查是否有可以立刻发送的非阻塞信<br>号。进程也可以选择去等待信号，此时进程将一直处于可中断状态直到信号出现。</p><h2 id="信号相关的系统调用"><a href="#信号相关的系统调用" class="headerlink" title="信号相关的系统调用"></a>信号相关的系统调用</h2><p>通过系统调用，进程可以向其它进程发送信号，也可以更改默认的信号处理函数、阻塞信号的掩码以及检查是否有挂<br>起的信号等。与信号相关的系统调用主要有kill()、sigaction()、sigprocmask()、sigpending()、signal()等。  </p><h4 id="1-使用kill发送信号"><a href="#1-使用kill发送信号" class="headerlink" title="1.使用kill发送信号"></a>1.使用kill发送信号</h4><p>系统调用kill()用来向一个进程或一个进程组发送一个信号。声明如下：  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sygnal.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">kill</span><span class="hljs-params">(<span class="hljs-type">pid_t</span> pid , <span class="hljs-type">int</span> sig)</span></span>;<br></code></pre></td></tr></table></figure><p>其中第一个参数决定信号发送的对象，pid可能的选择有以下4种：  </p><blockquote><ul><li>(1) 当pid &gt; 0时，pid是sig信号欲送往的进程的标识。</li><li>(1) 当pid &#x3D; 0时，sig信号将送往所有与调用kill的那个进程属于同一个使用组的进程。</li><li>(1) 当pid &#x3D; -1时，sig信号将送往调用进程有权发送信号的所有进程，除了进程1（init）外。</li><li>(1) 当pid &lt; -1时，sig信号将送往以|pid|为组标识的进程。</li></ul></blockquote><p>参数sig标识准备发送的信号代码，如果其值为0，则没有任何信号送出，但是系统会执行错误检查，通常会利用sig值<br>为0来检验某个进程是否仍在执行。当函数成功执行时，返回0，否则返回-1，此时errno可以得到错误码，错误码值<br>EINVAL表示指定的信号码无效（参数sig不合法），错误码值EPERM表示权限不够，无法发送信号给指定进程，错误码<br>值ESRCH表示参数PID所指定的进程或进程组不存在。   </p><p>示例：使用kill发送信号终止目标进程  </p><img src="/2023/02/12/linux%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1%EF%BC%88%E4%BF%A1%E5%8F%B7%EF%BC%89/1.png" class=""><p></p>上述示例首先创建一个子进程，然后将其休眠一会儿，在父进程中判断子进程是否存在，如果存在，则发送SIGKILL信号给子进程，让其退出。     <hr><p>函数waitpid会暂时停止当前进程的执行，直到有信号到来或者子进程结束，其原型声明如下：  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/wait.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">pid_t</span> <span class="hljs-title">waitpid</span><span class="hljs-params">(<span class="hljs-type">pid_t</span> pid , <span class="hljs-type">int</span> *status , <span class="hljs-type">int</span> options)</span></span>;<br></code></pre></td></tr></table></figure><p>其中，参数pid为等待的子进程的识别码，不同的取值含义不同，具体如下：  </p><blockquote><ul><li>当pid &lt; -1时，等待进程组识别码为|pid|的任何子进程。</li><li>当pid &#x3D; -1时，等待任何子进程，相当于wait()。</li><li>当pid &#x3D; 0 时，等待进程组识别码与当前进程相同的任何子进程。</li><li>当pid &gt; 0 时，等待任何子进程识别码为pid的子进程。</li></ul></blockquote><p>参数optiongs提供了一些额外的选项来控制waitpid，常见的有WNOHANG或WUNTRACED。WNOHANG表示若pid指定的子进程<br>没有结束，则waitpid()函数返回0，不予以等待，若结束，则返回该子进程的id。WUNTRACED表示若子进程进入暂停状<br>态，则马上返回，若子进程处于结束状态，则不予以理会。如果不想使用options，可以把options设为NULL。status<br>参数用来存放子进程的结束状态。如果函数执行成功，则返回子进程识别码pid，如果有错误发生，则返回-1，失败原<br>因存于errno中。   </p><h4 id="2-使用sigaction查询或设置信号处理方式"><a href="#2-使用sigaction查询或设置信号处理方式" class="headerlink" title="2.使用sigaction查询或设置信号处理方式"></a>2.使用sigaction查询或设置信号处理方式</h4><p>系统调用sigaction()可以用来查询或这是信号处理方式。其声明如下：  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;signal.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sigaction</span><span class="hljs-params">(<span class="hljs-type">int</span> signum , <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> sigaction *act , <span class="hljs-keyword">struct</span> sigaction *oldact)</span></span>;<br></code></pre></td></tr></table></figure><p>其中参数signum表示要操作的信号，可以指定SIGKILL和SIGSTOP以外的所有信号；act表示要设置的对信号的新处理方<br>式，它是一个结构体指针；oldact表示原来对信号的处理方式。函数执行成功返回0，否则返回-1。<br>结构体struct sigaction用来描述对信号的处理，定义如下： </p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">struct</span> sigaction<br>&#123;<br>    <span class="hljs-keyword">void</span>      (*sa_handler)(<span class="hljs-built_in">int</span>);<br>    <span class="hljs-keyword">void</span>      (*sa_sigaction)(<span class="hljs-built_in">int</span> , siginfo_t * , <span class="hljs-keyword">void</span> *);<br>    sigset_t  sa_mask;<br>    <span class="hljs-built_in">int</span>       sa_flags;<br>    <span class="hljs-keyword">void</span>      (*sa_restorer)(<span class="hljs-keyword">void</span>);<br>&#125;;<br></code></pre></td></tr></table></figure><p>结构体中，成员sa_handler是一个函数指针，指向一个信号处理函数；成员sa_sigaction则是另一个信号处理函数，<br>它包含三个参数，可以获得关于信号的更详细信息，当sa_flags成员的值包含SA_SIGINFO标志时，系统将使用sa_sigaction<br>函数作为信号处理函数，否则使用sa_handler作为信号处理函数。在某些系统中，成员sa_handler和sa_sigaction被<br>放在联合体中，因此使用时不要同时设置。成员sa_mask用来指定在信号处理函数执行期间需要被屏蔽的信号，特别是<br>当某个信号被处理时，它自身会被自动放入进程的信号掩码，因此在信号处理函数执行期间，这个信号不会再度发生。</p><p>sa_flags成员用于指定信号处理的行为，它可以是以下值的“按位或”组合。   </p><blockquote><ul><li>SA_RESTART: 使被信号打断的系统调用自动重新发起。</li><li>SA_NOCLDSTOP: 使父进程在它的子进程暂停或继续运行时不会收到SIGCHLD信号。</li><li>SA_NOCLDWAIT: 使父进程在它的子进程退出时不会收到SIGCHLD信号，这时子进程如果退出也不会成为僵尸进程。</li><li>SA_NODEFER: 使对信号的屏蔽无效，即在信号处理函数执行期间，仍能发出这个信号。</li><li>SA_RESETHAND: 信号处理之后重新设置为默认的处理方式。</li><li>SA_SIGINFO: 使用sa_sigaction作为信号处理函数而不是sa_handler函数。</li></ul></blockquote><p>成员re_restorer则是一个已经废弃的数据域，不要使用。如果需要用相同的方式处理某信号的多次出现，最好用函数<br>sigaction()，因为它设置的响应函数设置后就一直有效，不会重置。<br>函数sigaction使用示例  </p><img src="/2023/02/12/linux%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1%EF%BC%88%E4%BF%A1%E5%8F%B7%EF%BC%89/2.png" class=""><img src="/2023/02/12/linux%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1%EF%BC%88%E4%BF%A1%E5%8F%B7%EF%BC%89/3.png" class=""><img src="/2023/02/12/linux%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1%EF%BC%88%E4%BF%A1%E5%8F%B7%EF%BC%89/4.png" class=""><p></p>可以看到，当我们使用kill -USR2给目标进程发送信号后，进程收到信号后通过注册的处理函数输出了相应语句。需要注意的是系统调用函数read是一个阻塞函数，会等待用户的输入，当阻塞状态被信号中断后，errno会被赋值为EINTR并且系统调用read会返回-1，表示出错且会被退出程序abort立即中断运行，sigaction注册信号处理函数时，不会自动重新发起被信号中断的系统调用，如果需要自动重新发起，需要设置SA_RESTART标志，上例设置sa.sa_flags=SA_RESTART即可。      <h4 id="3-使用sigprocmask检测或更改信号屏蔽字"><a href="#3-使用sigprocmask检测或更改信号屏蔽字" class="headerlink" title="3.使用sigprocmask检测或更改信号屏蔽字"></a>3.使用sigprocmask检测或更改信号屏蔽字</h4><p>系统调用sigprocmask()可以检测或更改信号屏蔽字。一个进程的信号屏蔽字规定了当前因阻塞而不能递送给该进程的<br>信号集。函数声明如下：  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;signal.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sigprocmask</span><span class="hljs-params">(<span class="hljs-type">int</span> how , <span class="hljs-type">const</span> <span class="hljs-type">sigset_t</span> *set , <span class="hljs-type">sigset_t</span> *oldset)</span></span>;<br></code></pre></td></tr></table></figure><p>其中，参数how用于指定信号修改的方式，可能的选择有3种：  </p><blockquote><ul><li>SIG_BLOCK：表示加入信号到进程屏蔽。</li><li>SIG_UNBLOCK: 表示从进程屏蔽里将信号删除。</li><li>SIG_SETMASK: 表示将set的值设定为新的进程屏蔽。</li></ul></blockquote><p>参数set为指向信号集的指针，在此专指新设的信号集，如果仅想读取现在的屏蔽字，可将其设为NULL；参数oldset也<br>是指向信号集的指针，在此存放原来的信号集。如果函数成功执行，返回0，失败则返回-1，errno被设为EINVAL。<br>系统调用函数sigpromask()示例：  </p><img src="/2023/02/12/linux%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1%EF%BC%88%E4%BF%A1%E5%8F%B7%EF%BC%89/5.png" class=""><p></p>从示例可以看到，红框一为程序运行后，休眠期间多次发送信号ctrl+c都不会响应，因为此时这个信号被屏蔽了，休眠结束后，从第二个红框可以看到，该信号被处理了一回，接下来屏蔽被解除后，继续休眠，从第三个红框可以看出，ctrl+c发送一次信号便响应结束。    <h4 id="4-使用sigpending检查是否有挂起的信号"><a href="#4-使用sigpending检查是否有挂起的信号" class="headerlink" title="4.使用sigpending检查是否有挂起的信号"></a>4.使用sigpending检查是否有挂起的信号</h4><p>系统调用函数sigpending()用来检查进程是否有挂起的信号，也就是已经产生但被阻塞的信号。该函数声明如下：  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;signal.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">sigpending</span><span class="hljs-params">(<span class="hljs-type">sigset_t</span> *set)</span></span>;<br></code></pre></td></tr></table></figure><p>其中，信号集通过set参数返回。如果函数执行成功，返回0，错误返回-1。sigpending的示例可以参考sigprocmask的示例。   </p><h4 id="5-使用signal设置信号处理程序"><a href="#5-使用signal设置信号处理程序" class="headerlink" title="5.使用signal设置信号处理程序"></a>5.使用signal设置信号处理程序</h4><p>系统调用signal()来为信号设置一个新的信号处理程序，可以将这个信号处理程序设置为一个用户指定的函数，或者<br>设置为宏SIG_ING和SIG_DFL，该函数声明如下：  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;signal.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">void</span> <span class="hljs-params">(*<span class="hljs-type">sighandler_t</span>)</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-type">sighandler_t</span> <span class="hljs-title">signal</span><span class="hljs-params">(<span class="hljs-type">int</span> signum , <span class="hljs-type">sighandler_t</span> handler)</span></span>;<br></code></pre></td></tr></table></figure><p>参数signum是要处理的信号，指明了所有处理的信号类型，它可以取除了SIGKILL和SIGSTOP外的任何一种信号；参数<br>handler描述了与信号关联的动作，它可以取以下三种值：   </p><p><strong>（1）SIG_IGN</strong>  </p><blockquote><p>宏SIG_IGN代表忽略信号，比如signal(SIGINT , SIG_IGN)表示忽略SIGINT信号，SIGINT信号由interrupt key产生，<br>通常是用户按了ctrl+c键或者delete键产生。  </p></blockquote><p><strong>（2）SIG_DFL</strong>  </p><blockquote><p>SIG_DFL表示恢复对信号的系统默认处理。比如signal(SIGINT , SIG_DFL)表示对信号SIGINT进行默认处理，即终止<br>该进程。  </p></blockquote><p><strong>（3）sighandler_t类型的函数指针</strong>  </p><blockquote><p>此时参数handler是sighandler_t类型的函数指针，指向一个自定义的信号处理函数，用来响应signum的信号，并且<br>这个自定义信号处理函数的参数是signum。进程只要接收到类型为signum的信号，不管其正在执行程序的哪一部分，<br>都立即执行handler函数。当handler函数执行结束后，控制权返回进程被中断的现场继续执行。  </p></blockquote><p>函数执行成功时，则返回该信号上一次的handler值，如果出错失败，则返回SIG_ERR，此时可以用过错误码errno获得。  </p><p>函数signal类似于sigaction函数，但是两者之间是有区别的，首先signal是ANSI C标准的，而sigaction符合POSIX标<br>准；其次，signal比sigaction使用简单，但要注意，如果在C语言中使用，并且gcc编译时加上-std&#x3D;c99时，signal注<br>册的信号在sa_handler被调用之前会把信号的sa_handler指针恢复，用signal函数注册的信号处理函数只会被调用一<br>次，之后收到这个信号将按默认方式处理；如果编译时没有加上-std&#x3D;c99，则signal注册的信号在处理信号时不会恢<br>复sa_handler指针，下次依旧会使用signal定义的信号处理行为来处理。在c++程序中，signal注册的信号不会在sa_handler<br>被调用之前恢复该信号的sa_handler指针。而sigaction注册的信号在处理信号时不管编译时是否加上-std&#x3D;c99,都不<br>会恢复sa_handler指针，下次收到该信号时，依旧会根据sigaction注册的信号处理行为来处理。   </p><p>示例：忽略sigint信号  </p><img src="/2023/02/12/linux%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1%EF%BC%88%E4%BF%A1%E5%8F%B7%EF%BC%89/6.png" class=""><p></p>多次发送ctrl+c并没有使得该程序退出，表明sigint信号已经被忽略。  <hr><p>示例：自定义信号处理函数</p><img src="/2023/02/12/linux%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1%EF%BC%88%E4%BF%A1%E5%8F%B7%EF%BC%89/7.png" class=""><p></p>可以看到每次发送ctrl+c信号时，都会调用自定义函数而不是退出程序。]]></content>
    
    
    <categories>
      
      <category>linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>信号</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>linux进程（二）</title>
    <link href="/2023/02/10/linux%E5%A4%9A%E8%BF%9B%E7%A8%8B%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <url>/2023/02/10/linux%E5%A4%9A%E8%BF%9B%E7%A8%8B%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a>进程调度</h2><p>进程调度也就是处理机调度。在多程序设计环境中，进程数往往多于处理机数，这将导致多个进程对处理机资源的互<br>相争夺。进程调度的任务是控制和协调进程对CPU的竞争，按照一定的调度算法使某一就绪进程取得CPU的控制权，从<br>而转为运行状态，进程调度的功能主要包括：记录系统中所有进程的执行状况；根据一定的调度算法，从就绪队列中<br>选中一个进程来准备把处理机分配给它；将处理机分配给进程，进行上下文切换，把选中进程的进程控制块内有关的<br>现场信息（如程序状态字、通用寄存器等内容）送入处理器相应的寄存器中，从而让它占用处理机运行。进程的调度<br>一般发生在以下情况：  </p><blockquote><ul><li>（1） 正在执行的进程运行完毕。</li><li>（2） 正在执行的进程调用阻塞原语将自己阻塞起来，并来进入等待状态。</li><li>（3） 执行中的进程提出I&#x2F;O请求后被阻塞。</li><li>（4） 正在执行的进程调用了P原语操作，因资源得不到满足而被阻塞；或者调用V原语操作释放了资源，从而激<br>活了等待相应资源的进程队列。</li><li>（5） 在分时系统中，时间片已经用完。</li><li>（6） 就绪队列中的某个进程的优先级变得高于当前运行进程的优先级，从而引起进程的调度。</li></ul></blockquote><p>进程调度的主要问题是采用某种算法合理有效的将处理机分配给进程，其调度算法应尽可能的压榨处理机，并提高资<br>源的利用率，减少处理机的空闲时间。衡量进程调度算法的指标有：面向系统的吞吐量、处理机的利用率、公平性和<br>资源分配的平衡性等，面向用户的作业周转时间、相应时间、可预测性等。然而，这些“合理的目标”往往是相互制<br>约的，难以满足全部要求，实际系统中，往往综合考虑这些因素，根据具体情况区别对待或者进行某些取舍。常见的<br>进程调度算法有以下4种。  </p><h5 id="（1）先来先服务法（FCFS）"><a href="#（1）先来先服务法（FCFS）" class="headerlink" title="（1）先来先服务法（FCFS）"></a>（1）先来先服务法（FCFS）</h5><p>将变为就绪状态的进程按先后次序排成队列，并按照先来先服务的方式进行调度处理，这是一种最普遍也是最简单的<br>方法。  </p><h5 id="（2）时间片轮转法（RR）"><a href="#（2）时间片轮转法（RR）" class="headerlink" title="（2）时间片轮转法（RR）"></a>（2）时间片轮转法（RR）</h5><p>其基本思想是，将CPU的处理时间划分成一个个时间片，就绪队列中的各个进程轮流运行一个时间片，当时间片结束时<br>就强制运行进程让出CPU，该进程进入就绪队列等待下一次调度，此时又去选择就绪队列中的一个其它进程，并分给一<br>个时间片，以投入运行。如此轮流调度，使得就绪队列中的所有进程在有限的时间内都可以依次轮流获得一个时间片<br>的处理机时间，这主要是分时系统中采用的一种调度算法。  </p><h5 id="（3）优先级算法"><a href="#（3）优先级算法" class="headerlink" title="（3）优先级算法"></a>（3）优先级算法</h5><p>进程调度每次将处理机分配给具有最高优先级的就绪进程。进程优先级的设置可以是静态的，也可以是动态的。静态<br>优先级是在进程创建时根据进程初始状态或者用户要求而确定，在进程运行期间不再改变。动态优先级则是指在进程<br>创建时先确定一个初始优先级，以后在进程运行中随着进程的不断推进，其优先级值也随着不断的改变。  </p><h5 id="（4）多级反馈队列法"><a href="#（4）多级反馈队列法" class="headerlink" title="（4）多级反馈队列法"></a>（4）多级反馈队列法</h5><p>在实际系统中，调度模式经常是几种调度算法的结合。多级队列反馈法就是综合了先来先服务法、时间片轮转法和优<br>先级法的一种进程调度算法。系统按照优先级别的不同设置若干个就绪队列，对级别较高的队列分配较小的时间片，<br>对级别较低的队列分配稍大一点的时间片。除了最低一级的队列采用时间片轮转法调度之外，其它各级队列均采用先<br>来先服务法调度。系统总是先调度级别较高队列中的进程，仅当该队列为空时才去调度下一级队列中的进程。当执行<br>进程用完其时间片时，便被剥夺并进入下一级就绪队列。当等待进程被唤醒时，它进入与其优先级对应的就绪队列，<br>若其优先级高于当前执行进程，便抢占CPU执行。    </p><hr><p>linux采用基于优先级可抢占式的调度系统，并使用schedule函数来实现进程调度的功能。linux所实现的可抢占还只<br>是一定程度上的抢占，因为到目前为止，linux的内核还不是抢占式的，也就意味着进程只有在用户态运行时才能被抢<br>占。如果一个进程变为TAKS_RUNNING状态，内核则会检查它的动态优先级是否大于当前正在CPU上运行的进程优先级，<br>如果是，当前执行进程将被中断，并使用调度程序选择另一个进程运行（通常是刚变为可运行状态的进程）。此外，<br>进程在它的时间片到期时也可以被抢占。  </p><h5 id="1-优先级"><a href="#1-优先级" class="headerlink" title="1.优先级"></a>1.优先级</h5><p>为了选择一个进程运行，linux调度程序必须考虑每个进程的优先级。实际上，linux采用了两种优先级：静态优先级<br>和动态优先级。静态优先级只针对实时进程，它由用户赋给实时进程，范围为1-99，以后调度程序不再改变它。动态<br>优先级只应用于普通进程，实质上它是基本时间片与当前时期内的剩余时间片之和。其实，实时进程的静态优先级总<br>是高于普通进程的动态优先级，因此只有在处于可运行状态的进程中且没有实时进程后，调度程序才开始运行普通进<br>程。  </p><h5 id="2-调度策略"><a href="#2-调度策略" class="headerlink" title="2.调度策略"></a>2.调度策略</h5><p>linux对实时进程和普通进程区别对待。对于实时进程有两种调度策略：SCHED_FIFO和SCHED_RR。SCHED_FIFO就是先进<br>先出的算法，当调度程序将CPU分配给一个进程时，该进程的task_struct结构还保留在运行队列链表的当前位置，如<br>果没有其它更高优先级的实时进程，这个进程就可以占用CPU直至运行完毕。SCHED_RR就是采用循环轮转的方法，当调<br>度程序将CPU分配给一个进程时，则将这个进程的task_struct结构放置在运行队列的末尾。这种策略确保了把CPU时间<br>公平的分配给具有相同优先级的实时进程。对于普通的分时进程采用SCHED_OTHER策略。<br>linux的进程调度由内核函数schedule实现，linux在进程终止、进程睡眠或者某个进程变为可运行状态时都可能发生<br>进程调度；如果当前进程的时间片用完，或者进程从中断、异常及系统调用返回到用户态时，同样也可能会发生进程<br>调度。linux的进程状态转换图如下：  </p><img src="/2023/02/10/linux%E5%A4%9A%E8%BF%9B%E7%A8%8B%EF%BC%88%E4%BA%8C%EF%BC%89/1.png" class=""><h6 id="（1）可运行状态（TASK-RUNNING）"><a href="#（1）可运行状态（TASK-RUNNING）" class="headerlink" title="（1）可运行状态（TASK_RUNNING）"></a>（1）可运行状态（TASK_RUNNING）</h6><p>处于这种状态的进程，要么正在CPU上运行，要么准备运行。正在CPU上运行的进程就是当前进程（由current宏表示）<br>而准备运行的进程只要得到CPU就可以立即投入运行，CPU是这些进程唯一等待的系统资源。系统种有一个运行队列，<br>用来容纳所有处于可运行状态的进程，调度程序执行时，从中选择一个进程投入运行。</p><h6 id="（2）可中断的等待状态（TASK-INTERRUPTIBLE）"><a href="#（2）可中断的等待状态（TASK-INTERRUPTIBLE）" class="headerlink" title="（2）可中断的等待状态（TASK_INTERRUPTIBLE）"></a>（2）可中断的等待状态（TASK_INTERRUPTIBLE）</h6><p>进程被挂起，直到一些条件满足为止，条件可能包括：产生一个硬件中断、释放进程正等待的系统资源或者传递一个<br>信号，这些都有可能唤醒进程，让进程的状态返回到TASK_RUNNING状态。</p><h6 id="（3）不可中断的等待状态（TASK-UNINTERRUPTIBLE）"><a href="#（3）不可中断的等待状态（TASK-UNINTERRUPTIBLE）" class="headerlink" title="（3）不可中断的等待状态（TASK_UNINTERRUPTIBLE）"></a>（3）不可中断的等待状态（TASK_UNINTERRUPTIBLE）</h6><p>这种状态与前一种状态相似，但不同的是，传递信号给睡眠的进程并不能改变其状态。这种状态不太常见，但在一些<br>特定的情况下是很有用的，例如进程必须等待，直到给定的事件发生，而其间不能被中断。</p><h6 id="（4）暂停状态（TASK-STOPPED）"><a href="#（4）暂停状态（TASK-STOPPED）" class="headerlink" title="（4）暂停状态（TASK_STOPPED）"></a>（4）暂停状态（TASK_STOPPED）</h6><p>进程的执行已经被暂停，当进程接收到SIGSTOP、SIGTSTP、SIGTTIN或者SIGTTOU信号后，进入暂停状态。当一个进程<br>正在被另一个进程监控时（例如调试程序执行ptrace系统调用来监控测试程序），每一个这样的信号都可以将这个进<br>程置于TASK_STOPPED状态。</p><h6 id="（5）僵死状态（TASK-ZOMBIE）"><a href="#（5）僵死状态（TASK-ZOMBIE）" class="headerlink" title="（5）僵死状态（TASK_ZOMBIE）"></a>（5）僵死状态（TASK_ZOMBIE）</h6><p>进程的执行已经终止，但是父进程还没有发布wait类系统调用来返回有关终止进程的信息。在父进程发布wait类系统<br>调用之前，内核不能丢弃包含在终止进程task_struct结构中的数据，因为父进程可能还需要这些信息。</p><h2 id="进程的分类"><a href="#进程的分类" class="headerlink" title="进程的分类"></a>进程的分类</h2><p>linux下，进程一般分为前台进程、后台进程和守护（Daemon）这三类。</p><h3 id="前台进程"><a href="#前台进程" class="headerlink" title="前台进程"></a>前台进程</h3><p>前台进程（也称普通进程）就是需要和用户交互的进程。默认情况下，启动一个进程都是在前台运行的，这时它就把<br>Shell给占据了，我们无法进行其它操作，一直得等到该进程终止。之前讲述的进程基本都是前台进程。查看普通进<br>程的命令是ps，可以根据需要加上不同的命令选项，比如通过进程名来查找该进程id：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">ps</span> -<span class="hljs-keyword">e</span> | <span class="hljs-keyword">grep</span> process_name<br></code></pre></td></tr></table></figure><p>process_name为查找的进程名</p><h3 id="后台进程"><a href="#后台进程" class="headerlink" title="后台进程"></a>后台进程</h3><p>对于不需要与用户交互的进程，很多时候将其放在后台启动，可以在启动该进程的时候加一个“&amp;”。譬如需要将名为：<br>test_process的进程后台执行，则可以这样:test_process &amp; 启动，此时它就是就一个后台进程，而且不会占据Shell<br>我们可以在Shell进行其它操作。但关闭Shell窗口的时候，后台进程也将随之退出。切换到后台运行的进程称为job。<br>当一个进程以后台方式启动时，系统会输出该进程的相关job信息，job的id和进程ID。后台运行的进程，可以用ps查<br>看，或者使用jobs命令查看所有后台进程job。如果想要终止某个后台进程，可使用命令killall，如要终止某个进程<br>可以使用：killall test_process，此方法过于简单粗暴。</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs elixir">akatsuki<span class="hljs-variable">@312hours</span><span class="hljs-symbol">:~/akatsuki_info/linuxio</span><span class="hljs-variable">$ </span>./test_exepwd &amp;<br>[<span class="hljs-number">1</span>] <span class="hljs-number">307</span><br>akatsuki<span class="hljs-variable">@312hours</span><span class="hljs-symbol">:~/akatsuki_info/linuxio</span><span class="hljs-variable">$ </span>目标程序接管进程，此句不会输出<br><br>[<span class="hljs-number">1</span>]+  <span class="hljs-title class_">Done</span>                    ./test_exepwd<br>akatsuki<span class="hljs-variable">@312hours</span><span class="hljs-symbol">:~/akatsuki_info/linuxio</span><span class="hljs-variable">$ </span>jobs<br>akatsuki<span class="hljs-variable">@312hours</span><span class="hljs-symbol">:~/akatsuki_info/linuxio</span>$<br></code></pre></td></tr></table></figure><p>其中[1]表示job的ID，307表示进程test_exepwd的进程ID。</p><h3 id="守护进程"><a href="#守护进程" class="headerlink" title="守护进程"></a>守护进程</h3><p>守护进程（Daemon Process）是运行在后台的一种特殊进程。它独立于控制终端并且周期性的执行某种任务或等待处<br>理某些发生的事件。守护进程是一种很有用的进程，linux中大多数服务器都是用守护进程实现的，如Internet服务器<br>inetd、web服务器httpd等，另外还有常见的守护进程包括系统日志进程syslogd、数据库服务器mysqld等。同时，守<br>护进程完成许多任务系统，如作业规划进程crond、打印进程lpd等。在linux中，每一个系统与用户进行交互的界面<br>称为终端，每一个从此终端开始运行的进程都会依附于这个终端，这个终端称就称为这些进程的控制终端，当控制终<br>端被关闭时，相应的进程都会自动关闭，然而守护进程是脱离终端运行的，之所以要脱离终端，是为了更好的在后台<br>提供服务。守护进程一般在系统启动时开始运行，除非强制终止，否则一直到系统关机都会保持运行。守护进程经常<br>以超级用户root权限运行，因为它们需要使用特殊的端口1~1024或者访问某些特殊的资源。   </p><p><strong>一个守护进程的父进程是init进程，因为它真正的父进程在创建出子进程后就先于子进程退出了，所以它是一个由<br>init接管的孤儿进程。守护进程是非交互式程序，没有控制终端，所以任何输出，无论是向标准输出设备stdout还是<br>标准出错设备stderr的输出都需要特殊处理。守护进程的名称通常以d结尾，如sshd、xinetd、crond等。守护进程类<br>似于windows操作系统中的服务程序，它通常以超级用户启动，且没有控制终端。</strong>  </p><h6 id="守护进程的特点"><a href="#守护进程的特点" class="headerlink" title="守护进程的特点"></a>守护进程的特点</h6><p>守护进程最大的特点就是脱离控制终端后台运行。其次，守护进程必须与其运行前的环境隔离开来。这些环境包括未<br>关闭的文件描述符、控制终端、会话和进程组、工作目录以及文件创建掩模等。这些环境通常是守护进程从执行它的<br>父进程（特别是shell）中继承下来的。最后，守护进程的启动方式有其特殊之处，它可以在linux系统启动时从启动<br>脚本&#x2F;etc&#x2F;rc.d中启动，也可以由作业规划进程crond启动，还可以由用户终端（通常是shell）执行。总之，除了这些<br>特殊性以外，守护进程与普通进程基本上没有什么区别。因此，实现守护进程实际上就是把一个普通进程按照上述守<br>护进程的特性改造成守护进程。守护进程有以下几个特点：  </p><blockquote><ul><li>(1) 守护进程都具有超级用户的权限。</li><li>(2) 守护进程的父进程是init进程。</li><li>(3) 守护进程都不用控制终端，其TTY列以”?”表示，TPGID为-1。</li><li>(4) 守护进程都是各自进程组合会话过程的唯一进程。</li></ul></blockquote><h6 id="守护进程的查看"><a href="#守护进程的查看" class="headerlink" title="守护进程的查看"></a>守护进程的查看</h6><p>可以使用命令ps x或者ps axj来查看当前运行着的守护进程。其中，a表示不仅列出当前用户的进程，也列出所有其它<br>用户的进程；x表示不仅列有控制终端的进程，也列出所有无控制终端的进程；j表示列出与作业控制相关的信息。<br>输入：ps axj</p><img src="/2023/02/10/linux%E5%A4%9A%E8%BF%9B%E7%A8%8B%EF%BC%88%E4%BA%8C%EF%BC%89/2.png" class=""><p></p>TTY表示控制终端，可以看到这几个守护进程的控制终端为"?"，意思这些守护进程没有控制终端。UID为0，表示进程的启动者是超级进程。    <h6 id="守护进程的分类"><a href="#守护进程的分类" class="headerlink" title="守护进程的分类"></a>守护进程的分类</h6><p>根据守护进程的启动和管理方式，可以将守护进程分为独立启动守护进程和超级守护进程两类。<br><strong>独立启动（stand_alone）守护进程</strong>：这类守护进程遂系统启动，启动后就常驻内存，所以会一直占用系统资源。<br>其最大的优点是它会一直启动，当外界有要求时响应速度较快，比如httpd等进程。此类守护进程通常保存在系统目录<br>&#x2F;etc&#x2F;rc.d&#x2F;init.d下。<br><strong>超级守护进程</strong>：系统启动时，由一个统一的守护进程xinet来负责管理一些其它进程。当响应请求到来时，需要通<br>过xinet的转接才可以唤醒被xinet管理的进程。这种进程的优点是，最初只有xinet这一守护进程占用着系统资源，其<br>它的内部服务并不一直占有系统资源，只有数据包或其它请求到来时才会被xinet唤醒。并且还可以通过xinet对它所<br>管理的进程设置一些访问权限，相当于多了一层管理机制。<br>可以用银行业务类比这两类守护进程。<br>独立启动守护进程：银行里有一种单服务的窗口，像取钱、存钱窗口，这种窗口边上始终会坐着一个人，如果有人来<br>取钱或者存钱，可以直接到相应的窗口去办理，这个处理单一服务的始终存在的人就是独立启动的守护进程。<br>超级守护进程：银行有一种综合服务的导台，专为处理咨询、换汇款、大额提款存款等业务，这种导台也始终坐着一个<br>人（xinet），这个人可能不提供具体的业务服务，但是当有人需要服务时他会通知具体办理业务的服务人员，然后由<br>具体的服务人员来处理相关业务，这些负责处理具体业务的服务人员就称为超级守护进程。当然，可能有些服务的业<br>务会有具体的规则，如大额提款限制，超过多少万当天不能提取等。具体办理业务的服务人员就会将此规则告知导台<br>的服务咨询人员，当有人来要提取超过限额的款项时，服务咨询人员就会告知无法办理，也不会去通知具体的业务人<br>员，相当于提供了一层管理机制。需要注意的是，超级守护进程的管理员xinet也是一个守护进程，只不过它的任务类<br>似于传声筒。<br>每个守护进程都会监听一个端口(银行串口、导台)，一些常用守护进程的监听端口是固定的，像httpd监听80端口、<br>sshd监听22端口等，具体的端口信息可以通过cat &#x2F;etc&#x2F;services来查看。每个守护进程都会有一个脚本，可以理解<br>成工作配置文件。守护进程的脚本需要放在指定位置，独立启动守护进程的脚本放在&#x2F;etc&#x2F;init.d&#x2F;目录下，其中也包<br>括xinet的shell脚本；超级守护进程按照xinet中脚本的指示，所管理的守护进程位于&#x2F;etc&#x2F;xinetd.config目录下。   </p><h6 id="守护进程的启动方式"><a href="#守护进程的启动方式" class="headerlink" title="守护进程的启动方式"></a>守护进程的启动方式</h6><p>守护进程一般是随着系统启动而自动激活的。它可以通过以下方式启动：</p><blockquote><ul><li>(1) 在系统启动时由启动脚本启动，这些启动脚本通常放置在&#x2F;etc&#x2F;rc.d目录下。</li><li>(2) 利用inetd超级服务器启动，如telnet等。</li><li>(3) 由cron定时启动，在终端用nohup启动的进程也是守护进程</li></ul></blockquote><h6 id="创建守护进程的顺序"><a href="#创建守护进程的顺序" class="headerlink" title="创建守护进程的顺序"></a>创建守护进程的顺序</h6><p>在linux或者unix操作系统中，在系统引导的时候会开启很多服务，这些服务就叫作守护进程。为了增加灵活性，root<br>可以选择系统开启的模式，这些模式叫作运行级别，每一种运行级别以一定的方式配置系统。守护进程是脱离于终端<br>且在后台运行的进程，目的是为了避免进程在执行过程中的信息在任何终端上显示，而且进程也不会被任何终端所产<br>生的终端信息所打断。在创建守护进程之前，先了解一下守护进程编写的基本步骤：  </p><p><strong>（1）创建子进程，父进程退出</strong><br>这是编写守护进程的第一步，由于守护进程是脱离控制终端的，因此完成第一步后就会在shell终端里造成程序已经运<br>行完毕的假象。之后的所有工作都在子进程中完成，而用户在shell终端里则可以执行其它命令，从而在形式上做到与<br>控制终端的脱离<br>在linux中，父进程先于子进程退出会造成子进程成为孤儿进程，而每当系统发现一个孤儿进程时，就会自动由1号进<br>程（init）来收养它，这样原先的子进程就会变成init进程的子进程。  </p><p><strong>（2）在子进程中创建新对话</strong><br>这个步骤是创建守护进程中最重要的一步，虽然它的实现非常简单，但意义却非常重大。在这里使用的是系统函数setsid<br>在具体介绍setsid之前，先要了解两个概念：进程组和会话周期。   </p><blockquote><p><em><strong>进程组：是一个或多个进程的组合。进程组由进程组ID来唯一标识。除了进程号pid之外，进程组id也是一个进<br>程的必备属性高。每个进程组都有一个组长进程，其组长进程的进程号等于进程组ID，且该进程组ID不会因组长进程<br>的退出而受到影响。</strong></em><br><em><strong>会活周期：会话周期是一个或多个进程组的集合。通常，一个会话开始于用户登录，终止于用户退出，在此期间<br>该用户运行的所有进程都属于这个会话周期。</strong></em>  </p></blockquote><p>接下来具体介绍setsid函数。setsid函数用于创建一个新的会话，并担任该会话组的组长。调用setsid有下面3个作用</p><blockquote><ul><li>让进程摆脱原始会话的控制。</li><li>让进程摆脱原进程组的控制。</li><li>让进程摆脱原控制终端的控制。</li></ul></blockquote><p>在创建守护进程时需要调用setsid函数，原因在于创建守护进程的第一步调用了fork函数来创建子进程，再将父进程<br>退出，在调用fork函数时，子进程全盘复制了父进程的会话周期、进程组、控制终端等，虽然父进程退出了，但会话<br>周期、进程组以及控制终端并没有改变！因此还不算真正意义上的独立开来，而setsid函数能够使得进程完全独立出<br>来，从而摆脱其它进程的控制。  </p><p><strong>（3）改变当前目录为根目录</strong><br>这一步也是必要的步骤。使用fork创建的子进程继承了父进程当前的工作目录。由于在进程运行中，当前目录所在的<br>文件系统（如“&#x2F;mnt&#x2F;usb”）是不能卸载的。这对以后的使用会造成诸多麻烦。因此，通常的做法是让“&#x2F;”作为守护进程<br>的当前工作目录，这样就可以避免上述的问题。如果有特殊需求，也可以把当前工作目录换成其它的路径，如&#x2F;tmp。<br>改变工作目录的常见函数是chdir。<br><strong>（4）重设文件权限掩码</strong><br>文件权限掩码是指屏蔽掉文件权限中的对应位。比如，文件权限掩码是050，它就屏蔽了文件组拥有者的可读与可执行<br>权限。由于使用fork函数新建的子进程继承了父进程的文件权限掩码，这就给该子进程使用文件带来了诸多麻烦。因<br>此，把文件权限掩码设置为0可以大大增强该守护进程的灵活性。设置文件权限掩码的函数是umask。在这里，通常的<br>使用方法是umask(0)。<br><strong>（5）关闭文件描述符</strong><br>同文件权限掩码一样，用fork函数新建的子进程会从父进程那里继承一些已经打开的文件。这些被打开的文件可能永<br>远不会被守护进程读写，但它们一样消耗系统资源，而且可能导致所在的文件系统无法卸载。由于守护进程是脱离控<br>制终端的，因此从终端输入的字符不可能到达守护进程，守护进程中用常规方法（如printf）输出的字符也不可能在<br>终端上显示出来。所以，文件描述符0、1和2的3个文件（标准输入输出和错误）已经失去了存在的价值，也应该被关<br>闭。  </p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-built_in">for</span>(int i = <span class="hljs-number">0</span>; i&lt;MAXFILE; i++)<br>    <span class="hljs-built_in">close</span>(i);<br></code></pre></td></tr></table></figure><p>通常使用上述方式关闭文件描述符。</p><p><strong>（6）守护进程退出处理</strong><br>当用户需要外部停止守护进程运行时，常会使用kill命令来停止该守护进程。所以，守护进程中需要实现有关kill发<br>出的signal信号相关的处理，以达到进程的正常退出。  </p><figure class="highlight qml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs qml"><span class="hljs-keyword">signal</span><span class="hljs-string"></span>(SIGTERM , sigterm_handler);<br><span class="hljs-keyword">void</span> sigterm_handler(<span class="hljs-built_in">int</span> arg)<br>&#123;<br>    _running = <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>如此，一个简单的守护进程就被建立起来了。<br>示例程序：创建守护进程每隔十毫秒往log文件中写入一条数据  </p><img src="/2023/02/10/linux%E5%A4%9A%E8%BF%9B%E7%A8%8B%EF%BC%88%E4%BA%8C%EF%BC%89/3.png" class=""><img src="/2023/02/10/linux%E5%A4%9A%E8%BF%9B%E7%A8%8B%EF%BC%88%E4%BA%8C%EF%BC%89/4.png" class=""><img src="/2023/02/10/linux%E5%A4%9A%E8%BF%9B%E7%A8%8B%EF%BC%88%E4%BA%8C%EF%BC%89/5.png" class=""><img src="/2023/02/10/linux%E5%A4%9A%E8%BF%9B%E7%A8%8B%EF%BC%88%E4%BA%8C%EF%BC%89/6.png" class=""><p></p>可以看到log文件的大小不停在增长，kill掉进程后，文件增长停止，shell中的交互并不会影响到守护进程，除非强制终止守护进程。]]></content>
    
    
    <categories>
      
      <category>linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>进程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>linux进程(一)</title>
    <link href="/2023/02/02/linux%E5%A4%9A%E8%BF%9B%E7%A8%8B-%E4%B8%80/"/>
    <url>/2023/02/02/linux%E5%A4%9A%E8%BF%9B%E7%A8%8B-%E4%B8%80/</url>
    
    <content type="html"><![CDATA[<h2 id="进程的概念"><a href="#进程的概念" class="headerlink" title="进程的概念"></a>进程的概念</h2><p>进程是操作系统结构的基础。进程是一个具有独立功能的程序对某个数据集合在处理机上的执行过程，进程也是作为<br>资源分配的一个基本单位。linux作为一个多用户、多任务的操作系统，必定支持多进程。多进程也是现代操作系统的<br>基本特征之一，操作系统在裸机硬件层面之上提供了更为简单、可靠、安全、高效的功能，它的首要功能就是管理和<br>协调各种计算机系统资源，包括物理资源和虚拟的资源。为了提高计算机系统中各种资源的利用效率，现代操作系统<br>广泛采用了多进程技术，以使多种硬件资源能够并行的工作，程序的并发执行以及多任务共享资源成为现代操作系统<br>的重要特点。为了更好的理解进程的概念，需要明确程序与进程间的差异性：    </p><blockquote><ul><li>(1) 进程和程序是相辅相成的。程序是进程的组成部分之一，一个进程的运行目标是执行它所对应的程序，如果<br>没有程序，进程就失去了它存在的意义。一个程序也可以由多个进程组成。</li><li>(2) 进程是一个动态的概念，而程序则是一个静态概念。程序是指令的有序集合，其本身没有任何运行的含义，<br>是一个静态的概念。而进程是程序在处理机器上的一次执行过程，它是一个动态的概念，动态的产生、执行<br>然后消亡，因此进程的存在也是暂时的。</li><li>(3) 进程具有并行性特征，而程序则没有。进程具有并行特征的两个方面：独立性和异步性。独立性是指，进程<br>是一个相对完整的资源分配单位。异步性是指，每个进程按照各自独立的、不可预知的速度向前推进。显然<br>程序并不反映执行过程，所以不具有并行性。</li></ul></blockquote><h2 id="进程的描述"><a href="#进程的描述" class="headerlink" title="进程的描述"></a>进程的描述</h2><p>从构成要素描述进程的话可以分为三个部分：进程控制块（Process Control Block）PCB；相关的程序段；操作的数<br>据集合。其中进程控制块主要包括进程的一些描述信息、资源信息以及控制信息等。系统为每个进程设置一个PCB,它<br>是标识和描述进程存在及相关特性的数据块，是进程存在的唯一标识，也是进程动态特征的集中反映。当创建一个进<br>程时，系统首先创建其PCB，然后根据PCB中的信息对进程实施有效的管理和控制。当一个进程完成其功能之后，系统<br>则释放PCB，进程也随之消亡。进程控制块的具体内容随操作系统的不同而有所区别，但主要都应包括以下的信息：  </p><blockquote><ul><li>(1)进程标识： 每个进程都有系统唯一的进程名称或标识号。在识别一个进程时，进程名或标识号就代表该进程。</li><li>(2)状态信息： 指明进程当前所处的状态，作为进程调度、分配处理机的依据。进程在活动期间有三种基本的状<br>态，可分为就绪状态、执行状态和等待状态。一个进程在任意时刻只能具有三种状态中的一种。执行状态表<br>示该进程当前占有处理机，正在处理机上调度执行；就绪状态表示该进程已经得到了除处理机之外的全部资<br>源，准备占有处理机；等待状态则表示进程因某种原因而暂时不能占有处理机。在具体的系统中，为了最大<br>可能的提高资源的利用率，可能会引进某些状态或者进一步细分某些状态。</li><li>(3)进程的优先级： 进程优先级是选取进程占有处理机的重要依据，一般根据进程的轻重缓急程度为进程指定一<br>个优先级，包括静态或者动态的优先级。</li><li>(4)CPU现场信息： 当进程状态变化时（如一个进程放弃使用处理机），它需要将当时的CPU现场保护到内存中，<br>以便再次占用处理机时恢复到当时运行的状态。这些信息包括各种通用寄存器、程序计数器、程序状态字等。</li><li>(5)资源清单： 每个进程在运行时，除了需要内存外，还需要其它资源，如I&#x2F;O设备、外存、数据区等。</li><li>(6)队列指针： 用于将处于同一状态或者具有家族关系的进程链接成一个队列，在该单元中存放下一进程PCB首<br>地址。</li><li>(7)其它： 如计时信息、记账信息、通信信息等。</li></ul></blockquote><p>linux中的每个进程都由一个task_struct数据结构来表示。task_struct其实就是通常意义上的进程控制块pcb，或者<br>称为进程描述符，系统正是通过task_struct结构来对进程进行有效管理和控制的。当系统创建一个进程时，linux为<br>新的进程分配一个task_struct结构，进程结束时，又收回其task_struct结构，进程也随之消亡。分配给进程的结构<br>task_struct可以被内核中的许多模块（如调度程序、资源分配程序、中断处理程序等）访问，并常驻于内存.在linux<br>4.14内核中，linux为每个新创建的进程动态的分配一个task_struct结构，系统所能允许的最大进程数是由机器所拥<br>有的物理内存的大小决定的，这是对以前版本的改进。linux支持两种进程：普通进程和实时进程。实时进程具有一定<br>程度上的紧迫性，应该有一个短的响应时间，更重要的是，这个响应时间应该有很小的变化；而普通进程则没有这种限<br>制。因此，调度程序需要区别对待这两类进程。<br>task_struct结构包含进程的全部信息，数据结构比较庞大，按其功能主要分为几个大的部分：进程标识符信息；进程<br>调度信息；进程间通信信息；时间和定时器信息；进程链接信息；文件系统信息；虚拟内存信息；处理器特定信息以<br>及其它信息。    </p><blockquote><p>(1)进程标识符信息</p><blockquote><p> 进程标识符信息包括进程标识符、用户标识符、阻止标识符等一些信息。每个进程都有一个唯一的进程标识符PID<br>，内核通过这个标识符来识别不同的进程，同时，进程标识符也是内核提供给用户程序的接口。PID是32位的无符<br>号整数，存放在进程描述符的PID域中，它被顺序编号，新创建进程的PID通常是前一个进程的PID+1，为了与16<br>位硬件平台的传统UNIX系统保持兼容，linux允许的最大PID号是32767.当内核在系统中创建第32768个进程时，就<br>必须重新开始使用闲置的PID号。此外，每个进程都属于某个用户和某个用户组。进程描述符中定义了多种类别的<br>用户标识符和组标识符，比如用户标识符uid、有效用户标识符euid、组标识符gid、有效组标识符egid等。这些<br>都是简单的数字，主要用于系统的安全控制。   </p></blockquote><p>(2)进程调度信息</p><blockquote><p>调度程序利用这些信息来决定系统中哪个进程最迫切需要运行，并采用适当的策略来保证系统运转的公平性和高<br>效性。这些信息主要包括调度标志、调度的策略、进程的类别、进程的优先级、进程状态。其中可能的进程状态<br>有：可运行状态、可中断的等待状态、不可中断的等待状态、暂停状态和僵死状态。</p></blockquote><p>(3)进程间通信信息</p><blockquote><p>在多任务编程环境中，进程之间必然会发生多种多样的合作、协调等。因此进程间就必须进行通信，来交换信息<br>和传递数据。linux支持多种不同形式的进程间通信机制，如信号、管道，也支持System V进程间通信机制，如信<br>号量消息队列和共享内存等。进程描述符中主要有这些域与进程通信有关：sig，信号处理函数，包括自定义的和<br>系统默认的处理函数；blocked，进程所能接收信号的位掩码；sigmask_lock，信号掩码的自旋锁；semundo，进<br>程信号量的取消操作队列，进程每操作一次信号量，都生成一个对此次操作的取消操作，这些属于同一进程的取<br>消操作组成一个链表，当进程异常终止时，内核就会执行取消操作；semsleeping，与信号量相关的等待队列，每<br>一信号量集合对应一个等待队列。</p></blockquote><p>(4)进程链接信息</p><blockquote><p>linux系统中所有进程都是相互联系的。除了初始化进程init外，其它所有进程都有一个父进程。可以通过fork<br>或clone系统调用来创建子进程，除了进程标识符pid等必要的信息外，子进程的task_struct结构中的绝大部分信<br>息都是从父进程中复制过来的。每个进程对应的task_struct结构中都包含有指向其父进程和兄弟进程（具有相同<br>父进程）以及子进程的指针。有了这些指针，进程之间的通信、协作就更加方便了。进程的task_struct结构中主<br>要有下面这些域记录了进程间的各种关系。next_task、prev_task是用于链入进程双向链表的前后指针，系统的<br>所有进程组成一个双向循环链表。p_opptr、p_pptr、p_cptr、p_ysptr、p_osptr分别表示指向祖先进程、父进程<br>、子进程、兄弟进程的指针。pidhash_next、pidhash_prev是用于链入进程哈希表的前后指针。</p></blockquote><p>(5)时间和定时器信息</p><blockquote><p>内核需要记录进程的创建时间以及在其生命周期中消耗的CPU时间。进程耗费的CPU时间由两部分组成：一是在用<br>户态（用户模式）下耗费的时间；二是在内核态（内核模式）下耗费的时间。每个时钟滴答，也就是每个时钟中<br>断，内核都要更新当前进程耗费的时间。linux支持与进程相关的多种间隔定时器，包括实时定时器、虚拟定时器<br>和概况定时器。进程可以通过系统调用来设定定时器，以便在定时器到期后向它发送信号。这些定时器可以是一<br>次性的或者周期性的。</p></blockquote><p>(6)文件系统信息</p><blockquote><p>进程经常会访问文件系统资源，打开或者关闭文件，linux内核要对进程使用文件的情况进行记录。task_struct<br>结构中有两个数据结构用于描述进程与文件相关的信息。其中。fs域是指向fs_struct结构的指针，fs_struct结<br>构中描述了两个VFS索引节点，这两个索引节点叫作root和pwd，分别指向进程的可执行映像所对应的主目录和当<br>前工作目录。files域用来记录进程打开文件的文件描述符。</p></blockquote><p>(7)虚拟内存信息</p><blockquote><p>linux采用按需分页的策略来解决进程的内存需求，当物理内存不足时，linux内存管理系统需要把内存中的部分页<br>面交换到外存。每个进程都有自己的虚拟地址空间（内核线程除外），用mm_struct来描述，其中包括一个指向<br>若干个虚拟块的虚拟队列。另外，linux内核还引入了另一个域active_mm，它指向活动地址空间，但这一空间并<br>不为其进程所拥有，通常为内核线程所使用。内核线程与用户进程相比不需要mm_struct结构：当用户进程切换到<br>内核线程时，内核线程可以直接借用进程的页表，无须重新加载独立的页表。内核线程用active_mm指针指向所借<br>用进程的mm_struct结构。</p></blockquote><p>(8)处理器特定信息</p><blockquote><p>进程可以看作是系统当前执行状态的综合。进程运行时，它将使用处理器的寄存器以及堆栈等。进程被挂起时，<br>进程的上下文，即所有与CPU相关的处理机状态必须保存在它的task_struct结构中。当进程被调度重新运行时，<br>再从其中恢复这些运行环境，重新设定上下文，也就是恢复这些寄存器和堆栈的值。    </p></blockquote></blockquote><h4 id="进程的标识符"><a href="#进程的标识符" class="headerlink" title="进程的标识符"></a>进程的标识符</h4><p>进程标识符也称进程识别码（Process Identification）即PID，PID是进程运行时系统随机分配的，在进程运行时，<br>PID是不会改变的，进程终止后，PID就会被系统回收，以后可能会被分配给新运行的进程。进程ID在系统中其实就是<br>一个无符号整型数值，类型是pid_t，该类型定义在&#x2F;usr&#x2F;include&#x2F;sys&#x2F;types.h中，定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> __pid_t_defined</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">__pid_t</span> <span class="hljs-type">pid_t</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __pid_t_defined</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><p>可以看pid_t类型其实是__pid_t类型。而__pid_t在&#x2F;usr&#x2F;include&#x2F;bits&#x2F;types.h中被定义为__PID_T_TYPE类型。<br>在文件&#x2F;usr&#x2F;include&#x2F;bits&#x2F;typesizes.h中可以看到这样的定义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> __PID_T_TYPE  __S32_TYPE</span><br></code></pre></td></tr></table></figure><p>可以看到__PID_T_TYPE被定义为__S32_TYPE类型。在文件&#x2F;usr&#x2F;include&#x2F;bits&#x2F;types.h中，可以找到这样的定义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> __S32_TYPE  int</span><br></code></pre></td></tr></table></figure><p>可以看到实际上pid_t就是一个int型。在终端下可以使用命令ps -e来查看所有的进程id，譬如:  </p><img src="/2023/02/02/linux%E5%A4%9A%E8%BF%9B%E7%A8%8B-%E4%B8%80/1.png" class=""><p></p>-e表示显示所有进程，也可以使用-A，含义一样。上图第一列为进程ID，即PID，最后一列是进程的名字,其和所对应的程序名相同，因此会出现重名的进程，虽然会有重名进程的出现，但是其PID是不同的，因此PID才是一个进程的标识符。获取当前进程的pid的函数为getpid，该函数使用示例如下：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//使用示例：  </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">pid_t</span> pid = <span class="hljs-built_in">getpid</span>();<br>    std::cout&lt;&lt;<span class="hljs-string">&quot;pid = &quot;</span>&lt;&lt;pid&lt;&lt;std::endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;  <br>   <br></code></pre></td></tr></table></figure><h4 id="PID文件"><a href="#PID文件" class="headerlink" title="PID文件"></a>PID文件</h4><p>在系统的&#x2F;var&#x2F;run目录下，会看到很多后缀为*.pid的文件。往往新安装的程序在运行后会在&#x2F;var&#x2F;run目录下产生自<br>己的pid文件。pid文件为文本文件，内容只有一行，记录该进程的id。这些pid文件的作用是防止进程启动多个副本。<br>只有获得相应pid文件写入权限的进程才能正常启动，并把自身的pid写入该文件中。pid文件位于固定路径&#x2F;var&#x2F;run<br>，并且文件名也是固定的，即进程名.pid。<br>通常有两种方法配合pid文件来实现进程的重复启动。一种是文件加锁法，另一种是pid读写法。文件加锁法的基本思<br>路是进程运行后会给pid文件加一个文件锁，只有获得该锁的进程才有写入权限（F_WRLCK），以后其它试图获得该锁<br>的进程会自动退出，给文件加锁的函数是fcntl()函数，如果成功锁定，进程则继续往下执行，如果锁定不成功，说<br>明已经有同样的进程在运行了，该进程就退出。pid读写法则是先启动的进程往pid文件中写入自己的进程id号，然后<br>其它进程判断该pid文件中是否已有数据了。<br>使用pid文件判断进程是否运行示例：</p><img src="/2023/02/02/linux%E5%A4%9A%E8%BF%9B%E7%A8%8B-%E4%B8%80/2.png" class=""><img src="/2023/02/02/linux%E5%A4%9A%E8%BF%9B%E7%A8%8B-%E4%B8%80/3.png" class=""><img src="/2023/02/02/linux%E5%A4%9A%E8%BF%9B%E7%A8%8B-%E4%B8%80/4.png" class=""><p></p>check_pid是一个自定义函数，用来检测pid文件是否存在，然后根据pid文件内容判断进程是否运行。整个程序在刚刚启动的时候会创建一个test_pid.pid文件，并把本进程的进程号写入该文件中,程序结束的时候，也就是进程退出时会删除pid文件。check_pid中，使用stat函数判断文件是否存在，并用fopen函数又进一步做了保险判断，如果存在，就读取该文件中的进程号，然后通过kill函数检测该进程是否在运行。kill函数的第二个参数为要发送给内核的信号代码，如果为0，则表示没有送出任何信号，但是系统会执行错误检查。通常会利用sig值为0来检验某个进程是否仍在执行。     <h2 id="进程的创建"><a href="#进程的创建" class="headerlink" title="进程的创建"></a>进程的创建</h2><h3 id="使用fork创建"><a href="#使用fork创建" class="headerlink" title="使用fork创建"></a>使用fork创建</h3><p>linux可以通过执行系统调用函数fork来创建新的进程，由fork创建的新进程称为子进程，该函数被调用一次，但返回<br>两次。两次返回的区别是子进程的返回值是0，而父进程的返回值是子进程的PID，子进程和父进程继续执行fork之后<br>的指令。父进程和子进程几乎是等同的——它们具有相同的变量值（但变量内存并不共享），打开的文件也都相同，还<br>有其它一些相同属性。如果父进程改变了变量的值，子进程将不会看到这个变化。实际上，子进程是父进程的一个复<br>制，但它们并不共享内存。而且，linux并不完全复制内存页，而是采用了写时复制（copy on write）的技术，这些<br>内存区域由父、子进程共享，而且内核将它们的许可权限改为只读，当有进程试图改修这些区域时，内核就为相关部<br>分做一下复制。<br>系统调用函数fork的声明如下：  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">pid_t</span> <span class="hljs-title">fork</span><span class="hljs-params">()</span></span>;<br></code></pre></td></tr></table></figure><p>该函数将创建一个子进程。如果成功，在父进程的程序中将返回子进程的进程id，即pid值；在子进程中函数返回0；<br>如果失败，则在父进程程序中返回-1，并且可以通过errno得到错误码。一个进程成功调用fork函数后，系统先给新<br>的进程分配资源，例如存储数据和代码的空间。然后把原来的进程的所有值都复制到新的进程中，只有少数值与原来<br>的进程的值不同，相当于克隆了一个自己。代码示例如下：   </p><img src="/2023/02/02/linux%E5%A4%9A%E8%BF%9B%E7%A8%8B-%E4%B8%80/5.png" class=""><p></p>通过示例代码可以看到，父进程和子进程的pid是不同的，说明是两个不同的进程。在语句cpid=fork()之前，只有一个进程（即父进程）在执行这段代码，但在这条语句之后，就变成两个进程在执行了，这两个进程近乎完全相同，将要执行的下一条语句都是if(cpid < 0)判断，父进程和子进程都会执行该语句，并根据结果各自前进。父子进程中的cpid不同这和fork函数的特性有关。fork调用的神奇之处就是它仅被调用一次，但却能够返回两次。父进程fork返回的是子进程的pid，可以看到父进程中打印出的cpid是子进程的进程id，而子进程中的该值为0。另外，count因为在父子进程中各执行了count++，所以会输出两次count = 1。子进程创建成功后，系统中就会出现两个基本相同的进程这两个进程没有固定的先后执行顺序，哪个进程先执行要看操作系统的进程调度策略。  <h3 id="使用exec创建"><a href="#使用exec创建" class="headerlink" title="使用exec创建"></a>使用exec创建</h3><p>exec使用被执行的程序（新的目标程序）替换调用它的程序（调用exec的程序）。相对于fork函数会创建一个新的进<br>程，产生一个新的pid，exec会使用目标程序替换当前的进程，并且pid不变。exec()函数族总共6个，声明如下：  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">execl</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *path , <span class="hljs-type">const</span> <span class="hljs-type">char</span> *arg , ...)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">execlp</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *file , <span class="hljs-type">const</span> <span class="hljs-type">char</span> *arg , ...)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">execle</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *path , <span class="hljs-type">const</span> <span class="hljs-type">char</span> *arg , ... , <span class="hljs-type">char</span> *<span class="hljs-type">const</span> envp[])</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">execv</span><span class="hljs-params">(cosnt <span class="hljs-type">char</span> *path , <span class="hljs-type">char</span> *<span class="hljs-type">const</span> argv[])</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">execvp</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *file , <span class="hljs-type">char</span> *<span class="hljs-type">const</span> argv[])</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">execvpe</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *file , <span class="hljs-type">char</span> *<span class="hljs-type">const</span> argv[] , <span class="hljs-type">char</span> *<span class="hljs-type">const</span> anvp[])</span></span>;<br></code></pre></td></tr></table></figure><h4 id="1-execl函数"><a href="#1-execl函数" class="headerlink" title="1.execl函数"></a>1.execl函数</h4><p>函数execl声明如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">execl</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *path , <span class="hljs-type">const</span> <span class="hljs-type">char</span> *arg , ...)</span></span>;<br></code></pre></td></tr></table></figure><p>其中，参数path指向要执行的文件路径（可以是命令的全路径、执行程序的全路径或脚本文件的全路径）；后面的参<br>数arg以及之后的省略号代表执行该程序时传递的参数列表，并且第一个被认为是argv[0]（即path后面的参数const<br>char *arg），第二个被认为是argv[1 ]….相当于main函数中的argv，main函数中的argv[0]是程序的名称，程序<br>所需要的参数是从argv[1]才开始获取的，execl的argv[0]也是按照此习惯设计，即argv[1]才是传给execl要启动的<br>程序的第一个参数，argv[0]可以只写个程序名（对于大多数命令程序来说没什么作用，随便写一个字符串也可以，<br>但不要写NULL，写NULL就认为参数列表就此结束了，而对于自定义程序，则要视情况而定），最后一个参数必须使用<br>空指针NULL结束。函数成功时不返回值，失败则返回-1，失败原因存于errno中，可通过perror()打印。另外需要注<br>意的是，对于系统命令程序，如pwd命令，argv[0]是必须有的，但其值可以是一个无意义的字符串。<br>示例：使用execl执行不带参数的命令程序pwd   </p><img src="/2023/02/02/linux%E5%A4%9A%E8%BF%9B%E7%A8%8B-%E4%B8%80/6.png" class=""><p></p>程序打印当前路径，和单独执行pwd命令是一样的，虽然pwd命令不带参数，但使用execl执行的时候，依然需要argv[0]这个选项，不可为NULL。  <hr><p>使用execl执行可带参数的命令，ls:  </p><img src="/2023/02/02/linux%E5%A4%9A%E8%BF%9B%E7%A8%8B-%E4%B8%80/7.png" class=""><img src="/2023/02/02/linux%E5%A4%9A%E8%BF%9B%E7%A8%8B-%E4%B8%80/8.png" class=""><p></p>通过上面程序的运行结果比较，可以看到execl的第二个参数,即argv[0]没什么用处，即使随便输入一个字符串，程序效果也是一样的。说明对于execl函数，只要提供了程序的全路径和argv[1]开始的参数信息就可以了。   调用自定义程序示例：  <hr><p>实现自定义程序  </p><img src="/2023/02/02/linux%E5%A4%9A%E8%BF%9B%E7%A8%8B-%E4%B8%80/9.png" class=""><p></p><hr><p>使用execl调用自定义程序  </p><img src="/2023/02/02/linux%E5%A4%9A%E8%BF%9B%E7%A8%8B-%E4%B8%80/10.png" class=""><img src="/2023/02/02/linux%E5%A4%9A%E8%BF%9B%E7%A8%8B-%E4%B8%80/11.png" class=""><p></p>上面示例的自定义程序调用时传递的参数是不同的，可以对比关于argv传递的参数，理解argv参数传递的方式。<h4 id="2-execlp函数"><a href="#2-execlp函数" class="headerlink" title="2.execlp函数"></a>2.execlp函数</h4><p>execlp函数声明如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">execlp</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *file , <span class="hljs-type">const</span> <span class="hljs-type">char</span> *arg , ....)</span></span>;<br></code></pre></td></tr></table></figure><p>其中参数file指向要执行的程序，但不需要写出完整路径，函数会从环境变量PATH所指的目录中查找符合参数file的<br>文件名，找到后便执行该文件；后面的参数同execl函数相同，最后一个参数同样需要空指针NULL作为结束。函数成功<br>执行不会返回，执行失败返回-1，错误码存于errno中。<br>示例程序：  </p><img src="/2023/02/02/linux%E5%A4%9A%E8%BF%9B%E7%A8%8B-%E4%B8%80/12.png" class=""><p></p>上图可以看到execlp第一个参数直接写pwd这个命令即可，不需要写全路径，因为环境变量PATH中已经包含了pwd命令所在的路径了；第二个参数是空字符串，也可以是其它任意的字符串，但必须要有，不可为NULL，否则程序会报错。这个规则是对创建系统命令程序的情况，自定义程序无此规则要求。<hr><p>使用execlp调用自定义程序的话，需要将自定义程序的文件路径加入到环境变量PATH中，也可以将自定义程序移动到<br>PATH路径现在已经有的路径下。将上文的test_exemine复制一份到&#x2F;usr&#x2F;bin下，然后用execlp调用此程序示例如下：   </p><img src="/2023/02/02/linux%E5%A4%9A%E8%BF%9B%E7%A8%8B-%E4%B8%80/13.png" class=""><img src="/2023/02/02/linux%E5%A4%9A%E8%BF%9B%E7%A8%8B-%E4%B8%80/14.png" class=""><p></p>可以看到execlp调用自定义程序执行成功了，且参数为NULL。  实际上，只有函数execvpe才是真正意义上的系统调用，其它的都是在此基础上封装的函数。exec函数族的作用是根据指定的文件名找到可执行文件，并用它来取代调用进程的内容（即在调用进程内部执行一个可执行文件，此文件既可以是二进制文件，也可以是任何linux下可执行的脚本文件）。exec函数族的这6个函数都是以exec开头的，前面三个函数后面的字母都是l，表示list（列举参数），后面三个函数接着字母v，表示vector（参数向量表）。它们的区别在于，execv开头的函数是以“char \*argv[]”（vector)形式传递命令行参数的，而execl开头的函数采用罗列 （list）的方式，把参数一个一个列出来，然后以一个NULL表示结束。这里的NULL的作用和argv数组里的NULL作用是一样的。  <h3 id="使用system创建进程"><a href="#使用system创建进程" class="headerlink" title="使用system创建进程"></a>使用system创建进程</h3><p>system函数通过使用shell程序来执行所传入的命令（效率低），相当于先fork(),再execve()。该函数的特定是原进<br>程和子进程各自运行，且原进程需要等子进程运行完成后再继续。system()会调用fork()产生子进程，然后由子进程<br>来调用&#x2F;bin&#x2F;sh -c执行system函数的参数command字符串所代表的命令，此命令执行完后随即返回原调用的进程。<br>&#x2F;bin&#x2F;sh一般是一个软链接，指向某个具体的shell，比如bash，-c选项是告诉shell从字符串command中读取命令。在<br>该command执行期间，SIGCHLD信号会被暂时搁置，SIGINT和SIGQUIT信号则会被忽略。system函数声明如下：   </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">system</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *command)</span></span>;<br></code></pre></td></tr></table></figure><p>其中参数command是要执行的命令，如果fork失败，则返回-1，如果command顺利执行完毕，则返回command通过exit<br>或return返回的值。关于system()函数的返回值，需要了解其执行的过程，实际上，system()函数执行了3步操作：</p><blockquote><ul><li>(1) fork一个子进程。</li><li>(2) 在子进程中调用exec函数去执行command。</li><li>(3) 在父进程中调用wait等待子进程结束。</li></ul></blockquote><p>如果fork失败，system()函数返回-1。如果exec执行成功，即command顺利执行完毕，则返回command通过return或<br>exit返回的值（注意，command顺利执行不代表执行成功，比如“rm xxx.txt”，无论文件是否存在，该command都顺利<br>执行了）。如果exec执行失败，即command没有顺利执行，比如被信号中断或者command命令根本不存在，system()函<br>数返回127。如果command为NULL，则system()函数返回非0值，一般为1。<br>实现： </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">system</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *command)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">pit_t</span> pid;<br>    <span class="hljs-type">int</span> status;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-literal">NULL</span> == command)<br>    &#123;<br>        <span class="hljs-comment">//如果命令为空，返回非0值，一般为1</span><br>        <span class="hljs-keyword">return</span> (<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">if</span>((pid = fork()) &lt; <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-comment">//fork子进程创建失败，返回-1</span><br>        status = <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(pid == <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-comment">//子进程使用execl函数嗲用shell，然后通过shell执行目标程序命令command</span><br>        <span class="hljs-built_in">execl</span>(<span class="hljs-string">&quot;/bin/sh&quot;</span>,<span class="hljs-string">&quot;sh&quot;</span>,<span class="hljs-string">&quot;-c&quot;</span>,command,<span class="hljs-literal">NULL</span>);<br>        <span class="hljs-comment">//execl执行成功后子进程就被目标程序替代，此时子进程就不再存在</span><br>        <span class="hljs-comment">//execl执行失败时才会返回到现在的子进程，才有127返回码</span><br>        _exit(<span class="hljs-number">127</span>);<br>    &#125;<br>    <span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-comment">//父进程等待子进程结束，并获取子进程结束状态</span><br>        <span class="hljs-keyword">while</span>(<span class="hljs-built_in">waitpid</span>(pid,&amp;status,<span class="hljs-number">0</span>) &lt; <span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(errno != EINTR)<br>            &#123;<br>                <span class="hljs-comment">//waitpid被信号中断，则返回-1</span><br>                status = <span class="hljs-number">-1</span>;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//返回子进程状态</span><br>    <span class="hljs-keyword">return</span> status;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>进程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++下的文件IO</title>
    <link href="/2023/01/31/C-%E4%B8%8B%E7%9A%84%E6%96%87%E4%BB%B6IO/"/>
    <url>/2023/01/31/C-%E4%B8%8B%E7%9A%84%E6%96%87%E4%BB%B6IO/</url>
    
    <content type="html"><![CDATA[<h2 id="流的概念"><a href="#流的概念" class="headerlink" title="流的概念"></a>流的概念</h2><p>在C++语言中，数据的输入和输出（简称为I&#x2F;O）包括：对标准输入设备（如键盘）和标准输出设备（如显示器）；对<br>在外存磁盘上的文件；和对内存中指定的字符串存储空间（该存储空间亦可以存储其它任何信息）进行输入输出这3方<br>面。对标准输入设备和标准输出设备的输入输出简称为标准I&#x2F;O；对在外存磁盘上文件的输入输出简称为文件I&#x2F;O；对<br>内存中指定的字符串存储空间的输入输出简称为串I&#x2F;O。“流”就是”流动”，是物质从一处向另一处流动的过程。C++<br>流是指信息从外部输入设备（如键盘和磁盘）向计算机内部（即内存）输入和从内存向外部设备（如显示器和键盘）<br>输出的过程。这种输入输出过程被形象的比喻为”流”。为了实现信息的内外流动，C++系统定义了I&#x2F;O类库，其中的每<br>一个类都称作相应的流或流类，用以完成某一方面的功能。一个流类定义的对象也时常被称为流。例如根据文件流类<br>fstream定义的一个对象fio可称作为fio流或fio文件流，用它可以同磁盘上一个文件相联系，实现对该文件的输入和<br>输出，fio就等同于与之相联系的文件。<br>因为C++兼容C，所以C中的输入输出函数依然可以在C++中使用，但是直接把C的那套输入输出搬到C++中无法满足C++的<br>需求，C中的输入输出有类型要求，只支持基本类型，因此不满足C++的需求，所以C++设计了易于使用的并且多种输入<br>输出流接口统一的IO类库，且支持多种格式化操作，还可以自定义格式化操作。总的来说，C++中有3种输入输出流：   </p><blockquote><ul><li>标准I&#x2F;O流：内存与标准输入输出设备之间信息的传递。</li><li>文件I&#x2F;O流：内存与外部文件之间信息的传递。</li><li>字符串I&#x2F;O流：内存变量与表示字符串流的字符数组之间信息的传递。</li></ul></blockquote><p>C++引入IO流，将这3种输入输出流接口统一起来，使用符号”&gt;&gt;”读取数据的时候，不用去管是从何处读取数据，使用<br>符号”&lt;&lt;”写数据的时候，也不需要考虑输出到哪里去。   </p><h2 id="流的类库"><a href="#流的类库" class="headerlink" title="流的类库"></a>流的类库</h2><p>C++语言系统为实现数据的输入和输出定义了一个庞大的类库，其中ios为根基类，其余都是它的直接或间接派生类，<br>它直接派生4个类：输入流类istream；输出流类ostream；文件流基类fstreambase；和字符串流基类strstreambase.<br>C++系统中的I&#x2F;O类库的所有类被包含在iostream、fstream和strstream 3个系统头文件中。各个类的继承关系如下：      </p><img src="/2023/01/31/C-%E4%B8%8B%E7%9A%84%E6%96%87%E4%BB%B6IO/1.png" class=""><p></p><p>头文件<fstream>提供了三个文件流类：ifstream、ofstream和fstream。这三个类的描述如下：    </p><blockquote><ul><li>ifstream : 该类表示输入文件流，用于从文件流读取信息</li><li>ofstream : 该类表示输出文件流，用于创建文件并向文件写入信息</li><li>fstream : 该类通常表示文件流，且同时具有ifstream和ofstream两种功能，意味着它可以创建文件、向文件<br>        写入信息、从文件读取信息</li></ul></blockquote><p>使用C++进行文件处理时，必须包含头文件<fstream>。此外，C++新标准中，头文件都把.h去掉了，所以之前的写法<br>如 #include&lt;fstream.h&gt;现在要改为：  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;fstream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br></code></pre></td></tr></table></figure><p>同时需要把标准命名空间加上。需要注意的是，这两个写法的头文件并不是完全等价的。在旧头文件里的fstream.h，<br>如果使用ifstream fio的默认参数声明一个输入文件流，当这个要读的fio文件不存在时，会自动创建一个空文件，<br>从而给判断文件是否存在会造成麻烦。如果使用新标准fstream，就不会创建空文件，从而可以使用while(!fio)来判<br>断文件是否存在。类似的头文件iostream.h与iostream也是不同的。iostream.h在旧的标准C++中使用，新标准中用<br>头文件iostream，还需要引用命名空间std。iostream.h慢慢不再使用了，如微软VC6可以使用iostream.h，VS2008就<br>已经不能使用iostream.h了。    </p><h3 id="打开文件"><a href="#打开文件" class="headerlink" title="打开文件"></a>打开文件</h3><p>ifstream、ofstream和fstream都可以用来打开文件，如果只是需要对文件进行读操作，就使用ifstream对象，如果<br>需要对文件进行写入操作，就用ofstream或者fstream对象。被打开的文件在程序中由一个流对象（stream object）<br>来表示（这些类的实例对象），对这个流对象所做的任何输入输出操作实际上就是对该文件的操作。要通过一个流<br>对象打开一个文件，可以使用它的成员函数open(),open()函数是fstream、ifstream和ofstream对象的一个成员函数<br>该函数声明如下：   </p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">open</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *filename , ios::openmode mode)</span></span>;<br></code></pre></td></tr></table></figure><p>其中，第一个参数指定要打开的文件名称和位置，第二个参数定义文件打开的模式，模式有如下选项：  </p><blockquote><ul><li>ios::app : 追加模式。所有写入都追加到文件末尾</li><li>ios::ate : 文件打开后定位到文件末尾</li><li>ios::in : 打开文件用于读取</li><li>ios::out : 打开文件用于写入</li><li>ios::trunc: 如果该文件已经存在，其内容将在打开文件之前被截断，即把文件长度设为0</li><li>ios::binary: 以二进制方式打开文件</li></ul></blockquote><p>以上模式可以组合使用。</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-comment">//以写入模式打开文件，并希望截断文件，防止文件已经存在</span><br>ofstream <span class="hljs-attr">ofile</span><span class="hljs-punctuation">;</span><br>ofile.open(<span class="hljs-string">&quot;file.dat&quot;</span> , ios::out | ios::trunc)<span class="hljs-punctuation">;</span><br><br><span class="hljs-comment">//以读写模式打开</span><br>fstream <span class="hljs-attr">iofile</span><span class="hljs-punctuation">;</span><br>iofile.open(<span class="hljs-string">&quot;file.dat&quot;</span> , ios::in | ios::out)<span class="hljs-punctuation">;</span><br><br><span class="hljs-comment">//以二进制方式打开文件，并追加写入数据</span><br>ofstream <span class="hljs-attr">ofile</span><span class="hljs-punctuation">;</span><br>ofile.open(<span class="hljs-string">&quot;file.bin&quot;</span> , ios::out | ios::app | ios::binary)<span class="hljs-punctuation">;</span><br><br></code></pre></td></tr></table></figure><p>ifstream、ofstream和fstream类的成员函数open都包含一个默认打开文件的方式，这三个类的默认方式各不相同：</p><blockquote><ul><li>ofstream : ios::out | ios::trunc</li><li>ifstream : ios::in</li><li>fstream  : ios::in | ios::out</li></ul></blockquote><p>只有在函数被调用时没有声明方式参数的情况下，默认值才会生效。这三个类都有一个构造函数可以直接调用open<br>函数，因此可以通过如下方式定义对象并打开文件：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">//使用构造函数</span><br><span class="hljs-function">ofstream <span class="hljs-title">ofile</span>(<span class="hljs-params"><span class="hljs-string">&quot;file.bin&quot;</span> , ios::<span class="hljs-keyword">out</span> | ios::app | ios::binary</span>)</span>;<br><br><span class="hljs-comment">//检查文件是否被成功打开，true为成功打开，否则为false</span><br><span class="hljs-function"><span class="hljs-built_in">bool</span> <span class="hljs-title">is_open</span>()</span>;<br></code></pre></td></tr></table></figure><h3 id="关闭文件"><a href="#关闭文件" class="headerlink" title="关闭文件"></a>关闭文件</h3><p>文件读写操作完毕后，必须将文件关闭以使文件重新变为可访问的。关闭文件可以使用成员函数close()，它负责将缓<br>存中的数据刷新并关闭文件。类ifstream、ofstream和fstream都拥有成员函数close()，声明如下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">close</span>()</span>;<br></code></pre></td></tr></table></figure><p>该函数一旦被调用，之前使用的流对象就可以被用来打开其它的文件，关闭的文件也就可以重新被其它的进程所访问<br>了。为防止流对象被销毁时仍关联着打开的文件，析构函数将会自动调用关闭函数close。</p><h3 id="读写文件、数据块"><a href="#读写文件、数据块" class="headerlink" title="读写文件、数据块"></a>读写文件、数据块</h3><p>在C++中，可以使用流提取运算符”&gt;&gt;” 从文件读取信息，使用流插入运算符”&lt;&lt;”向文件写入数据，就如同使用该运算从<br>键盘读取信息，然后输出到屏幕一样。不同点在于文件操作时使用的是ifstream、ofstream或fstream对象，屏幕和键盘<br>使用的是cin和cout对象。C++的I&#x2F;O中也提供了write和read函数，分别从流中读取数据和向流写入数据。    </p><blockquote><ul><li>wirte()函数是ostream的一个成员函数，被ofstream所继承</li><li>read()函数是istream的一个成员函数，被ifstream所继承</li><li>fstream类对象同时拥有write和read两个函数</li></ul></blockquote><p>函数原型如下：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function">ostream&amp; <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-type">char</span> * buffer , streamsize size)</span></span>;<br><span class="hljs-function">istream&amp; <span class="hljs-title">read</span><span class="hljs-params">(<span class="hljs-type">char</span> * buffer , streamsize size)</span></span>;<br></code></pre></td></tr></table></figure><p>其中buffer是申请的一块内存地址，用于储存从流中读出的数据或者将要写入流的数据；参数size是一个整数值，表示<br>将要从流中读入buffer或者从buffer写入流时的大小。函数示例如下：     </p><img src="/2023/01/31/C-%E4%B8%8B%E7%9A%84%E6%96%87%E4%BB%B6IO/3.png" class=""><h3 id="文件位置指针"><a href="#文件位置指针" class="headerlink" title="文件位置指针"></a>文件位置指针</h3><p>在C++中，istream和ostream也提供了用于重新定位文件位置指针的成员函数seekg和seekp，seekg用于设置输入文件<br>流的文件流指针位置，而seekp用于设置输出文件流的文件流指针位置。声明如下：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs scss">ostream&amp; <span class="hljs-built_in">seekp</span>(streampos pos);<br>ostream&amp; <span class="hljs-built_in">seekp</span>(streamoff off , ios::seek_dir dir);<br>istream&amp; <span class="hljs-built_in">seekg</span>(streampos pos);<br>istream&amp; <span class="hljs-built_in">seekg</span>(streamoff off , ios::seek_dir dir);<br></code></pre></td></tr></table></figure><p>其中，pos表示文件流指针新的位置值；off表示偏移量；dir表示起始位置；off和dir参数共同定位了文件流指针的操<br>作位置。dir在ios中定义的枚举类型如下：</p><figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs fsharp"><span class="hljs-built_in">enum</span> <span class="hljs-keyword">seek_dir</span>&#123;beg , cur , <span class="hljs-keyword">end</span>&#125;;<br></code></pre></td></tr></table></figure><p>每个枚举常量的含义如下：     </p><blockquote><ul><li>ios::beg : 文件流的起始位置（默认值，从流的开头开始定位）</li><li>ios::cur : 文件流的当前位置</li><li>ios::end : 文件流的结束位置</li></ul></blockquote><p>文件位置指针是一个整数值，指定了从文件的起始位置到指针所在位置的字节数。以下是关于定位获取文件位置指针<br>的示例：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>定位到fileObject的第n个字节（假设是ios::beg)<br>fileObject.seekg(n);<br><br><span class="hljs-regexp">//</span>把文件的读指针从fileObject当前位置向后移动n个字节<br>fileObject.seekg(n , ios::cur);<br><br><span class="hljs-regexp">//</span>把文件的读指针从fileObject末尾往回移动n个字节<br>fileObject.seekg(n , ios::end);<br><br><span class="hljs-regexp">//</span>定位到fileObject的末尾<br>fileObject.seekg(<span class="hljs-number">0</span> , ios::end);<br></code></pre></td></tr></table></figure><p>获取二进制文件大小的示例代码如下：     </p><img src="/2023/01/31/C-%E4%B8%8B%E7%9A%84%E6%96%87%E4%BB%B6IO/2.png" class=""><h3 id="状态标识符"><a href="#状态标识符" class="headerlink" title="状态标识符"></a>状态标识符</h3><p>验证流的状态的成员函数可以用于读写文件的过程中，如eof()函数，它是ifstream从类ios中继承过来的，当到达文<br>件末尾时返回true，除了eof()以外，还有一些其它的验证流的成员函数，这些函数的返回类型都是bool型。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">//读写过程中出错返回true，如对一个打开模式不是为写状态的文件进行写操作、写入设备没有空间、文件受损或硬</span><br><span class="hljs-comment">//件故障</span><br><span class="hljs-function"><span class="hljs-built_in">bool</span> <span class="hljs-title">bad</span>()</span>;<br><br><span class="hljs-comment">//读取数据类型不匹配返回true，如果遇到EOF，该方法也返回true</span><br><span class="hljs-function"><span class="hljs-built_in">bool</span> <span class="hljs-title">fail</span>()</span>;<br><br><span class="hljs-comment">//是否到文件尾部，遇到EOF，true为已到文件尾部</span><br><span class="hljs-function"><span class="hljs-built_in">bool</span> <span class="hljs-title">eof</span>()</span>;<br><br><span class="hljs-comment">//没有发生任何错误的时候返回true，上面的方法如果返回true，则该方法返回false</span><br><span class="hljs-function"><span class="hljs-built_in">bool</span> <span class="hljs-title">good</span>()</span>;<br><br><span class="hljs-comment">//重置以上成员函数所检查的状态标识</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">clear</span>()</span>;    <br></code></pre></td></tr></table></figure><h3 id="文件属性"><a href="#文件属性" class="headerlink" title="文件属性"></a>文件属性</h3><p>除了上面对文件的读写情况外，获取文件的相关信息（如类型、大小、是否存在）也会经常遇到，linux用函数stat来<br>获取文件的相关信息，之前的linux系统调用下文件IO有过介绍，该函数声明如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">stat</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *filename , <span class="hljs-keyword">struct</span> stat *buf)</span></span>;<br></code></pre></td></tr></table></figure><p>其中参数filename指向文件名；buf指向结构体stat，用于存放文件属性信息。关于结构体stat的定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">stat</span>&#123;<br>    <span class="hljs-type">mode_t</span>  st_mode;    <span class="hljs-comment">//文件的类型和存取的权限</span><br>    <span class="hljs-type">ino_t</span>   st_ino;     <span class="hljs-comment">//inode节点号</span><br>    <span class="hljs-type">dev_t</span>   st_dev;     <span class="hljs-comment">//文件设备编号</span><br>    <span class="hljs-type">dev_t</span>   st_rdev;    <span class="hljs-comment">//（设备类型）若此文件为设备文件，则为其设备编号</span><br>    <span class="hljs-type">nlink_t</span> st_nlink;   <span class="hljs-comment">//连到该文件的硬链接数目，刚建立的文件值为1</span><br>    <span class="hljs-type">uid_t</span>   st_uid;     <span class="hljs-comment">//文件所有者的用户ID</span><br>    <span class="hljs-type">gid_t</span>   st_gid;     <span class="hljs-comment">//文件所有者对应的组ID</span><br>    <span class="hljs-type">off_t</span>   st_size;    <span class="hljs-comment">//普通文件，对应的文件字节数</span><br>    <span class="hljs-type">time_t</span>  st_atime;   <span class="hljs-comment">//文件最后一次被访问的时间</span><br>    <span class="hljs-type">time_t</span>  st_mtime;   <span class="hljs-comment">//文件内容最后一次被修改的时间</span><br>    <span class="hljs-type">time_t</span>  st_ctime;   <span class="hljs-comment">//文件状态改变的时间（指属性）</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>   st_blksize;    <span class="hljs-comment">//文件内容对应的块大小(文件系统的I/O缓冲区大小)</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>   st_blocks;     <span class="hljs-comment">//文件内容对应的块数量</span><br>&#125;；<br></code></pre></td></tr></table></figure><p>如果函数执行成功，返回0；失败返回-1；错误代码存在于errno中，常见错误代码如下：   </p><blockquote><ul><li>ENOENT： 参数filename指定的文件不存在</li><li>ENOTDIR： 路径中的目录存在但却非真正的目录</li><li>ELOOP： 欲打开的文件有过多符号连接问题，上限为16个符号链接</li><li>EFAULT： 参数buf为无效指针，指向无法存在的内存空间</li><li>EACCESS： 存取文件时被拒绝</li><li>ENOMEM： 核心内存不足</li><li>ENAMETOOLONG： 参数filename的路径名称太长</li></ul></blockquote><p>这些宏定义可以在include&#x2F;asm-generic&#x2F;errno-base.h中找到。可以通过stat获取文件的类型和文件大小等信息。文<br>件类型有：普通文件、目录文件、块特殊文件、字符特殊文件、FIFO、套接字和符号链接。<br>获取文件大小和判断文件是否存在示例：      </p><img src="/2023/01/31/C-%E4%B8%8B%E7%9A%84%E6%96%87%E4%BB%B6IO/4.png" class=""><h3 id="文件目录项创建与删除"><a href="#文件目录项创建与删除" class="headerlink" title="文件目录项创建与删除"></a>文件目录项创建与删除</h3><p>目录文件中存放的是文件名和对应的inode号码，这些统称为目录项。link和unlink函数分别用于创建硬链接和删除硬<br>链接。link函数创建一个新目录项，并且增加一个链接数。unlink函数删除目录项，并且减少一个链接数。如果链接<br>数达到0并且没有任何进程打开该文件，该文件内容才被真正删除。如果在unlink之前没有close，那么依旧可以访问<br>文件内容。两个函数中的操作都是原子操作。总之，真正影响链接数的操作是link、unlink以及open的创建。删除文<br>件内容的真正含义是文件的链接数为0。link与unlink函数声明如下：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">link</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *oldpath , <span class="hljs-type">const</span> <span class="hljs-type">char</span> *newpath)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">unlink</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *pathname)</span></span>;<br></code></pre></td></tr></table></figure><p>link函数以参数newpath指定的名称来建立一个新的硬链接到参数oldpath所指定的已存在文件。如果参数newpath指定<br>的名称为一已经存在的文件则不会建立链接。link函数所建立的硬链接无法跨越不同文件系统，如果需要可以使用软<br>链接symlink函数。当oldpath不存在或者newpath存在会调用失败，调用成功时返回0，否则返回-1。<br>unlink函数的参数：pathname为要删除目录项的文件路径名。如果函数执行成功就返回0，否则返回-1。<br>linux中是用inode节点来区分文件的，当删除一个文件的时候，系统并不一定就会释放inode节点的内容。当满足以下<br>的要求时，系统才会释放inode节点的内容。   </p><blockquote><ul><li>(1) inode中记录指向该节点的硬链接数为0。</li><li>(2) 没有进程打开指向该节点的文件。</li></ul></blockquote><p>使用unlink函数删除文件的时候，只会删除目录项，并且将inode节点的硬链接数目减1，并不一定会释放inode节点。<br>如果此时没有进程正在打开该文件或者有其它文件指向该inode节点，该inode节点将会被释放；如果此时有进程正在<br>打开一个文件，而此时使用unlink删除了该文件，那么此时只是删除了目录项，并没有释放，因为此时仍然有进程在<br>占用此文件。<br>unlink函数的另一个用途就是用来创建临时文件，如果在程序中使用open创建了一个文件后，立即使用unlink函数删<br>除文件，由于此时进程正在打开该文件，因此系统并不会释放该文件的inode节点，而只是删除其目录项。当进程退出<br>时，该inode节点将会立即被释放。临时文件可以用在进程间通信的有名管道通信中。      </p><img src="/2023/01/31/C-%E4%B8%8B%E7%9A%84%E6%96%87%E4%BB%B6IO/5.png" class=""><img src="/2023/01/31/C-%E4%B8%8B%E7%9A%84%E6%96%87%E4%BB%B6IO/6.png" class=""><img src="/2023/01/31/C-%E4%B8%8B%E7%9A%84%E6%96%87%E4%BB%B6IO/7.png" class=""><p></p>      <p>可以看到，第二步open只读时不影响链接数；第三步close时也不会影响链接数；第四步link后链接数会+1；unlink后<br>链接数会-1；第六步重新打开链接数不变；第七步unlink之后再次-1，此时使用fstat函数获取文件属性而非stat，因<br>为unlink已经删除了文件名，所以无法通过文件名访问，但是fd仍然是打开的，文件内容还没有被真正删除，仍然可<br>以使用fd取得文件信息，到最后程序close关闭fd之后，文件内容被删除，ls查看test.dat时已不存该文件。</p>]]></content>
    
    
    <categories>
      
      <category>c++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>文件io</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2023/01/21</title>
    <link href="/2023/01/21/%E6%88%91%E7%9A%842022/"/>
    <url>/2023/01/21/%E6%88%91%E7%9A%842022/</url>
    
    <content type="html"><![CDATA[<h2 id="最是人间留不住，朱颜辞镜花辞树。"><a href="#最是人间留不住，朱颜辞镜花辞树。" class="headerlink" title="最是人间留不住，朱颜辞镜花辞树。"></a>最是人间留不住，朱颜辞镜花辞树。</h2><p>今天是一年的最后一天了，今晚过完就是癸卯兔年了。回顾2022全年，最开心的事情莫过于阿根廷夺冠，messi终圆童<br>话梦,也让我多年的青春和执念有始有终了。糟心的事情则是国内放开后家人相继中招，元旦时我和媳妇在这边也莫名<br>中招了，家里就剩小贝儿和母亲没被感染，真心希望这疫情赶紧早点结束，早点恢复正常的通航。工作上，今年好像<br>干的挺杂乱的，一会是java的项目，一会又是powershell的脚本项目，偶尔还得看看c++的项目，东一榔头西一棒槌的<br>一年就完了，技术上好像也没学到什么。值得欣慰的是在工作闲暇的时候看了些技术书籍，&lt;&lt;Essential C++&gt;&gt;和&lt;&lt;C++ Primer Plus&gt;&gt;<br>这是唯二看完的两本，其它的一些书都被看的零零碎碎，像小孩吃东西一样，东一口西一口，手边是什么就看什么。<br>&lt;&lt;计算机系统要素&gt;&gt;这本书看了有近一半多，这本也是所有书中让我受益最大的一本书，跟着这本书中的课后任务，<br>可以从硬件系统的设计搭建一直到操作系统、编译器、虚拟机以及编程语言的实现，我因为只看到一半多，所以现在<br>只做到虚拟机实现的上半部分。&lt;&lt;java虚拟机规范&gt;&gt;看了两章多，原来只要遵循jvm的规范，任何其它语言编写的程<br>序也都可以在jvm上运行，之前一直以为这是java语言专属的虚拟机。&lt;&lt;数据密集型应用系统设计&gt;&gt;这本书看了一章多<br>，开篇就是以twitter举例密集数据的设计应该兼顾考虑哪些范畴，也是一本难得的技术资料，豆瓣评分据说9.7，赶上<br>去年看的那本CSAPP了。&lt;&lt;Vim实用技巧&gt;&gt;看了三章，纯讲高效使用vim编辑器。&lt;&lt;剑指offer&gt;&gt;也看了两章多，也是很不<br>错的一本书，开篇列举的例子就很抓人。&lt;&lt;Linux C&#x2F;C++ &gt;&gt;看到第五章，主讲c++在linux端编程。&lt;&lt;百年孤独&gt;&gt;看了几<br>十页，文学类的巨著感觉现在的年龄已经看不进去了。这些就是2022年狗啃式看过的书，大部分书都被啃的零零碎碎，<br>希望新的一年我可以改掉这个毛病吧，也加把劲，尽早把这些书都啃完！同时也希望自己能将现在这个blog更新好，别<br>再像之前阿里云上的blog一样，没做过任何备份，最后把积累的一些东西就那样随意丢弃了。  </p><p>最后，祝每个人新年健康平安快乐，2023都得偿所愿！</p>]]></content>
    
    
    <categories>
      
      <category>杂记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>生活</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>linux系统调用下的文件I/O</title>
    <link href="/2023/01/15/linux%E6%96%87%E4%BB%B6io/"/>
    <url>/2023/01/15/linux%E6%96%87%E4%BB%B6io/</url>
    
    <content type="html"><![CDATA[<h2 id="关于I-x2F-O"><a href="#关于I-x2F-O" class="headerlink" title="关于I&#x2F;O"></a>关于I&#x2F;O</h2><p>I&#x2F;O就是输入&#x2F;输出，它是主存和外部设备（比如硬盘、U盘）之间复制数据的过程，其中数据从设备到内存的过程<br>称为输入，数据从内存到设备的过程叫输出，I&#x2F;O可以分为高级I&#x2F;O和低级I&#x2F;O，高级I&#x2F;O通常也称为带缓冲的I&#x2F;O，<br>比如ANSI C提供的标准I&#x2F;O库。低级I&#x2F;O通常也称为不带缓冲的I&#x2F;O，它是linux提供的系统调用，速度快，如函数<br>open、read、write等。而带缓冲的I&#x2F;O在系统调用前采用一定的策略，速度慢，但比不带缓冲的I&#x2F;O安全，如fopen、<br>fread、fwrite等。在linux下对文件进行输入输出操作有3种编程方式，一种是调用C库中文件的I&#x2F;O函数，比如<br>fopen、fread&#x2F;fwrite、fclose等，另外两种方式是使用linux的系统调用和C++文件流的操作。</p><h2 id="I-x2F-O相关函数"><a href="#I-x2F-O相关函数" class="headerlink" title="I&#x2F;O相关函数"></a>I&#x2F;O相关函数</h2><h4 id="文件描述符"><a href="#文件描述符" class="headerlink" title="文件描述符"></a>文件描述符</h4><p>对于linux而言，所有设备或文件的操作都是通过文件描述符进行的。当打开或者创建一个文件的时候，内核向进<br>程返回一个非负的文件描述符。后续对文件的操作只需要通过该文件描述符，内核记录有关这个打开文件的信息。<br>一个进程启动时，默认打开三个文件，标准输入、标准输出、标准错误，对应文件描述符是0（STDIN_FILENO）、<br>1（STDOUT_FILENO）、2（STDERR_FILENO）,这些常量定义在unistd.h头文件中。文件描述符和文件指针可以互相<br>转换，具体通过函数fileno和fdopen。函数fileno将文件指针转为文件描述符，函数声明如下:</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fileno</span><span class="hljs-params">(FILE *stream)</span></span>;<br></code></pre></td></tr></table></figure><p>其中，参数stream是文件指针。<br>函数fdopen将文件描述符转换为文件指针，声明如下：    </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">FILE *<span class="hljs-title">fdopen</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *mode)</span></span>;<br></code></pre></td></tr></table></figure><p>其中，参数fd是文件描述符，mode是打开方式。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;fileno(stdin) = %d\n&quot;</span>,<span class="hljs-built_in">fileno</span>(stdin));<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;fileno(stdout) = %d\n&quot;</span>,<span class="hljs-built_in">fileno</span>(stdout));<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;fileno(stderr) = %d\n&quot;</span>,<span class="hljs-built_in">fileno</span>(stderr));<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>编译运行：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">fileno(stdin) <span class="hljs-operator">=</span> <span class="hljs-number">0</span><span class="hljs-comment">;</span><br>fileno(stdout) <span class="hljs-operator">=</span> <span class="hljs-number">1</span><span class="hljs-comment">;</span><br>fileno(stderr) <span class="hljs-operator">=</span> <span class="hljs-number">2</span><span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><h4 id="打开或创建文件"><a href="#打开或创建文件" class="headerlink" title="打开或创建文件"></a>打开或创建文件</h4><p>linux提供open函数来打开或者创建一个文件。该函数声明如下：   </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">open</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *pathname, <span class="hljs-type">int</span> flags)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">open</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *pathname, <span class="hljs-type">int</span> flags, <span class="hljs-type">mode_t</span> mode)</span></span>;<br></code></pre></td></tr></table></figure><p>其中，参数pathname表示文件的名称，可以包含（绝对和相对）路径；flags表示文件打开方式；mode用来规定对该文件的<br>所有者、文件的用户组及系统中其他用户的访问权限。如果函数执行成功，就返回文件描述符，如果函数执行失败就返回-1.<br>文件打开的方式flags可以使用下列宏（当有多个选项时，采用“|”连接）： </p><blockquote><ul><li>O_RDONLY: 打开一个只供读取的文件。</li><li>O_WRONLY: 打开一个只供写入的文件。</li><li>O_RDWR: 打开一个可供读写的文件。</li><li>O_APPEND: 写入的所有数据将被追加到文件的末尾。</li><li>O_CREAT: 打开文件，如果文件不存在就建立文件。</li><li>O_EXCL: 如果已经置O_CREAT且文件存在，就强制open失败。</li><li>O_TRUNC: 在打开文件时，将文件的内容清。</li><li>O_DSYNC: 每次写入时，等待数据写到磁盘上。</li><li>O_RSYNC: 每次读取时，等待相同部分先写到磁盘上。</li><li>O_SYNC: 以同步方式写入文件，强制刷新内核缓冲区到输出文件。</li></ul></blockquote><p>最后三个SYNC（同步）选项都会降低性能，使用这些宏需要包含头文件fcntl.h。O_RDONLY、O_WRONLY或O_RDWR<br>这三个选项是必选一个的。mode只有创建文件时才使用此参数，指定文件的访问权限。模式包含以下:  </p><blockquote><ul><li>S_IRUSR: 文件所有者的读权限位。</li><li>S_IWUSR: 文件所有者的写权限位。</li><li>S_IXUSR: 文件所有者的执行权限位。</li><li>S_IRWXU: S_IRUSR | S_IWUSR | S_IXUSR。</li><li>S_IRGRP: 文件用户组的读权限位。</li><li>S_IWGRP: 文件用户组的写权限位。</li><li>S_IXGRP: 文件用户组的执行权限位。</li><li>S_IRWXG: S_IRGRP | S_IWGRP | S_IXGRP。</li><li>S_IROTH: 文件其他用户的读权限位。</li><li>S_IWOTH: 文件其他用户的写权限位。</li><li>S_IXOTH: 文件其他用户的执行权限位。</li><li>S_IRWXO: S_IROTH | S_IWOTH | S_IXOTH。</li></ul></blockquote><p>使用这些权限宏时需要包含头文件sys&#x2F;stat.h。文件的访问权限是跟根据umask&amp;~mode得出来的。例如：umask &#x3D; 0022,<br>mode &#x3D; 0655，则访问权限为：644。umask是目前用户在建立档案或目录时的权限默认值，可以通过命令umask或者<br>umask -S查看该值。<br>打开创建文件示例:</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">int</span> fd = <span class="hljs-keyword">open</span>(<span class="hljs-string">&quot;./test.txt&quot;</span>,O_RDONLY);<span class="hljs-regexp">//</span>以只读方式打开test.txt文件<br><span class="hljs-keyword">int</span> fd = <span class="hljs-keyword">open</span>(<span class="hljs-string">&quot;./test.txt&quot;</span>,O_CREAT | O_RDWR);<span class="hljs-regexp">//</span>不存在就新建，否则以读写方式打开test.txt文件<br></code></pre></td></tr></table></figure><p>为了维持与早期的unix系统的向后兼容性，linux也提供了一个专门创建文件的系统调用，creat函数，它的声明如下:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">creat</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *pathname, <span class="hljs-type">mode_t</span> mode)</span></span>;<br></code></pre></td></tr></table></figure><p>其中参数pathname表示文件的名称，可以包含（绝对和相对）路径；mode用来规定对该文件的所有者、文件的用户<br>组及系统中其他用户的访问权限，其取值与open函数的mode相同。如果函数执行成功就返回文件描述符，负责返回<br>-1。在unix的早期版本中，open系统调用仅仅存在两个参数的形式。如果文件不存在，就不能打开这些文件。文件<br>的创建则由单独的系统调用creat完成。在Linux及所有unix的近代版本中，creat系统调用是多余的，因为open也<br>可以用来创建文件。以下两种形式等价。</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">int fd</span> = creat(file , mode);<br><span class="hljs-attribute">int fd</span> = open(file , O_WRONLY | O_CREAT | O_TRUNC , mode);<br></code></pre></td></tr></table></figure><img src="/2023/01/15/linux%E6%96%87%E4%BB%B6io/1.png" class=""><h4 id="关闭文件"><a href="#关闭文件" class="headerlink" title="关闭文件"></a>关闭文件</h4><p> 文件不再使用的时候，需要关闭，关闭问价使用close函数，该函数声明如下：<br> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">close</span><span class="hljs-params">(<span class="hljs-type">int</span> fd)</span></span>;<br></code></pre></td></tr></table></figure><br>其中fd为要关闭的文件描述符，函数执行成功就返回文件描述符，否则则返回-1。<br>文件关闭以后，此问价描述符不再指向任何文件，从而此描述符可以再次使用。如果每次打开文件后不关闭，就会<br>将系统的文件描述符耗尽，最终导致不能再打开文件。</p><h4 id="读取文件数据"><a href="#读取文件数据" class="headerlink" title="读取文件数据"></a>读取文件数据</h4><p>read函数可以实现从已经打开的文件中读取数据，该函数声明如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">ssize_t</span> <span class="hljs-title">read</span><span class="hljs-params">(<span class="hljs-type">int</span> fd , <span class="hljs-type">void</span> *buf , <span class="hljs-type">size_t</span> count)</span></span>;<br></code></pre></td></tr></table></figure><p>该函数把参数fd所指的文件传送count个字节到buf指针所指的内存中，若count为0，则read函数不会起作用并<br>返回0，返回值为实际读取到的字节数，如果返回0，表示已经到达文件结尾或没有可以读取的数据。<em><strong>注意：文件读写位置会随读取到的字节移动。</strong></em><br>需要强调的是，如果函数读取成功，会返回实际读取到的字节数，所以最好能将返回值与参数count做比较，若<br>返回的字节数小于要求读取的字节数，则有可能读到了文件尾部或者read函数被信号中断了读取动作。若有错<br>误发生时，则返回-1，错误代码存入errno中，此时文件读写位置无法预期。<br>常见的错误代码如下：</p><blockquote><ul><li>EINTR: 此调用被信号所中断。</li><li>EAGAIN: 当使用不可阻断I&#x2F;O时（O_NONBLOCK），若无数据可读取，则返回此值。</li><li>EBADF: 参数fd为非有效的文件描述符，或者当前文件已关闭。</li></ul></blockquote><p>read函数示例如下：  </p><img src="/2023/01/15/linux%E6%96%87%E4%BB%B6io/2.png" class="">  <h4 id="向文件写入数据"><a href="#向文件写入数据" class="headerlink" title="向文件写入数据"></a>向文件写入数据</h4><p>函数write可用于将数据写入已经打开的文件，该函数声明如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">ssize_t</span> <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-type">int</span> fd , <span class="hljs-type">const</span> <span class="hljs-type">void</span> *buf , <span class="hljs-type">size_t</span> count)</span></span>;<br></code></pre></td></tr></table></figure><p>该函数会把参数buf所指向的缓冲区中的count个字节数据写入fd所指的文件内，文件读写位置会随之移动。fd<br>是一个已经打开的文件描述符；buf指向一个缓冲区，为要写入的数据；count表示要写入的数据长度，单位是<br>字节。函数执行成功时返回实际写入的数据的字节数，当有错误发生时返回-1。错误代码用errno查看，常见<br>错误代码如下：</p><blockquote><ul><li>EINTR: 此调用被信号所中断。</li><li>EADF: 参数fd是非有效的文件描述符，或者该文件已经关闭。</li></ul></blockquote><p>代码示例：  </p><img src="/2023/01/15/linux%E6%96%87%E4%BB%B6io/3.png" class="">   <h4 id="文件偏移量"><a href="#文件偏移量" class="headerlink" title="文件偏移量"></a>文件偏移量</h4><p>读写文件时可能需要从不同的位置开始，此时需要让文件的读写位置可以移动到新的位置，所以需要用到设定文<br>件偏移量的函数。文件偏移量指的是当前文件操作位置相对于文件开始位置的偏移，当打开一个文件时，如果没<br>有指定O_APPEND参数，文件的偏移量为0，如果指定了O_APPEND参数，文件的偏移量与文件的长度相等，即文件的<br>当前操作位置移到了文件的末尾。<br>用来设定文件偏移量的系统函数是lseek，声明如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">off_t</span> <span class="hljs-title">lseek</span><span class="hljs-params">(<span class="hljs-type">int</span> fd , <span class="hljs-type">off_t</span> offset , <span class="hljs-type">int</span> whence)</span></span>;<br></code></pre></td></tr></table></figure><p>该函数对文件描述符fd所代表的文件，按照操作模式whence和偏移量的大小off_t，重新设置文件偏移量。如果<br>lseek()函数操作成功，就返回新的文件偏移量的值；如果失败就返回-1.由于文件的偏移量可以为负值，因此判<br>断lseek()是否操作成功时，要用是否等于-1来判断，不能使用小于0进行判断。参数offset和whence搭配使用，<br>具体含义如下：</p><blockquote><ul><li>whence值为SEEK_SET时，offset为相对文件开始处的值。</li><li>whence值为SEEK_CUR时，offset为相对当前位置的值。</li><li>whence值为SEEK_END时，offset为相对文件结尾的值。</li></ul></blockquote><p>函数使用示例如下：  </p><img src="/2023/01/15/linux%E6%96%87%E4%BB%B6io/4.png" class="">  <p></p>打开lseek.txt文件，可以看到写入的内容前有^@符号，这些不是空格,而是“0“，或者称为文件空洞。如果偏     移量设置超出文件的大小，就会造成文件空洞现象，即文件尾部（0字节大小的文件尾部就是文件的开头）到设置  之间被”0”填充。示例代码中新创建的文件lseek.txt文件大小为0kb，所以设置文件偏移量后会造成文件空洞    的现象。   <img src="/2023/01/15/linux%E6%96%87%E4%BB%B6io/5.png" class="">  <p></p>删除掉刚才的lseek.txt文件，然后新建一个文件lseek.txt,输入123456789ABCDEF，然后再重新执行示例程序，  会看到offset test被写入到7后面，并覆盖7以后的内容。  <img src="/2023/01/15/linux%E6%96%87%E4%BB%B6io/6.png" class="">  <img src="/2023/01/15/linux%E6%96%87%E4%BB%B6io/7.png" class="">  <img src="/2023/01/15/linux%E6%96%87%E4%BB%B6io/8.png" class="">  <h4 id="获取文件状态"><a href="#获取文件状态" class="headerlink" title="获取文件状态"></a>获取文件状态</h4><p>程序设计的时候经常要用到文件的一些属性特征值，如文件的所有者、文件的修改时间、文件的大小等。此时可以<br>使用stat()函数、fstat()函数或者lstat()函数。这些函数都可以获得文件的状态，函数声明如下：  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">stat</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *path , <span class="hljs-keyword">struct</span> stat *buf)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fstat</span><span class="hljs-params">(<span class="hljs-type">int</span> fd , <span class="hljs-keyword">struct</span> stat *buf)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lstat</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *path , <span class="hljs-keyword">struct</span> stat *buf)</span></span>;<br></code></pre></td></tr></table></figure><p>其中参数path是文件路径（包含文件名）；fd是文件描述符；buf为指向struct stat的结构体指针，获得的文件<br>属性特征值从这个参数中回传。当函数执行成功时返回0，执行失败时返回-1.<br>fstat函数区别于另外两个系统调用函数的地方在于，fstat系统调用接受的是一个文件描述符，而另外两个则直接<br>接受文件的全路径。文件描述符需要使用open系统调用后才能取得，而文件全路径可以省略此步，直接使用文件的<br>path就可以了。stat函数与lstat的区别是：当文件是一个符号链接时，lstat返回的是该符号链接本身的信息；而<br>stat返回的是该链接指向的文件的信息。<br>结构体struct stat是文件的属性特征描述，该结构定义如下：  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">stat</span>&#123;<br>    <span class="hljs-type">mode_t</span>  st_mode;    <span class="hljs-comment">//文件对应的模式、文件、目录等</span><br>    <span class="hljs-type">ino_t</span>   st_ino;     <span class="hljs-comment">//inode节点号</span><br>    <span class="hljs-type">dev_t</span>   st_dev;     <span class="hljs-comment">//设备号码</span><br>    <span class="hljs-type">dev_t</span>   st_rdev;    <span class="hljs-comment">//特殊设备号码</span><br>    <span class="hljs-type">nlink_t</span> st_nlink;   <span class="hljs-comment">//文件的链接数</span><br>    <span class="hljs-type">uid_t</span>   st_uid;     <span class="hljs-comment">//文件所有者</span><br>    <span class="hljs-type">gid_t</span>   st_gid;     <span class="hljs-comment">//文件所有者对应的组</span><br>    <span class="hljs-type">off_t</span>   st_size;    <span class="hljs-comment">//普通文件，对应的文件字节数</span><br>    <span class="hljs-type">time_t</span>  st_atime;   <span class="hljs-comment">//文件最后被访问的时间</span><br>    <span class="hljs-type">time_t</span>  st_mtime;   <span class="hljs-comment">//文件内容最后被修改的时间</span><br>    <span class="hljs-type">time_t</span>  st_ctime;   <span class="hljs-comment">//文件状态改变的时间</span><br>    <span class="hljs-type">blksize_t</span>   st_blksize;    <span class="hljs-comment">//文件内容对应的块大小</span><br>    <span class="hljs-type">blkcnt_t</span>    st_blocks;     <span class="hljs-comment">//文件内容对应的块数量</span><br>&#125;；<br></code></pre></td></tr></table></figure><p>示例代码： </p><img src="/2023/01/15/linux%E6%96%87%E4%BB%B6io/9.png" class="">  <h4 id="文件锁定"><a href="#文件锁定" class="headerlink" title="文件锁定"></a>文件锁定</h4><p>当一个文件被多个用户共同使用和操作时，会导致共享资源产生竞争的状态，Linux采用给文件上锁的方法来避免产生共享资<br>源竞争。文件锁分为建议性锁和强制性锁，建议锁是指给文件上锁后，只在文件上设置一个锁的标识，其他进程如果要对该<br>文件进行操作时可以检测到有锁的存在，但该锁并不能阻止其它进程对这个文件要进行的操作。类似于红绿灯，红灯并不能<br>阻止车辆闯红灯的行为，更多的是建议规范。而强制性锁则是当给文件上锁后，其它进程要对这个文件进行不兼容的操作（<br>上了读锁，另外一个进程要写入）时，系统内核将会阻止后来的第二个进程，一直到第一个进程将锁解开。一般情况下，内<br>核和系统都不适合使用建议性锁，而应该使用强制性锁，这样可以防止一些破坏性的操作。每个进程对文件进行操作时，例<br>如执行open、read、write等操作时，内核都会检测该文件是否被加了强制性锁，如果加了强制性锁，其它进程对这些文件的<br>操作就会失败，也就是内核强制应用程序（即其它进程）来遵守游戏规则，这就是强制性锁的原理。<br><em><strong>对文件的加索操作是原子性的，并且，由fork产生的子进程不能继承父进程所设置的锁。也就意味着，若一个进程得到一把<br>锁，然后调用fork，那么对于父进程所获得的锁而言，子进程将被视为其它进程。对于从父进程处继承过来的任一描述符，<br>子进程都需要调用fnctl()函数才能获得属于它自己的锁。</strong></em><br>linux下可以使用fcntl()函数来实现文件的锁定。锁定文件在很多场合都很有用，例如为了防止进程的重复启动，可以在进<br>程启动时对&#x2F;var&#x2F;run目录下的.PID文件进行锁定，这样进程重复启动时，会因为无法对该文件上锁而退出。fcntl函数不仅能<br>对整个文件上锁，而且还可以对文件的某一记录上锁，此时的锁又称为记录锁。fcntl函数声明如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fcntl</span><span class="hljs-params">(<span class="hljs-type">int</span> fd , <span class="hljs-type">int</span> cmd , <span class="hljs-keyword">struct</span> flock *lock)</span></span>;<br></code></pre></td></tr></table></figure><p>其中，参数fd为文件描述符，cmd为操作命令，锁定文件时取值如下：  </p><blockquote><ul><li>F_GETLK: 根据lock描述，决定是否上文件锁或者记录锁。</li><li>F_SETLK: 设置lock所描述的文件锁或者记录锁。</li></ul></blockquote><p>lock是指向结构体flock的指针，用来说明是一个文件锁还是一个记录锁，是用于整个文件锁定还是锁定文件中的某一部分字<br>节。锁的方式有两种：建议锁和强制锁（然而这两种锁的区分并不是通过参数设置完成的，而是通过对系统的设置加以实现<br>的）。建议锁，相对温柔，在对文件进行锁操作时，会检测是否已经有锁存在，并且尊重已有的锁，但是其它的进程仍然可<br>以自由的修改文件。如果所有的程序进程都以一致的方式处理文件锁（或者记录锁），即在读写共享的文件前都申请一次文<br>件锁或记录锁，或者都不申请，总之所有进程都要以一致的方式进行处理。那么就不会发生冲突，这样的进程集称为合作进<br>程，合作进程使用建议性锁是可行的。强制锁是由内核执行的锁，当一个文件被执行强制锁，并且当前进程正在写入数据的<br>操作，此时内核将阻止其它进程对该文件进行的读写操作。采取强锁会对性能影响很大，fcntl函数默认是建议锁，如果需要<br>在Linux中使用强制锁，则需要在root权限下，通过mount命令用-o mand选项打开该机制。结构体flock定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">flock</span><br>&#123;<br>    <span class="hljs-type">short</span> <span class="hljs-type">int</span> l_type;     <span class="hljs-comment">//锁定的状态</span><br>    <span class="hljs-type">short</span> <span class="hljs-type">int</span> l_whence;   <span class="hljs-comment">//决定l_start的位置</span><br>    <span class="hljs-type">off_t</span>     l_start;    <span class="hljs-comment">//锁定区域的开头位置</span><br>    <span class="hljs-type">off_t</span>     l_len;      <span class="hljs-comment">//锁定区域的大小</span><br>    <span class="hljs-type">pid_t</span>     l_pid;      <span class="hljs-comment">//锁定动作的进程</span><br>&#125;；<br></code></pre></td></tr></table></figure><p>l_type有三个选项：  </p><blockquote><ul><li>F_RDLCK: 共享锁（也称读锁），只读用，多个进程可以同时建立读取锁。</li><li>F_WRLCK: 独占锁（也称写锁），在任何时刻只能有一个进程建立写入锁</li><li>F_UNLCK: 解除锁定。</li></ul></blockquote><p>l_whence有以下几个选项（在unistd.h中定义）：</p><blockquote><ul><li>SEEK_SET: 文件开始位置</li><li>SEEK_CUR: 文件当前位置</li><li>SEEK_END: 文件末尾位置</li></ul></blockquote><p>其它的三个参数：</p><blockquote><ul><li>l_start: 相对开始偏移量，相对于l_whence而言。</li><li>l_len: 加锁的长度，0为到文件末尾。</li><li>l_pid：当前操作文件的进程ID号。</li></ul></blockquote><p>如果函数执行成功返回值为0，否则返回-1，此时可用errno查看错误码。函数使用示例代码如下：</p><img src="/2023/01/15/linux%E6%96%87%E4%BB%B6io/10.png" class="">  <p></p>如上图所示，程序编译并运行，此时程序处于死循环状态，并且文件已经加锁成功（默认为建议锁）。然后往lock.txt的文  件中写入数据，可以看到是可以写入成功的，如下图所示:    <img src="/2023/01/15/linux%E6%96%87%E4%BB%B6io/11.png" class="">  <p></p>上图中的lock.txt文件内容开始是空的，然后用echo往该上锁文件中写入数据，再次输出时可以看到写入的数据被输出了，  说明被建议锁锁住的文件的确是可以被其它进程修改的,所以建议锁只适合于合作进程。建议锁就是假定所有人都会遵守某  些规则去做一件事，例如人与车看到红灯都会停，看到绿灯才会继续走，此时的红绿灯就类似于建议锁，但这是一件需要  大家主动去遵守的规则，而并不能避免有些车与人强行闯红灯，而强制锁则完全是无法闯红灯的措施。  实现强制锁需要将文件所在的文件系统通过mount命令的“-o mand”选项来挂载，并且使用chmod函数或者chmod命令将文  件用户组的x权限去掉（即清楚组可执行位）。如下图所示：  首先切换到root用户，并查看我们的文件挂载硬盘信息：      <img src="/2023/01/15/linux%E6%96%87%E4%BB%B6io/12.png" class="">  <p></p> 可以看到lock.txt文件是挂载在/dev/sdc下的，所以进入lock.txt所在目录重新进行挂载，挂载完成后，此时文件系统   /dev/sdc增加了mand选项，然后再修改lock.txt的权限，将用户组的x权限去掉。如下图所示：    <img src="/2023/01/15/linux%E6%96%87%E4%BB%B6io/13.png" class="">  <p></p>  <img src="/2023/01/15/linux%E6%96%87%E4%BB%B6io/14.png" class="">  <p></p>此时重新运行之前的test_filelock程序，程序处于死循环当中，然后重新打开一个终端shell,尝试向lock.txt中写入新  内容，可以发现，#提示符出现不了，说明echo命令被阻塞不动了（内核阻止了该进程），说明强制锁已经生效。然后回  到之前的shell使用ctrl+c终止test_filelock程序，可以发现另一个shell的echo进程阻塞被解除了，出现了#提示符，查  看lock.txt文件，发现新的内容已经被写入，这说明强制锁解除后，就可以写入新内容了，否则无法写入。从这个例子可  以看出，强制锁的实现只是进行了一些系统上的设置，重新加载了文件系统，修改了文件的权限，程序上并没有进行任何  更改。<h4 id="文件与内存映射"><a href="#文件与内存映射" class="headerlink" title="文件与内存映射"></a>文件与内存映射</h4><p>文件和内存的映射，就是将普通文件映射到内存中，普通文件被映射到进程地址空间后，进程可以像访问普通内存一样对<br>文件进行访问，不需要再调用read或者write等函数进行操作。将普通文件映射到内存的系统函数为mmap,函数声明如下：  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/mman.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">void</span> *<span class="hljs-title">mmap</span><span class="hljs-params">(<span class="hljs-type">void</span> *start , <span class="hljs-type">size_t</span> length , <span class="hljs-type">int</span> prot , <span class="hljs-type">int</span> flags , <span class="hljs-type">int</span> fd , <span class="hljs-type">off_t</span> offset)</span></span>;<br></code></pre></td></tr></table></figure><p>其中参数start为映射区域的起始地址，通常为NULL或0，表示由系统自己决定映射到什么地址；length为映射数据的长度<br>，即文件需要映射到内存中的数据的大小；prot表示映射区域的保护方式，有以下取值（或它们的组合）：  </p><blockquote><ul><li>PROT_EXEC: 映射区可被执行。</li><li>PROT_READ: 映射区可读取。</li><li>PROT_WRITE: 映射区可写入。</li><li>PROT_NONE: 映射区不可访问。</li></ul></blockquote><p>flags用来指定映射对象的类型、映射选项和映射页是否可以共享，它的取值可以是一个或者多个位的组合。如下所示：  </p><blockquote><ul><li>MAP_FIXED: 如果参数start指定了需要映射到的地址，而所指定的地址无法成功建立映射，映射就会失败。通常不推<br>         荐使用此设置，而将start设置为NULL或0，由系统自动选取映射地址。</li><li>MAP_SHARED: 共享映射区域，映射区域允许其它进程共享，对映射区域写入数据将会写入原来的文件中。</li><li>MAP_PRIVATE: 对映射区域进行写入操作时会产生一个映射文件的复制，即私人的写入时复制（copy on write），对此<br>           映射区域的修改不会写回原来的文件，即不会影响原来文件的内容。</li><li>MAP_ANONYMOUS: 建立匿名映射。映射区不与任何文件关联，而且映射区无法与其它进程共享。</li><li>MAP_DENYWRITE: 对文件的写入操作将被禁止，不允许直接对文件进行操作。</li><li>MAP_LOCKED: 将映射区锁定，防止页面被交换出内存。</li></ul></blockquote><p>参数flags必须为MAP_SHARED或者MAP_PRIVATE二者之一的类型。MAP_SHARED类型表示多个进程使用的是一个内存映射的副<br>本，任何一个进程都可以对此映射进行修改，且其它进程对此修改是可见的。而MAP_PRIVATE则是多个进程使用的文件内存<br>映射，在写入操作后，会复制一个副本给修改的进程，多个进程之间的副本是不一致的。<br>参数fd表示文件描述符，一般由open()函数返回；<br>参数offset表示被映射数据在文件中的起点；<br>mmap()函数映射后，可以让用户程序直接访问设备内存，相比较在用户空间和内核空间相互复制数据，小路更高，在<br>要求高性能的应用中比较常用。mmap映射内存必须是页面大小的整数倍，面向流的设备不能进行mmap映射，mmap的实<br>现和硬件有关。<br>mmap()使用示例：  </p><img src="/2023/01/15/linux%E6%96%87%E4%BB%B6io/15.png" class="">   <p></p><img src="/2023/01/15/linux%E6%96%87%E4%BB%B6io/16.png" class="">         <p></p>以上的程序将文件test.txt的内容先映射到内存mapped_mem，然后使用printf函数将此内存区域的内容输出出来，可以看到，输出的内容正是test.txt文本文件的内容。   以上的示例因为使用的是PROT_READ，所以只能读取文件里的内容，不能修改，如果使用PROT_WIRTE，就可以修改文件的内容了。又因为使用了MMAP_PRIVATE，所以只能此进程使用此内存区域，若换用MAP_SHARED，则可以被其它进程访问，如下例示：       <img src="/2023/01/15/linux%E6%96%87%E4%BB%B6io/17.png" class="">    <p></p><img src="/2023/01/15/linux%E6%96%87%E4%BB%B6io/18.png" class="">         <p></p>可以看到，我们通过对内存映射的修改，文本文件也修改成功了。   #### mmap和共享内存共享内存允许两个或者多个进程共享一个给定的存储区，因为数据不需要来回复制，所以是最快的一种进程间通讯机制。共享内存可以通过mmap()映射普通文件（特殊情况下还可以采用匿名映射）机制实现，也可以通过系统V共享内存机制实现。应用接口和原理很简单，内部机制复杂。为了实现更安全的通信，往往还与信号灯等同步机制共同使用。对比如下：   > - mmap机制：就是在硬盘上建立一个文件，每个进程存储器里面单独开辟一个空间来进行映射。如果是多进程，那么对实际的物理存储器（主存）消耗不会太大。mmap保存到实际硬盘，实际存储并没有反映到主存上。优点是存储量可以很大（多于主存），缺点是进程间读取和写入速度要比主存的慢。   > - shm机制：每个进程的共享内存都直接映射到实际物理存储器里面。shm保存到物理存储器（主存），实际的存储量直接反映到主存上。优点是进程间访问速度（读写）比磁盘要快，缺点是存储量不能非常大（多于主存）。        <p>从使用上看，如果分配的存储量不大，就使用shm；如果存储量大，就使用mmap。</p>]]></content>
    
    
    <categories>
      
      <category>linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>文件io</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>窗口函数</title>
    <link href="/2022/11/20/%E7%AA%97%E5%8F%A3%E5%87%BD%E6%95%B0/"/>
    <url>/2022/11/20/%E7%AA%97%E5%8F%A3%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="窗口函数"><a href="#窗口函数" class="headerlink" title="窗口函数"></a>窗口函数</h2><p>窗口函数（也称为分析函数）针对一组行计算值，并为每行返回一个结果。这与聚合函数不同；聚合函数会为一组行返回一个结果。<br>窗口函数，也叫OLAP函数（Online Anallytical Processing，联机分析处理），可以对数据库数据进行实时分析处理。<br>窗口函数包含一个 OVER 子句，该子句定义了涵盖所要计算行的行窗口。对于每一行，系统会使用选定的行窗口作为输入来计算窗口函数结果，并可能进行聚合。<br>语法如下：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">&lt;窗口函数&gt; <span class="hljs-keyword">over</span> (<span class="hljs-keyword">partition</span> <span class="hljs-keyword">by</span> &lt;用于分组的列名&gt;<br>                <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> &lt;用于排序的列名&gt;)<br></code></pre></td></tr></table></figure><p>借助窗口函数，您可以计算移动平均值、对各项进行排名、计算累计总和，以及执行其他分析。<br>常用的业务场景有：部门按员工业绩排名、或者找出每个部门的topN员工等。</p><h4 id="窗口函数使用"><a href="#窗口函数使用" class="headerlink" title="窗口函数使用"></a>窗口函数使用</h4><p>窗口函数分为两种：</p><ul><li>专用窗口函数：rank, dense_rank, row_number等</li><li>聚合函数：sum. avg, count, max, min等</li></ul><ol><li>初始表数据如下<figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> student_score;<br></code></pre></td></tr></table></figure><img src="/2022/11/20/%E7%AA%97%E5%8F%A3%E5%87%BD%E6%95%B0/1.png" class=""></li></ol><p></p>  <hr><ol start="2"><li>业务需求：各个班级独自按成绩排名<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">select</span> * ,rank()<span class="hljs-keyword">over</span>(<span class="hljs-keyword">partition</span> <span class="hljs-keyword">by</span> std_class <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> std_score <span class="hljs-keyword">desc</span>) <span class="hljs-keyword">as</span> ranking<br><span class="hljs-keyword">from</span> student_score;<br></code></pre></td></tr></table></figure>该sql语句使用partition by对班级进行分组，order by 对分组后的成绩进行排序。</li></ol><img src="/2022/11/20/%E7%AA%97%E5%8F%A3%E5%87%BD%E6%95%B0/2.png" class=""><p></p>上述业务group by和order by不易实现，因为group by分组完会改变表的行数，一行只代表一个类别，而partition by和rank是不会改变原表的行数的。      <hr><ol start="3"><li>其它窗口函数<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">select</span> * ,rank()<span class="hljs-keyword">over</span>(<span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> std_score <span class="hljs-keyword">desc</span>) <span class="hljs-keyword">as</span> ranking, <br>         dense_rank() <span class="hljs-keyword">over</span>(<span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> std_score <span class="hljs-keyword">desc</span>) <span class="hljs-keyword">as</span> den_ranking, <br>         row_number() <span class="hljs-keyword">over</span>(<span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> std_score <span class="hljs-keyword">desc</span>) <span class="hljs-keyword">as</span> row_num <br><span class="hljs-keyword">from</span> student_score;<br></code></pre></td></tr></table></figure><img src="/2022/11/20/%E7%AA%97%E5%8F%A3%E5%87%BD%E6%95%B0/3.png" class=""></li></ol><p></p><blockquote><ul><li>rank函数：如果有并列的名次，则排名相同，下一位置被占。</li><li>dense_rank函数：如果有并列的名次，则排名相同，下一位置不被占。</li><li>row_num函数：不考虑并列情况。</li></ul></blockquote><ol start="4"><li>其它聚合函数</li></ol><pre><code class="hljs">select * ,sum(std_score) over(order by std_id) as std_sum,       avg(std_score) over(order by std_id) as std_avg,       count(std_score) over(order by std_id) as std_count,       max(std_score) over(order by std_id) as std_max,       min(std_score) over(order by std_id) as std_min   from student_score;</code></pre><img src="/2022/11/20/%E7%AA%97%E5%8F%A3%E5%87%BD%E6%95%B0/4.png" class=""><p></p>窗口函数中使用聚合函数的效果如上所示，每行的值都是截至到该行数据的一个汇总计算，不会涵盖该行以下。<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><blockquote><p>窗口函数不同于group by等，它不会改变原表的行数，且同时具有分组和排序的功能，<br>窗口是指分组过后每组的数据范围，通常窗口函数只存在于select语句中。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>sql</category>
      
    </categories>
    
    
    <tags>
      
      <tag>sql函数</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>power shell脚本命令</title>
    <link href="/2022/11/11/powershell%E8%84%9A%E6%9C%AC/"/>
    <url>/2022/11/11/powershell%E8%84%9A%E6%9C%AC/</url>
    
    <content type="html"><![CDATA[<p>最近开始支援其他项目组做一些脚本开发的工作，memo一下常用的数据处理命令。  </p><ul><li>去除输入文件的首行，重新生成新的文件：<figure class="highlight dsconfig"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dsconfig">$<span class="hljs-string">x</span> = <span class="hljs-string">Get-Content</span> -<span class="hljs-string">Path</span> <span class="hljs-string">&quot;..test.csv&quot;</span><br><span class="hljs-built_in">set-Content</span> -<span class="hljs-string">Path</span> <span class="hljs-string">&quot;..new.csv&quot;</span> -<span class="hljs-string">Value</span> ($<span class="hljs-string">x</span>[<span class="hljs-string">1</span>..($<span class="hljs-string">x</span>.<span class="hljs-string">Length-1</span>)])<br></code></pre></td></tr></table></figure></li><li>获取文件的当前路径 $PSScriptRoot</li></ul><figure class="highlight monkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs monkey"><span class="hljs-keyword">Import</span>-<span class="hljs-keyword">Module</span> ./test.ps1<span class="hljs-meta"></span><br><span class="hljs-meta"># 更改为</span><br><span class="hljs-keyword">Import</span>-<span class="hljs-keyword">Module</span> $PSScriptRoot/test.ps1<br></code></pre></td></tr></table></figure><p>这样可以避免执行脚本时必须进入脚本所在的目录，只需要在任意路径下输入脚本的绝对路径，这样脚本中其它的导<br>入模块也会正常的被脚本读取到。</p><ul><li>将读入的csv文件转化为数组<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-variable">$csvdata</span> = <span class="hljs-selector-tag">@</span>(<span class="hljs-built_in">Import-Csv</span> <span class="hljs-variable">$csvfile</span> <span class="hljs-literal">-Encoding</span> UTF8)<br><span class="hljs-comment"># 数组长度</span><br><span class="hljs-variable">$arrsize</span> = <span class="hljs-variable">$csvdate</span>.Count<br></code></pre></td></tr></table></figure></li><li>导入导出CSV<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-comment">#导入</span><br><span class="hljs-variable">$csvdata</span> = <span class="hljs-built_in">Import-Csv</span> <span class="hljs-literal">-Encoding</span> UTF8 <span class="hljs-literal">-Path</span> xxxx<br><span class="hljs-comment">#数据库查询结果处理</span><br><span class="hljs-variable">$result</span> | <span class="hljs-built_in">Foreach-Object</span>&#123;<br>    <span class="hljs-variable">$object</span> = <span class="hljs-built_in">New-Object</span> PSObject | <span class="hljs-built_in">Select-Object</span> col1,col2,col3<br>    <span class="hljs-variable">$object</span>.col1 = <span class="hljs-variable">$_</span>.col1<br>    <span class="hljs-variable">$object</span>.col2 = <span class="hljs-variable">$_</span>.col2<br>    <span class="hljs-variable">$object</span>.col3 = <span class="hljs-variable">$_</span>.col3<br>    <span class="hljs-variable">$list</span>.AddRange(<span class="hljs-variable">$object</span>)<br>&#125;<br><span class="hljs-comment">#导出</span><br><span class="hljs-variable">$csvdata</span> | <span class="hljs-built_in">ConvertTo-Csv</span> <span class="hljs-literal">-NoTypeInfomation</span> | <span class="hljs-built_in">Out-File</span> <span class="hljs-literal">-FilePath</span> xxxx <span class="hljs-literal">-Encoding</span> UTF8<br><span class="hljs-comment">#导出时去除引号</span><br><span class="hljs-variable">$csvdata</span> | <span class="hljs-built_in">ConvertTo-Csv</span> <span class="hljs-literal">-NoTypeInfomation</span> | <span class="hljs-built_in">ForEach-Object</span> &#123; <span class="hljs-variable">$_</span> <span class="hljs-operator">-replace</span> <span class="hljs-string">&#x27;&quot;&#x27;</span>&#125;&#125; | <span class="hljs-built_in">Out-File</span> <span class="hljs-literal">-FilePath</span> xxxx <span class="hljs-literal">-Encoding</span> UTF8<br><span class="hljs-comment">#导出去除首行</span><br><span class="hljs-variable">$csvdata</span> | <span class="hljs-built_in">Select-Object</span> <span class="hljs-literal">-Skip</span> <span class="hljs-number">1</span> | <span class="hljs-built_in">ConvertTo-Csv</span> <span class="hljs-literal">-NoTypeInfomation</span> | <span class="hljs-built_in">Out-File</span> <span class="hljs-literal">-FilePath</span> xxxx <span class="hljs-literal">-Encoding</span> UTF8<br></code></pre></td></tr></table></figure>如果脚本对性能有一定的要求的话，尽量就使用.net，避免使用powershell自身的cmdlet和管道等，支援的项目就因<br>为大量的使用了powershell自身的数组，导致性能极低，跑几万条数据需要好几个小时才能结束，譬如在大的循环中<br>尽量避免@()数组的使用，因为它是不可变的，每次数组相加时就会创建一个足以容纳左操作数和右操作数的所有原<br>素的数组，系统会将两个操作数的元素复制到新数组中。同样避免使用字符串的加法操作，原因也是字符串是不可变<br>的，每次相加都会导致系统的多于IO操作。<figure class="highlight nsis"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs nsis"><span class="hljs-comment">#数组</span><br><span class="hljs-variable">$list</span> = @()<br><span class="hljs-variable">$list</span> += xxx<br><span class="hljs-comment">#优化为</span><br>[<span class="hljs-params">System</span>.Collections.ArrayList]<span class="hljs-variable">$list</span> = [<span class="hljs-params">System</span>.Collections.ArrayList]::new()<br><span class="hljs-variable">$list.AddRange</span>(xxx)<br><br><span class="hljs-comment">#字符串</span><br><span class="hljs-variable">$str1</span> = <span class="hljs-string">&quot;xxx&quot;</span><br><span class="hljs-variable">$str2</span> = <span class="hljs-string">&quot;yyy&quot;</span><br><span class="hljs-variable">$str3</span> = <span class="hljs-variable">$str1</span> + <span class="hljs-variable">$str2</span><br><span class="hljs-comment">#优化为使用-join或者StringBuilder</span><br><span class="hljs-variable">$str1</span> = <span class="hljs-string">&quot;xxx&quot;</span><br><span class="hljs-variable">$str2</span> = <span class="hljs-string">&quot;yyy&quot;</span><br><span class="hljs-variable">$str3</span> = <span class="hljs-variable">$str1</span>,<span class="hljs-variable">$str2</span> -join <span class="hljs-string">&quot;&quot;</span><br><span class="hljs-comment">#或者</span><br><span class="hljs-variable">$str3</span> = [<span class="hljs-params">System</span>.Text.StringBuilder]::new()<br><span class="hljs-variable">$str3.Append</span>(str1)<br><span class="hljs-variable">$str3.Append</span>(str2)<br></code></pre></td></tr></table></figure></li><li>处理大型文件时可以直接使用.NET的API提高性能<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-comment">#惯用方法</span><br><span class="hljs-built_in">Get-Content</span> <span class="hljs-variable">$path</span> | <span class="hljs-built_in">Where-Object</span>&#123; <span class="hljs-variable">$_</span>.Length <span class="hljs-operator">-gt</span> <span class="hljs-number">10</span>&#125;<br><span class="hljs-comment">#优化为</span><br><span class="hljs-keyword">try</span>&#123;<br>    <span class="hljs-variable">$stream</span> = [<span class="hljs-type">System.IO.StreamReader</span>]::new(<span class="hljs-variable">$path</span>)<br>    <span class="hljs-keyword">while</span>(<span class="hljs-variable">$line</span> = <span class="hljs-variable">$stream</span>.ReadLine())<br>    &#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-variable">$line</span>.Length <span class="hljs-operator">-gt</span> <span class="hljs-number">10</span>)<br>        &#123;<br>            <span class="hljs-variable">$line</span><br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">finally</span>&#123;<br>    <span class="hljs-variable">$stream</span>.Dispose()<br>&#125;<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>shell</category>
      
    </categories>
    
    
    <tags>
      
      <tag>powershell</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>poi包冲突调试</title>
    <link href="/2022/11/02/poi%E5%8C%85%E5%86%B2%E7%AA%81%E8%B0%83%E8%AF%95/"/>
    <url>/2022/11/02/poi%E5%8C%85%E5%86%B2%E7%AA%81%E8%B0%83%E8%AF%95/</url>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>媳妇她们项目组在做一个老旧项目的升级移行工作，她最近主要在负责batch这块的改修，其中有一个功能是关于<br>excel生成的，之前老项目中是HSSF的导出，现在她要升级为XSSF的导出，所以得引入一些poi的包，由于导入了<br>部分新包，所以项目产生了莫名其妙的报错。</p><h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><p>由于她们的项目是很老的项目，没有使用maven管理，所以排查起来很是费劲。先是在本地建了一个maven的项目，<br>然后导入了主要的两个poi包，poi-5.2.2.jar和poi-ooxml-5.2.2.jar，查看了它们的依赖关系，锁定了需要的最<br>小依赖，写了段简略的读写测试代码，运行调试通过。最后将项目所有包导入，运行报错，试着删除和poi有依赖<br>冲突可能的包，直到测试代码可以正常运行。最后锁定了一个名为poi-2.5.1-final-20040804.jar的包，删掉此<br>包后测试代码正常执行导入导出，但是奇怪的是再次导入此包后测试代码仍然可以正常运行，以为是项目缓存<br>导致的，所以将project又clean了继续运行，然而测试代码仍然正常结束。重复了几次，发现只有在第一次导入<br>所有包时运行报错，删除poi-2.5.1-final-20040804.jar包后就正常运行，再次导入后又不会引发冲突错误，更<br>令人费解的是正式项目的引用包中是没有poi-2.5.1-final-20040804.jar的。<br><br>报错如下：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">Exception <span class="hljs-keyword">in</span> thread <span class="hljs-string">&quot;main&quot;</span> java.lang.NoSuchMethodError: org.apache.poi.util.<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">IOUtils</span>.</span></span>copy(Ljava/io/InputStream;Ljava/io/OutputStream;)J<br>at org.apache.poi.openxml4j.opc.internal.marshallers.<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ZipPartMarshaller</span>.</span></span>marshall(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ZipPartMarshaller</span>.</span></span>java:<span class="hljs-number">89</span>)<br>at org.apache.poi.openxml4j.opc.internal.<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">MemoryPackagePart</span>.</span></span>save(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">MemoryPackagePart</span>.</span></span>java:<span class="hljs-number">111</span>)<br>at org.apache.poi.openxml4j.opc.internal.marshallers.<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">DefaultMarshaller</span>.</span></span>marshall(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">DefaultMarshaller</span>.</span></span>java:<span class="hljs-number">46</span>)<br>at org.apache.poi.openxml4j.opc.<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ZipPackage</span>.</span></span>save<span class="hljs-constructor">Impl(ZipPackage.<span class="hljs-params">java</span>:584)</span><br>at org.apache.poi.openxml4j.opc.<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">OPCPackage</span>.</span></span>save(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">OPCPackage</span>.</span></span>java:<span class="hljs-number">1490</span>)<br>at org.apache.poi.ooxml.<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">POIXMLDocument</span>.</span></span>write(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">POIXMLDocument</span>.</span></span>java:<span class="hljs-number">227</span>)<br>at testlib.<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Test</span>.</span></span>main(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Test</span>.</span></span>java:<span class="hljs-number">31</span>)<br></code></pre></td></tr></table></figure><p>或者报错是关于btye[]的方法peekFirstNBtyes之类。</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>由于错误log中所报的这些方法经过跟踪确实是存在的，删掉poi-2.5.1-final-20040804.jar包也确实不再报错，所以可以<br>确定的是问题肯定出在了poi-2.5.1-final-20040804.jar这个jar包上，但是为什么只有第一次存在这个jar包引用时会出错<br>删掉再导入后又不会引发冲突，为什么正式项目中没有此包也报错？本能觉得是项目结构构筑的问题，所以就查看了关于<br>build path的详细信息，发现关于order and export的一段描述是越上层的优先级越高，而我本地的build path中的导致<br>报错的poi-2.5.1-final-20040804.jar包却在最底层，所以我将该包的优先级调为了上层又复现了之前的错误，为什么只<br>有第一次导入会导致报错，删除后重新导入就不会引发错误的问题至此已经解决，还有第二个问题是正式项目中没有此包<br>为什么也会报错，这个问题经过查看build path后发现老项目中引用了一个外部工程common，而位于顶层的common当中<br>引用了poi-2.5.1-final-20040804.jar此包，经过优先级重调，第二个问题也顺利解决。<br><br>模拟第一次报错：</p><img src="/2022/11/02/poi%E5%8C%85%E5%86%B2%E7%AA%81%E8%B0%83%E8%AF%95/1.png" class=""><p></p>  <hr><p>删除冲突包执行成功：</p><img src="/2022/11/02/poi%E5%8C%85%E5%86%B2%E7%AA%81%E8%B0%83%E8%AF%95/2.png" class=""><img src="/2022/11/02/poi%E5%8C%85%E5%86%B2%E7%AA%81%E8%B0%83%E8%AF%95/3.png" class=""><p></p>  <hr><p>再次导入冲突包执行依然成功：</p><img src="/2022/11/02/poi%E5%8C%85%E5%86%B2%E7%AA%81%E8%B0%83%E8%AF%95/4.png" class=""><img src="/2022/11/02/poi%E5%8C%85%E5%86%B2%E7%AA%81%E8%B0%83%E8%AF%95/5.png" class=""><img src="/2022/11/02/poi%E5%8C%85%E5%86%B2%E7%AA%81%E8%B0%83%E8%AF%95/6.png" class=""><img src="/2022/11/02/poi%E5%8C%85%E5%86%B2%E7%AA%81%E8%B0%83%E8%AF%95/7.png" class=""><img src="/2022/11/02/poi%E5%8C%85%E5%86%B2%E7%AA%81%E8%B0%83%E8%AF%95/8.png" class=""><p></p>  <hr><p>更改引用顺序，重现错误：  </p><img src="/2022/11/02/poi%E5%8C%85%E5%86%B2%E7%AA%81%E8%B0%83%E8%AF%95/9.png" class=""><img src="/2022/11/02/poi%E5%8C%85%E5%86%B2%E7%AA%81%E8%B0%83%E8%AF%95/10.png" class="">]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>jar包冲突</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>指针相等问题</title>
    <link href="/2022/11/01/%E5%88%A4%E6%96%AD%E4%B8%A4%E4%B8%AA%E6%8C%87%E9%92%88%E7%9B%B8%E7%AD%89%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/"/>
    <url>/2022/11/01/%E5%88%A4%E6%96%AD%E4%B8%A4%E4%B8%AA%E6%8C%87%E9%92%88%E7%9B%B8%E7%AD%89%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</url>
    
    <content type="html"><![CDATA[<h2 id="指针操作"><a href="#指针操作" class="headerlink" title="指针操作"></a>指针操作</h2><p>C++ Primer中关于指针操作中有一段描述是：</p><blockquote><p>对于两个类型相同的合法指针，可以用相等操作符 &#x3D;&#x3D; 或 不相等操作符 !&#x3D; 来比较它们，比较的的结果<br>是布尔类型。如果两个指针存放的地址值相同，则它们相等；反之它们不相等。这里两个指针存放的地址值相同（两个指针相等）<br>有三种可能：它们都为空、都指向同一个对象、或者都指向了同一个对象的下一地址。<br>需要注意的是:<strong>一个指针指向某对象，同时另一个指针指向另外对象的下一地址，此时也有可能出现这两个指针值相同的情况，即指针相等。</strong></p></blockquote><p>关于最后描述的同一个对象的下一地址，出现有可能相等的情况，这是因为内存的申请使用一般都是连续分配的，所以很可能出现指针运算过后指向的下一个地址和相同类型的另一指针指向的当前位置相等！具体如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br> <br>  <span class="hljs-type">int</span> a1 = <span class="hljs-number">1</span>;<br>  <span class="hljs-type">int</span> a2 = <span class="hljs-number">2</span>;<br> <br>  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function">  </span>&#123;<br>      <span class="hljs-type">int</span>* p1 = &amp;a1;<br>      <span class="hljs-type">int</span>* p2 = &amp;a2;<br>      <span class="hljs-type">int</span>* p3;<br> <br>      std::cout&lt;&lt;<span class="hljs-string">&quot;*p1 = &quot;</span>&lt;&lt;*p1&lt;&lt;<span class="hljs-string">&quot;,地址为：p1 = &quot;</span>&lt;&lt;p1&lt;&lt;std::endl;<br>      std::cout&lt;&lt;<span class="hljs-string">&quot;*p2 = &quot;</span>&lt;&lt;*p2&lt;&lt;<span class="hljs-string">&quot;,地址为：p2 = &quot;</span>&lt;&lt;p2&lt;&lt;std::endl;<br>      p3 = ++p1;<br>      <span class="hljs-keyword">if</span>(p2 == p3)&#123;<br>      ¦   std::cout&lt;&lt;<span class="hljs-string">&quot;*p3 = &quot;</span>&lt;&lt;*p3&lt;&lt;<span class="hljs-string">&quot;,地址为：p3 = &quot;</span>&lt;&lt;p3&lt;&lt;std::endl;<br>      &#125;<br> <br>      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  &#125;<br></code></pre></td></tr></table></figure><p>运行图如下所示：</p><img src="/2022/11/01/%E5%88%A4%E6%96%AD%E4%B8%A4%E4%B8%AA%E6%8C%87%E9%92%88%E7%9B%B8%E7%AD%89%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/bg1.png" class=""><h4 id="关于指针和引用"><a href="#关于指针和引用" class="headerlink" title="关于指针和引用"></a>关于指针和引用</h4><p>引用并非对象，它只是为一个已经存在的对象所起的别名而已，所以引用只能使用对象进行初始化(不能使用字面量初始化)，<br>引用的初始化过程并非是将对象的值拷贝给引用，而是绑定，程序将引用和它的初始值绑定在一起，一旦初始化完成，引用<br>将和它的初始值对象一直捆绑在一起，也正是因为引用无法重新解绑到另外一个对象，所以引用必须进行初始化操作！因为<br>引用不是对象，没有实际的地址，所以不能定义指向引用的指针 ！</p><p><strong>指针和引用的区别：</strong><br>指针和引用同为复合类型，都与内存中实际存在的对象有联系。指针”指向”内存中的某个对象，而引用”绑定到”内存中的某<br>个对象，它们都实现了对其他对象的间接访问，二者的区别主要有两方面：</p><p><em><strong>第一，指针本身就是一个对象，允许对指针赋值和拷贝，而且在指针的生命周期内它可以指向几个不同的对象；引用不是一<br>个对象，无法令引用重新绑定到另外一个对象。<br><br>第二，指针无须在定义时赋初值，和其他内置类型一样，在块作用域内定义的指针如果没有被初始化，也将拥有一个不确定<br>的值；引用则必须在定义时赋初值。</strong></em></p>]]></content>
    
    
    <categories>
      
      <category>C/C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vimrc</title>
    <link href="/2022/10/24/%E4%B8%AA%E4%BA%BAvim%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/"/>
    <url>/2022/10/24/%E4%B8%AA%E4%BA%BAvim%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="配置如下"><a href="#配置如下" class="headerlink" title="配置如下"></a><center>配置如下</h1><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br></pre></td><td class="code"><pre><code class="hljs 1c"><span class="hljs-string">&quot; All system-wide defaults are set in $VIMRUNTIME/debian.vim and sourced by</span><br><span class="hljs-string">&quot; the call to :runtime you can find below.If you wish to change any of those</span><br><span class="hljs-string">&quot; settings, you should do it in this file (/etc/vim/vimrc), since debian.vim</span><br><span class="hljs-string">&quot; will be overwritten everytime an upgrade of the vim packages is performed.</span><br><span class="hljs-string">&quot; It is recommended to make changes after sourcing debian.vim since it alters</span><br><span class="hljs-string">&quot; the value of the &#x27;compatible&#x27; option.</span><br><br>runtime! debian.vim<br><br><span class="hljs-string">&quot; Vim will load $VIMRUNTIME/defaults.vim if the user does not have a vimrc.</span><br><span class="hljs-string">&quot; This happens after /etc/vim/vimrc(.local) are loaded, so it will override</span><br><span class="hljs-string">&quot; any settings in these files.</span><br><span class="hljs-string">&quot; If you don&#x27;t want that to happen, uncomment the below line to prevent</span><br><span class="hljs-string">&quot; defaults.vim from being loaded.</span><br><span class="hljs-string">&quot; let g:skip_defaults_vim = 1</span><br><br><span class="hljs-string">&quot; Uncomment the next line to make Vim more Vi-compatible</span><br><span class="hljs-string">&quot; NOTE: debian.vim sets &#x27;nocompatible&#x27;.  Setting &#x27;compatible&#x27; changes numerous</span><br><span class="hljs-string">&quot; options, so any other options should be set AFTER setting &#x27;compatible&#x27;.</span><br><span class="hljs-string">&quot;set compatible</span><br><br><span class="hljs-string">&quot; Vim5 and later versions support syntax highlighting. Uncommenting the next</span><br><span class="hljs-string">&quot; line enables syntax highlighting by default.</span><br>if has(<span class="hljs-string">&quot;syntax&quot;</span>)<br>  syntax on<br>endif<br><br><span class="hljs-string">&quot; If using a dark background within the editing area and syntax highlighting</span><br><span class="hljs-string">&quot; turn on this option as well</span><br><span class="hljs-string">&quot;set background=dark</span><br><br><span class="hljs-string">&quot; Uncomment the following to have Vim jump to the last position when</span><br><span class="hljs-string">&quot; reopening a file</span><br><span class="hljs-string">&quot;au BufReadPost * if line(&quot;</span>&#x27;\&quot;&quot;) &gt; 1 &amp;&amp; line(&quot;&#x27;\<span class="hljs-string">&quot;&quot;</span>) &lt;= line(<span class="hljs-string">&quot;$&quot;</span>) <span class="hljs-string">| exe &quot;</span>normal! g&#x27;\&quot;&quot; | endif<br><br>&quot; Uncomment the following to have Vim load indentation rules and plugins<br>&quot; according to the detected filetype.<br>&quot;filetype plugin indent on<br><br>&quot; The following are commented out as they cause vim to behave a lot<br>&quot; differently from regular Vi. They are highly recommended though.<br>&quot;set showcmd&quot; Show (partial) command in status line.<br>&quot;set showmatch&quot; Show matching brackets.<br>&quot;set ignorecase&quot; Do case insensitive matching<br>&quot;set smartcase&quot; Do smart case matching<br>&quot;set incsearch&quot; Incremental search<br>&quot;set autowrite&quot; Automatically save before commands like :next and :make<br>&quot;set hidden&quot; Hide buffers when they are abandoned<br>&quot;set mouse=a&quot; Enable mouse usage (all modes)<br><br>&quot; Source a global configuration file if available<br>if filereadable(&quot;/etc/vim/vimrc.local&quot;)<br>  source /etc/vim/vimrc.local<br>endif<br><br>&quot;个人配置==================================================================================================&gt;<br>&quot;打开文件的编码设置<br>set fileencodings=cs-bom,utf-8,utf-16,gbk,big5,gb<span class="hljs-number">1803</span>0,latin1<br>&quot;开启鼠标<br>&quot;set mouse=a <br>&quot;前缀键&lt;leader&gt;默认为\ 使用下面命令将前缀键定义为逗号<br>let mapleader=&quot;,&quot;<br>&quot;设置行号<br>set nu<br>&quot;设置缩进格式<br>set autoindent &quot;自动缩进<br>set cindent<br>set ts=4 &quot;表示一个tab在屏幕上打印多少个空格长度，默认为8<br>&quot;set softtabstop=4<br>set shiftwidth=4<br>set expandtab<br><br>&quot;set cursorcolumn<br>&quot;set cursorline<br>set hlsearch<br>hi Search term=bold,reverse cterm=bold ctermfg=15 ctermbg=2 gui=bold guifg=bg guibg=DarkGreen<br><br>&quot;设置引号和括号自动补全<br>inoremap &#x27; &#x27;&#x27;&lt;ESC&gt;i<br>inoremap <span class="hljs-string">&quot; &quot;&quot;&lt;ESC&gt;i</span><br>inoremap ( ()&lt;ESC&gt;i<br>inoremap [ []&lt;ESC&gt;i<br><span class="hljs-string">&quot;数组初始化使用补全</span><br>inoremap &#123; &#123;&#125;&lt;ESC&gt;i<br><span class="hljs-string">&quot;方法括号补全</span><br>inoremap &#123;&lt;CR&gt; &#123;&#125;&lt;ESC&gt;i&lt;CR&gt;&lt;ESC&gt;O<br><span class="hljs-string">&quot;跳出括号等</span><br>inoremap &lt;tab&gt;&lt;space&gt; &lt;ESC&gt;&lt;space&gt;a<br><span class="hljs-string">&quot;插入模式下注释当前行</span><br>inoremap <span class="hljs-comment">// &lt;ESC&gt;0i//&lt;ESC&gt;</span><br><span class="hljs-string">&quot;删除当前行注释</span><br>nnoremap &lt;leader&gt;/ <span class="hljs-number">0</span>xx<br><br><span class="hljs-string">&quot;将crtl+d映射为插入模式下的删除当前行</span><br>inoremap &lt;c-d&gt; &lt;ESC&gt;dd i<br><br><span class="hljs-string">&quot;插件管理-----------------------------------------&gt;</span><br>call plug<span class="hljs-meta">#begin(&#x27;~/.vim/plugged&#x27;)</span><br>Plug &#x27;vim-airline/vim-airline&#x27;<br>Plug &#x27;ludovicchabant/vim-gutentags&#x27;<br>Plug &#x27;ycm-core/YouCompleteMe&#x27;<br>Plug  &#x27;Yggdroot/indentLine&#x27;<br>Plug &#x27;skywind<span class="hljs-number">3000</span>/asyncrun.vim&#x27;<br>Plug &#x27;preservim/nerdtree&#x27;<br>Plug &#x27;iamcco/markdown-preview.nvim&#x27;, &#123; &#x27;do&#x27;: &#123; -&gt; mkdp<span class="hljs-meta">#util#install() &#125;, &#x27;for&#x27;: [&#x27;markdown&#x27;, &#x27;vim-plug&#x27;]&#125;</span><br><span class="hljs-string">&quot;Plug &#x27;puremourning/vimspector&#x27;</span><br><br><br>call plug<span class="hljs-meta">#end()</span><br><span class="hljs-string">&quot;-------------------------------------------------&gt;</span><br><br><span class="hljs-string">&quot;文件插件类型</span><br>filetype plugin indent on<br><br><span class="hljs-string">&quot;vim-gutentags插件设置----------------------------&gt;</span><br>set tags=./.tags;,.tags<br><span class="hljs-string">&quot;gutentags搜索工程目录的标志,碰到这些文件或者目录名就停止向上一级递归</span><br>let g:gutentags_project_root=[&#x27;.root&#x27;,&#x27;.svn&#x27;,&#x27;.git&#x27;,&#x27;.hg&#x27;,&#x27;.project&#x27;]<br><span class="hljs-string">&quot;所生成的数据的文件名称</span><br>let g:gutentags_ctags_tagfile=&#x27;.tags&#x27;<br><span class="hljs-string">&quot;将自动生成的tags文件全部放入~/.cache/tags/目录中，避免污染工程目录</span><br>let s:vim_tags=expand(&#x27;~/.cache/tags&#x27;)<br>let g:gutentags_cache_dir=s:vim_tags<br><span class="hljs-string">&quot;配置ctags的参数</span><br>let g:gutentags_ctags_extra_args=[&#x27;--fields=+niazS&#x27;,&#x27;--extra=+q&#x27;]<br>let g:gutentags_ctags_extra_args+=[&#x27;--c++-kinds=+px&#x27;]<br>let g:gutentags_ctags_extra_args+=[&#x27;--c-kinds=+px&#x27;]<br>let g:gutentags_ctags_extra_args+=[&#x27;--output-format=e-ctags&#x27;]<br><span class="hljs-string">&quot;检测~/.cache/tags,不存在就新建</span><br>if !isdirectory(s:vim_tags)<br>silent! call mkdir(s:vim_tags,&#x27;p&#x27;)<br>endif<br><br><span class="hljs-string">&quot;--------------------------------------------------&gt;</span><br><span class="hljs-string">&quot;YouCompleteMe代码补全插件设置-----------------------------------------&gt;</span><br><span class="hljs-string">&quot;设置补全窗口的背景色</span><br>highlight PMenu ctermfg=<span class="hljs-number">0</span> ctermbg=<span class="hljs-number">242</span> guifg=black guibg=darkgrey<br>highlight PMenuSel ctermfg=<span class="hljs-number">242</span> ctermbg=<span class="hljs-number">8</span> guifg=darkgrey guibg=black<br><br>let g:ycm_add_preview_to_completeopt = <span class="hljs-number">0</span><br>let g:ycm_show_diagnostics_ui = <span class="hljs-number">0</span><br>let g:ycm_server_log_level = &#x27;info&#x27;<br>let g:ycm_min_num_identifier_candidate_chars = <span class="hljs-number">2</span><br>let g:ycm_collect_identifiers_from_comments_and_strings = <span class="hljs-number">1</span><br>let g:ycm_complete_in_strings=<span class="hljs-number">1</span><br>let g:ycm_key_invoke_completion = &#x27;&lt;c-z&gt;&#x27;<br>set completeopt=menu,menuone<br><br>noremap &lt;c-z&gt; &lt;NOP&gt;<br><br>let g:ycm_semantic_triggers =  &#123;<br>\ &#x27;c,cpp,python,java,go,erlang,perl&#x27;: [&#x27;re!\w&#123;2&#125;&#x27;],<br>\ &#x27;cs,lua,javascript&#x27;: [&#x27;re!\w&#123;2&#125;&#x27;],<br>\ &#125;<br><br>let g:ycm_filetype_whitelist = &#123; <br>\ <span class="hljs-string">&quot;c&quot;</span>:<span class="hljs-number">1</span>,<br>\ <span class="hljs-string">&quot;cpp&quot;</span>:<span class="hljs-number">1</span>, <br>\ <span class="hljs-string">&quot;objc&quot;</span>:<span class="hljs-number">1</span>,<br>\ <span class="hljs-string">&quot;sh&quot;</span>:<span class="hljs-number">1</span>,<br>\ <span class="hljs-string">&quot;zsh&quot;</span>:<span class="hljs-number">1</span>,<br>\ <span class="hljs-string">&quot;zimbu&quot;</span>:<span class="hljs-number">1</span>,<br>\ &#125;<br><br><br><span class="hljs-string">&quot;-----------------------------------------------------------------------&gt;</span><br><br><span class="hljs-string">&quot;indentLine插件设置-----------------------------------------------------------------&gt;</span><br>let g:indentLine_char =  &#x27;¦&#x27;<span class="hljs-string">&quot; 设置缩进线字符，也可以为 &#x27;|&#x27;, &#x27;┆&#x27;, &#x27;┊&#x27; 等</span><br>let g:indentLine_conceallevel = <span class="hljs-number">2</span><span class="hljs-string">&quot; 使插件正常运行</span><br><br><span class="hljs-string">&quot;-----------------------------------------------------------------------------------&gt;</span><br><br><br><span class="hljs-string">&quot;asyncrun插件设置-----------------------------------------------------------------&gt;</span><br>let g:asyncrun_rootmarks = [&#x27;.svn&#x27;, &#x27;.git&#x27;, &#x27;.root&#x27;, &#x27;_darcs&#x27;, &#x27;build.xml&#x27;]<br>let g:asyncrun_open=<span class="hljs-number">10</span> <span class="hljs-string">&quot;自动打开quick window窗口，高度为10</span><br>let g:asyncrun_bell=<span class="hljs-number">1</span> <span class="hljs-string">&quot;任务结束响铃提醒</span><br><span class="hljs-string">&quot;设置F1打开关闭quickfix窗口</span><br>noremap &lt;F1&gt; :call asyncrun<span class="hljs-meta">#quickfix_toggle(6)&lt;cr&gt; </span><br><span class="hljs-string">&quot;设置F2单文件：编译(C文件)</span><br>nnoremap &lt;silent&gt; &lt;F2&gt; :AsyncRun! gcc -Wall -O2 <span class="hljs-string">&quot;$(VIM_FILEPATH)&quot;</span> -o <span class="hljs-string">&quot;$(VIM_FILEDIR)/$(VIM_FILENOEXT)&quot;</span> &lt;cr&gt;<br><span class="hljs-string">&quot;设置F3单文件：编译debug版本（C++）</span><br>nnoremap &lt;silent&gt; &lt;F3&gt; :AsyncRun! g++ -g <span class="hljs-string">&quot;$(VIM_FILEPATH)&quot;</span> -o <span class="hljs-string">&quot;$(VIM_FILEDIR)/$(VIM_FILENOEXT)&quot;</span>&lt;cr&gt;<br><span class="hljs-string">&quot;设置F4单文件：编译正常版本（C++）</span><br>nnoremap &lt;silent&gt; &lt;F4&gt; :AsyncRun! g++ -O3 <span class="hljs-string">&quot;$(VIM_FILEPATH)&quot;</span> -o <span class="hljs-string">&quot;$(VIM_FILEDIR)/$(VIM_FILENOEXT)&quot;</span>&lt;cr&gt;<br><span class="hljs-string">&quot;设置F5单文件：运行</span><br><span class="hljs-string">&quot;nnoremap &lt;silent&gt; &lt;F5&gt; :AsyncRun -raw -cwd=$(VIM_FILEDIR) \&quot;</span>$(VIM_FILEDIR)/$(VIM_FILENOEXT)<span class="hljs-string">&quot; &lt;cr&gt;</span><br>nnoremap &lt;silent&gt; &lt;F5&gt; :AsyncRun! -mode=term -pos=right -cols=<span class="hljs-number">60</span> <span class="hljs-string">&quot;$(VIM_PATHNOEXT)&quot;</span>&lt;cr&gt;<br><br><span class="hljs-string">&quot;设置F7项目：编译</span><br>nnoremap &lt;silent&gt; &lt;F7&gt; :AsyncRun! -cwd=&lt;root&gt; make &lt;cr&gt;<br><span class="hljs-string">&quot;设置F8项目：运行</span><br>nnoremap &lt;silent&gt; &lt;F8&gt; :AsyncRun! -cwd=&lt;root&gt; -raw make run &lt;cr&gt;<br><span class="hljs-string">&quot;退出运行时的终端窗口terminal</span><br>nnoremap &lt;leader&gt;w :exit&lt;cr&gt;<br><br><span class="hljs-string">&quot;--------------------------------------------------------------------------------&gt;&quot;</span><br><br><span class="hljs-string">&quot;NERDTree插件设置-----------------------------------------------------------------&gt;</span><br><span class="hljs-string">&quot;设置目录箭头</span><br>let g:NERDTreeDirArrowExpandable = &#x27;⇨⇨⇨&#x27;<br>let g:NERDTreeDirArrowCollapsible = &#x27;➤➤➤&#x27;<br><span class="hljs-string">&quot; 在 vim 启动的时候默认开启 NERDTree（autocmd 可以缩写为 au）</span><br><span class="hljs-string">&quot;autocmd VimEnter * NERDTree</span><br><span class="hljs-string">&quot;定位当前文件的位置，类似于eclipse的link with edited</span><br>nnoremap &lt;C-f&gt; :NERDTreeFind&lt;CR&gt;<br><span class="hljs-string">&quot;打开关闭目录树</span><br>nnoremap &lt;C-n&gt; :NERDTreeToggle&lt;CR&gt;<br><span class="hljs-string">&quot;如果 NERDTree 是唯一选项卡中剩下的唯一窗口，则退出 Vim</span><br>autocmd BufEnter * if tabpagenr(&#x27;$&#x27;) == <span class="hljs-number">1</span> <span class="hljs-meta">&amp;&amp; winnr(&#x27;$&#x27;) == 1 &amp;&amp; exists(&#x27;b:NERDTree&#x27;) &amp;&amp; b:NERDTree.isTabTree() | quit | endif</span><br><span class="hljs-string">&quot;如果 NERDTree 是其中唯一剩余的窗口，请关闭选项卡</span><br>autocmd BufEnter * if winnr(&#x27;$&#x27;) == <span class="hljs-number">1</span> <span class="hljs-meta">&amp;&amp; exists(&#x27;b:NERDTree&#x27;) &amp;&amp; b:NERDTree.isTabTree() | quit | endif</span><br><span class="hljs-string">&quot;关闭当前标签页</span><br>nnoremap &lt;leader&gt;c :tabc&lt;CR&gt;<br><span class="hljs-string">&quot;关闭其它标签页</span><br>nnoremap &lt;leader&gt;o :tabo&lt;CR&gt;<br><span class="hljs-string">&quot;前一个tab标签页</span><br>nnoremap &lt;leader&gt;m :tabp&lt;CR&gt;<br><span class="hljs-string">&quot;下一个标签页</span><br>nnoremap &lt;leader&gt;n :tabn&lt;CR&gt;<br><br><span class="hljs-string">&quot;---------------------------------------------------------------------------------&gt;&quot;</span><br><br><span class="hljs-string">&quot;vimspector插件设置-----------------------------------------------------------------&gt;</span><br><span class="hljs-string">&quot;F5 debugger/ Shift F5 stop debugger/ Ctrl+Shift+F5 restart debugger</span><br><span class="hljs-string">&quot;F6 pause debugger</span><br><span class="hljs-string">&quot;F9 Toggle line breakpoint on the current line</span><br><span class="hljs-string">&quot;Shift F9 Add a function breakpoint for the expression under cursor</span><br><span class="hljs-string">&quot;F10 Step Over</span><br><span class="hljs-string">&quot;F11 Step into</span><br><span class="hljs-string">&quot;Shift F11 Step out of current function scope</span><br><span class="hljs-string">&quot;let g:vimspector_enable_mappings = &#x27;VISUAL_STUDIO&#x27;</span><br><span class="hljs-string">&quot;nnoremap &lt;leader&gt;e :VimspectorReset&lt;CR&gt;</span><br><span class="hljs-string">&quot;---------------------------------------------------------------------------------&gt;&quot;</span><br><br><span class="hljs-string">&quot;vim8自带的Termdebug插件设置-----------------------------------------------------------------&gt;</span><br><span class="hljs-string">&quot;F6进入debug当前文件模式</span><br>nnoremap &lt;silent&gt; &lt;F6&gt; :packadd termdebug&lt;cr&gt;:Termdebug %:r&lt;cr&gt;<br><br><span class="hljs-string">&quot;---------------------------------------------------------------------------------&gt;&quot;</span><br><br><span class="hljs-string">&quot;vim8使用CGDB进行调试-----------------------------------------------------------------&gt;</span><br>nnoremap &lt;space&gt;cd :!cgdb %:r&lt;cr&gt;<br><span class="hljs-string">&quot;---------------------------------------------------------------------------------&gt;&quot;</span><br><br><br><span class="hljs-string">&quot;Markdownd插件设置----------------------------------------------------------------&gt;</span><br>imap &lt;C-s&gt; &lt;Plug&gt;MarkdownPreview<br><span class="hljs-string">&quot;---------------------------------------------------------------------------------&gt;&quot;</span><br><br><br><span class="hljs-string">&quot;---------------------------------------------------------------------------------&gt;&quot;</span><br><br><span class="hljs-string">&quot;---------------------------------------------------------------------------------&gt;&quot;</span><br><span class="hljs-string">&quot;====================================================================================================================&gt;</span><br><br><br></code></pre></td></tr></table></figure><img src="/2022/10/24/%E4%B8%AA%E4%BA%BAvim%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/vimrc1.png" class=""><img src="/2022/10/24/%E4%B8%AA%E4%BA%BAvim%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/vimrc2.png" class=""><img src="/2022/10/24/%E4%B8%AA%E4%BA%BAvim%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/vimrc3.png" class=""><img src="/2022/10/24/%E4%B8%AA%E4%BA%BAvim%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/vimrc4.png" class=""><img src="/2022/10/24/%E4%B8%AA%E4%BA%BAvim%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/vimrc5.png" class="">]]></content>
    
    
    <categories>
      
      <category>vim</category>
      
    </categories>
    
    
    <tags>
      
      <tag>个人配置</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
