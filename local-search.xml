<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>linux多进程(一)</title>
    <link href="/2023/02/02/linux%E5%A4%9A%E8%BF%9B%E7%A8%8B-%E4%B8%80/"/>
    <url>/2023/02/02/linux%E5%A4%9A%E8%BF%9B%E7%A8%8B-%E4%B8%80/</url>
    
    <content type="html"><![CDATA[<h2 id="进程的概念"><a href="#进程的概念" class="headerlink" title="进程的概念"></a>进程的概念</h2><p>进程是操作系统结构的基础。进程是一个具有独立功能的程序对某个数据集合在处理机上的执行过程，进程也是作为<br>资源分配的一个基本单位。linux作为一个多用户、多任务的操作系统，必定支持多进程。多进程也是现代操作系统的<br>基本特征之一，操作系统在裸机硬件层面之上提供了更为简单、可靠、安全、高效的功能，它的首要功能就是管理和<br>协调各种计算机系统资源，包括物理资源和虚拟的资源。为了提高计算机系统中各种资源的利用效率，现代操作系统<br>广泛采用了多进程技术，以使多种硬件资源能够并行的工作，程序的并发执行以及多任务共享资源成为现代操作系统<br>的重要特点。为了更好的理解进程的概念，需要明确程序与进程间的差异性：    </p><blockquote><ul><li>(1) 进程和程序是相辅相成的。程序是进程的组成部分之一，一个进程的运行目标是执行它所对应的程序，如果<br>没有程序，进程就失去了它存在的意义。一个程序也可以由多个进程组成。</li><li>(2) 进程是一个动态的概念，而程序则是一个静态概念。程序是指令的有序集合，其本身没有任何运行的含义，<br>是一个静态的概念。而进程是程序在处理机器上的一次执行过程，它是一个动态的概念，动态的产生、执行<br>然后消亡，因此进程的存在也是暂时的。</li><li>(3) 进程具有并行性特征，而程序则没有。进程具有并行特征的两个方面：独立性和异步性。独立性是指，进程<br>是一个相对完整的资源分配单位。异步性是指，每个进程按照各自独立的、不可预知的速度向前推进。显然<br>程序并不反映执行过程，所以不具有并行性。</li></ul></blockquote><h2 id="进程的描述"><a href="#进程的描述" class="headerlink" title="进程的描述"></a>进程的描述</h2><p>从构成要素描述进程的话可以分为三个部分：进程控制块（Process Control Block）PCB；相关的程序段；操作的数<br>据集合。其中进程控制块主要包括进程的一些描述信息、资源信息以及控制信息等。系统为每个进程设置一个PCB,它<br>是标识和描述进程存在及相关特性的数据块，是进程存在的唯一标识，也是进程动态特征的集中反映。当创建一个进<br>程时，系统首先创建其PCB，然后根据PCB中的信息对进程实施有效的管理和控制。当一个进程完成其功能之后，系统<br>则释放PCB，进程也随之消亡。进程控制块的具体内容随操作系统的不同而有所区别，但主要都应包括以下的信息：  </p><blockquote><ul><li>(1)进程标识： 每个进程都有系统唯一的进程名称或标识号。在识别一个进程时，进程名或标识号就代表该进程。</li><li>(2)状态信息： 指明进程当前所处的状态，作为进程调度、分配处理机的依据。进程在活动期间有三种基本的状<br>态，可分为就绪状态、执行状态和等待状态。一个进程在任意时刻只能具有三种状态中的一种。执行状态表<br>示该进程当前占有处理机，正在处理机上调度执行；就绪状态表示该进程已经得到了除处理机之外的全部资<br>源，准备占有处理机；等待状态则表示进程因某种原因而暂时不能占有处理机。在具体的系统中，为了最大<br>可能的提高资源的利用率，可能会引进某些状态或者进一步细分某些状态。</li><li>(3)进程的优先级： 进程优先级是选取进程占有处理机的重要依据，一般根据进程的轻重缓急程度为进程指定一<br>个优先级，包括静态或者动态的优先级。</li><li>(4)CPU现场信息： 当进程状态变化时（如一个进程放弃使用处理机），它需要将当时的CPU现场保护到内存中，<br>以便再次占用处理机时恢复到当时运行的状态。这些信息包括各种通用寄存器、程序计数器、程序状态字等。</li><li>(5)资源清单： 每个进程在运行时，除了需要内存外，还需要其它资源，如I&#x2F;O设备、外存、数据区等。</li><li>(6)队列指针： 用于将处于同一状态或者具有家族关系的进程链接成一个队列，在该单元中存放下一进程PCB首<br>地址。</li><li>(7)其它： 如计时信息、记账信息、通信信息等。</li></ul></blockquote><p>linux中的每个进程都由一个task_struct数据结构来表示。task_struct其实就是通常意义上的进程控制块pcb，或者<br>称为进程描述符，系统正是通过task_struct结构来对进程进行有效管理和控制的。当系统创建一个进程时，linux为<br>新的进程分配一个task_struct结构，进程结束时，又收回其task_struct结构，进程也随之消亡。分配给进程的结构<br>task_struct可以被内核中的许多模块（如调度程序、资源分配程序、中断处理程序等）访问，并常驻于内存.在linux<br>4.14内核中，linux为每个新创建的进程动态的分配一个task_struct结构，系统所能允许的最大进程数是由机器所拥<br>有的物理内存的大小决定的，这是对以前版本的改进。linux支持两种进程：普通进程和实时进程。实时进程具有一定<br>程度上的紧迫性，应该有一个短的响应时间，更重要的是，这个响应时间应该有很小的变化；而普通进程则没有这种限<br>制。因此，调度程序需要区别对待这两类进程。<br>task_struct结构包含进程的全部信息，数据结构比较庞大，按其功能主要分为几个大的部分：进程标识符信息；进程<br>调度信息；进程间通信信息；时间和定时器信息；进程链接信息；文件系统信息；虚拟内存信息；处理器特定信息以<br>及其它信息。    </p><blockquote><p>(1)进程标识符信息</p><blockquote><p> 进程标识符信息包括进程标识符、用户标识符、阻止标识符等一些信息。每个进程都有一个唯一的进程标识符PID<br>，内核通过这个标识符来识别不同的进程，同时，进程标识符也是内核提供给用户程序的接口。PID是32位的无符<br>号整数，存放在进程描述符的PID域中，它被顺序编号，新创建进程的PID通常是前一个进程的PID+1，为了与16<br>位硬件平台的传统UNIX系统保持兼容，linux允许的最大PID号是32767.当内核在系统中创建第32768个进程时，就<br>必须重新开始使用闲置的PID号。此外，每个进程都属于某个用户和某个用户组。进程描述符中定义了多种类别的<br>用户标识符和组标识符，比如用户标识符uid、有效用户标识符euid、组标识符gid、有效组标识符egid等。这些<br>都是简单的数字，主要用于系统的安全控制。   </p></blockquote><p>(2)进程调度信息</p><blockquote><p>调度程序利用这些信息来决定系统中哪个进程最迫切需要运行，并采用适当的策略来保证系统运转的公平性和高<br>效性。这些信息主要包括调度标志、调度的策略、进程的类别、进程的优先级、进程状态。其中可能的进程状态<br>有：可运行状态、可中断的等待状态、不可中断的等待状态、暂停状态和僵死状态。</p></blockquote><p>(3)进程间通信信息</p><blockquote><p>在多任务编程环境中，进程之间必然会发生多种多样的合作、协调等。因此进程间就必须进行通信，来交换信息<br>和传递数据。linux支持多种不同形式的进程间通信机制，如信号、管道，也支持System V进程间通信机制，如信<br>号量消息队列和共享内存等。进程描述符中主要有这些域与进程通信有关：sig，信号处理函数，包括自定义的和<br>系统默认的处理函数；blocked，进程所能接收信号的位掩码；sigmask_lock，信号掩码的自旋锁；semundo，进<br>程信号量的取消操作队列，进程每操作一次信号量，都生成一个对此次操作的取消操作，这些属于同一进程的取<br>消操作组成一个链表，当进程异常终止时，内核就会执行取消操作；semsleeping，与信号量相关的等待队列，每<br>一信号量集合对应一个等待队列。</p></blockquote><p>(4)进程链接信息</p><blockquote><p>linux系统中所有进程都是相互联系的。除了初始化进程init外，其它所有进程都有一个父进程。可以通过fork<br>或clone系统调用来创建子进程，除了进程标识符pid等必要的信息外，子进程的task_struct结构中的绝大部分信<br>息都是从父进程中复制过来的。每个进程对应的task_struct结构中都包含有指向其父进程和兄弟进程（具有相同<br>父进程）以及子进程的指针。有了这些指针，进程之间的通信、协作就更加方便了。进程的task_struct结构中主<br>要有下面这些域记录了进程间的各种关系。next_task、prev_task是用于链入进程双向链表的前后指针，系统的<br>所有进程组成一个双向循环链表。p_opptr、p_pptr、p_cptr、p_ysptr、p_osptr分别表示指向祖先进程、父进程<br>、子进程、兄弟进程的指针。pidhash_next、pidhash_prev是用于链入进程哈希表的前后指针。</p></blockquote><p>(5)时间和定时器信息</p><blockquote><p>内核需要记录进程的创建时间以及在其生命周期中消耗的CPU时间。进程耗费的CPU时间由两部分组成：一是在用<br>户态（用户模式）下耗费的时间；二是在内核态（内核模式）下耗费的时间。每个时钟滴答，也就是每个时钟中<br>断，内核都要更新当前进程耗费的时间。linux支持与进程相关的多种间隔定时器，包括实时定时器、虚拟定时器<br>和概况定时器。进程可以通过系统调用来设定定时器，以便在定时器到期后向它发送信号。这些定时器可以是一<br>次性的或者周期性的。</p></blockquote><p>(6)文件系统信息</p><blockquote><p>进程经常会访问文件系统资源，打开或者关闭文件，linux内核要对进程使用文件的情况进行记录。task_struct<br>结构中有两个数据结构用于描述进程与文件相关的信息。其中。fs域是指向fs_struct结构的指针，fs_struct结<br>构中描述了两个VFS索引节点，这两个索引节点叫作root和pwd，分别指向进程的可执行映像所对应的主目录和当<br>前工作目录。files域用来记录进程打开文件的文件描述符。</p></blockquote><p>(7)虚拟内存信息</p><blockquote><p>linux采用按需分页的策略来解决进程的内存需求，当物理内存不足时，linux内存管理系统需要把内存中的部分页<br>面交换到外存。每个进程都有自己的虚拟地址空间（内核线程除外），用mm_struct来描述，其中包括一个指向<br>若干个虚拟块的虚拟队列。另外，linux内核还引入了另一个域active_mm，它指向活动地址空间，但这一空间并<br>不为其进程所拥有，通常为内核线程所使用。内核线程与用户进程相比不需要mm_struct结构：当用户进程切换到<br>内核线程时，内核线程可以直接借用进程的页表，无须重新加载独立的页表。内核线程用active_mm指针指向所借<br>用进程的mm_struct结构。</p></blockquote><p>(8)处理器特定信息</p><blockquote><p>进程可以看作是系统当前执行状态的综合。进程运行时，它将使用处理器的寄存器以及堆栈等。进程被挂起时，<br>进程的上下文，即所有与CPU相关的处理机状态必须保存在它的task_struct结构中。当进程被调度重新运行时，<br>再从其中恢复这些运行环境，重新设定上下文，也就是恢复这些寄存器和堆栈的值。    </p></blockquote></blockquote><h4 id="进程的标识符"><a href="#进程的标识符" class="headerlink" title="进程的标识符"></a>进程的标识符</h4><p>进程标识符也称进程识别码（Process Identification）即PID，PID是进程运行时系统随机分配的，在进程运行时，<br>PID是不会改变的，进程终止后，PID就会被系统回收，以后可能会被分配给新运行的进程。进程ID在系统中其实就是<br>一个无符号整型数值，类型是pid_t，该类型定义在&#x2F;usr&#x2F;include&#x2F;sys&#x2F;types.h中，定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> __pid_t_defined</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">__pid_t</span> <span class="hljs-type">pid_t</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> __pid_t_defined</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><p>可以看pid_t类型其实是__pid_t类型。而__pid_t在&#x2F;usr&#x2F;include&#x2F;bits&#x2F;types.h中被定义为__PID_T_TYPE类型。<br>在文件&#x2F;usr&#x2F;include&#x2F;bits&#x2F;typesizes.h中可以看到这样的定义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> __PID_T_TYPE  __S32_TYPE</span><br></code></pre></td></tr></table></figure><p>可以看到__PID_T_TYPE被定义为__S32_TYPE类型。在文件&#x2F;usr&#x2F;include&#x2F;bits&#x2F;types.h中，可以找到这样的定义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> __S32_TYPE  int</span><br></code></pre></td></tr></table></figure><p>可以看到实际上pid_t就是一个int型。在终端下可以使用命令ps -e来查看所有的进程id，譬如:  </p><img src="/2023/02/02/linux%E5%A4%9A%E8%BF%9B%E7%A8%8B-%E4%B8%80/1.png" class=""><p>-e表示显示所有进程，也可以使用-A，含义一样。上图第一列为进程ID，即PID，最后一列是进程的名字,其和所对应<br>的程序名相同，因此会出现重名的进程，虽然会有重名进程的出现，但是其PID是不同的，因此PID才是一个进程的标<br>识符。获取当前进程的pid的函数为getpid，该函数使用示例如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//使用示例：  </span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">pid_t</span> pid = <span class="hljs-built_in">getpid</span>();<br>    std::cout&lt;&lt;<span class="hljs-string">&quot;pid = &quot;</span>&lt;&lt;pid&lt;&lt;std::endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;  <br>   <br></code></pre></td></tr></table></figure><h4 id="PID文件"><a href="#PID文件" class="headerlink" title="PID文件"></a>PID文件</h4><p>在系统的&#x2F;var&#x2F;run目录下，会看到很多后缀为*.pid的文件。往往新安装的程序在运行后会在&#x2F;var&#x2F;run目录下产生自<br>己的pid文件。pid文件为文本文件，内容只有一行，记录该进程的id。这些pid文件的作用是防止进程启动多个副本。<br>只有获得相应pid文件写入权限的进程才能正常启动，并把自身的pid写入该文件中。pid文件位于固定路径&#x2F;var&#x2F;run<br>，并且文件名也是固定的，即进程名.pid。<br>通常有两种方法配合pid文件来实现进程的重复启动。一种是文件加锁法，另一种是pid读写法。文件加锁法的基本思<br>路是进程运行后会给pid文件加一个文件锁，只有获得该锁的进程才有写入权限（F_WRLCK），以后其它试图获得该锁<br>的进程会自动退出，给文件加锁的函数是fcntl()函数，如果成功锁定，进程则继续往下执行，如果锁定不成功，说<br>明已经有同样的进程在运行了，该进程就退出。pid读写法则是先启动的进程往pid文件中写入自己的进程id号，然后<br>其它进程判断该pid文件中是否已有数据了。<br>使用pid文件判断进程是否运行示例：</p><img src="/2023/02/02/linux%E5%A4%9A%E8%BF%9B%E7%A8%8B-%E4%B8%80/2.png" class=""><img src="/2023/02/02/linux%E5%A4%9A%E8%BF%9B%E7%A8%8B-%E4%B8%80/3.png" class=""><img src="/2023/02/02/linux%E5%A4%9A%E8%BF%9B%E7%A8%8B-%E4%B8%80/4.png" class=""><p>check_pid是一个自定义函数，用来检测pid文件是否存在，然后根据pid文件内容判断进程是否运行。整个程序在刚刚<br>启动的时候会创建一个test_pid.pid文件，并把本进程的进程号写入该文件中,程序结束的时候，也就是进程退出时会<br>删除pid文件。check_pid中，使用stat函数判断文件是否存在，并用fopen函数又进一步做了保险判断，如果存在，就<br>读取该文件中的进程号，然后通过kill函数检测该进程是否在运行。kill函数的第二个参数为要发送给内核的信号代码<br>，如果为0，则表示没有送出任何信号，但是系统会执行错误检查。通常会利用sig值为0来检验某个进程是否仍在执行。  </p><h2 id="进程的创建"><a href="#进程的创建" class="headerlink" title="进程的创建"></a>进程的创建</h2><h3 id="使用fork创建"><a href="#使用fork创建" class="headerlink" title="使用fork创建"></a>使用fork创建</h3><p>linux可以通过执行系统调用函数fork来创建新的进程，由fork创建的新进程称为子进程，该函数被调用一次，但返回<br>两次。两次返回的区别是子进程的返回值是0，而父进程的返回值是子进程的PID，子进程和父进程继续执行fork之后<br>的指令。父进程和子进程几乎是等同的——它们具有相同的变量值（但变量内存并不共享），打开的文件也都相同，还<br>有其它一些相同属性。如果父进程改变了变量的值，子进程将不会看到这个变化。实际上，子进程是父进程的一个复<br>制，但它们并不共享内存。而且，linux并不完全复制内存页，而是采用了写时复制（copy on write）的技术，这些<br>内存区域由父、子进程共享，而且内核将它们的许可权限改为只读，当有进程试图改修这些区域时，内核就为相关部<br>分做一下复制。<br>系统调用函数fork的声明如下：  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">pid_t</span> <span class="hljs-title">fork</span><span class="hljs-params">()</span></span>;<br></code></pre></td></tr></table></figure><p>该函数将创建一个子进程。如果成功，在父进程的程序中将返回子进程的进程id，即pid值；在子进程中函数返回0；<br>如果失败，则在父进程程序中返回-1，并且可以通过errno得到错误码。一个进程成功调用fork函数后，系统先给新<br>的进程分配资源，例如存储数据和代码的空间。然后把原来的进程的所有值都复制到新的进程中，只有少数值与原来<br>的进程的值不同，相当于克隆了一个自己。代码示例如下：   </p><img src="/2023/02/02/linux%E5%A4%9A%E8%BF%9B%E7%A8%8B-%E4%B8%80/5.png" class=""><p>通过示例代码可以看到，父进程和子进程的pid是不同的，说明是两个不同的进程。在语句cpid&#x3D;fork()之前，只有一<br>个进程（即父进程）在执行这段代码，但在这条语句之后，就变成两个进程在执行了，这两个进程近乎完全相同，将<br>要执行的下一条语句都是if(cpid &lt; 0)判断，父进程和子进程都会执行该语句，并根据结果各自前进。父子进程中的<br>cpid不同这和fork函数的特性有关。fork调用的神奇之处就是它仅被调用一次，但却能够返回两次。父进程fork返回<br>的是子进程的pid，可以看到父进程中打印出的cpid是子进程的进程id，而子进程中的该值为0。另外，count因为在<br>父子进程中各执行了count++，所以会输出两次count &#x3D; 1。子进程创建成功后，系统中就会出现两个基本相同的进程<br>这两个进程没有固定的先后执行顺序，哪个进程先执行要看操作系统的进程调度策略。</p><h3 id="使用exec创建"><a href="#使用exec创建" class="headerlink" title="使用exec创建"></a>使用exec创建</h3><p>exec使用被执行的程序（新的目标程序）替换调用它的程序（调用exec的程序）。相对于fork函数会创建一个新的进<br>程，产生一个新的pid，exec会使用目标程序替换当前的进程，并且pid不变。exec()函数族总共6个，声明如下：  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">execl</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *path , <span class="hljs-type">const</span> <span class="hljs-type">char</span> *arg , ...)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">execlp</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *file , <span class="hljs-type">const</span> <span class="hljs-type">char</span> *arg , ...)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">execle</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *path , <span class="hljs-type">const</span> <span class="hljs-type">char</span> *arg , ... , <span class="hljs-type">char</span> *<span class="hljs-type">const</span> envp[])</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">execv</span><span class="hljs-params">(cosnt <span class="hljs-type">char</span> *path , <span class="hljs-type">char</span> *<span class="hljs-type">const</span> argv[])</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">execvp</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *file , <span class="hljs-type">char</span> *<span class="hljs-type">const</span> argv[])</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">execvpe</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *file , <span class="hljs-type">char</span> *<span class="hljs-type">const</span> argv[] , <span class="hljs-type">char</span> *<span class="hljs-type">const</span> anvp[])</span></span>;<br></code></pre></td></tr></table></figure><h4 id="1-execl函数"><a href="#1-execl函数" class="headerlink" title="1.execl函数"></a>1.execl函数</h4><p>函数execl声明如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">execl</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *path , <span class="hljs-type">const</span> <span class="hljs-type">char</span> *arg , ...)</span></span>;<br></code></pre></td></tr></table></figure><p>其中，参数path指向要执行的文件路径（可以是命令的全路径、执行程序的全路径或脚本文件的全路径）；后面的参<br>数arg以及之后的省略号代表执行该程序时传递的参数列表，并且第一个被认为是argv[0]（即path后面的参数const<br>char *arg），第二个被认为是argv[1 ]….相当于main函数中的argv，main函数中的argv[0]是程序的名称，程序<br>所需要的参数是从argv[1]才开始获取的，execl的argv[0]也是按照此习惯设计，即argv[1]才是传给execl要启动的<br>程序的第一个参数，argv[0]可以只写个程序名（对于大多数命令程序来说没什么作用，随便写一个字符串也可以，<br>但不要写NULL，写NULL就认为参数列表就此结束了，而对于自定义程序，则要视情况而定），最后一个参数必须使用<br>空指针NULL结束。函数成功时不返回值，失败则返回-1，失败原因存于errno中，可通过perror()打印。另外需要注<br>意的是，对于系统命令程序，如pwd命令，argv[0]是必须有的，但其值可以是一个无意义的字符串。<br>示例：使用execl执行不带参数的命令程序pwd   </p><img src="/2023/02/02/linux%E5%A4%9A%E8%BF%9B%E7%A8%8B-%E4%B8%80/6.png" class=""><p>程序打印当前路径，和单独执行pwd命令是一样的，虽然pwd命令不带参数，但使用execl执行的时候，依然需要argv[0]<br>这个选项，不可为NULL。<br>使用execl执行可带参数的命令，ls:  </p><img src="/2023/02/02/linux%E5%A4%9A%E8%BF%9B%E7%A8%8B-%E4%B8%80/7.png" class=""><img src="/2023/02/02/linux%E5%A4%9A%E8%BF%9B%E7%A8%8B-%E4%B8%80/8.png" class=""><p>通过上面程序的运行结果比较，可以看到execl的第二个参数,即argv[0]没什么用处，即使随便输入一个字符串，程序<br>效果也是一样的。说明对于execl函数，只要提供了程序的全路径和argv[1]开始的参数信息就可以了。<br>调用自定义程序示例：  </p><p>实现自定义程序  </p><img src="/2023/02/02/linux%E5%A4%9A%E8%BF%9B%E7%A8%8B-%E4%B8%80/9.png" class=""><p>使用execl调用自定义程序  </p><img src="/2023/02/02/linux%E5%A4%9A%E8%BF%9B%E7%A8%8B-%E4%B8%80/10.png" class=""><img src="/2023/02/02/linux%E5%A4%9A%E8%BF%9B%E7%A8%8B-%E4%B8%80/11.png" class=""><p>上面示例的自定义程序调用时传递的参数是不同的，可以对比关于argv传递的参数，理解argv参数传递的方式。</p><h4 id="2-execlp函数"><a href="#2-execlp函数" class="headerlink" title="2.execlp函数"></a>2.execlp函数</h4><p>execlp函数声明如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">execlp</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *file , <span class="hljs-type">const</span> <span class="hljs-type">char</span> *arg , ....)</span></span>;<br></code></pre></td></tr></table></figure><p>其中参数file指向要执行的程序，但不需要写出完整路径，函数会从环境变量PATH所指的目录中查找符合参数file的<br>文件名，找到后便执行该文件；后面的参数同execl函数相同，最后一个参数同样需要空指针NULL作为结束。函数成功<br>执行不会返回，执行失败返回-1，错误码存于errno中。<br>示例程序：  </p><img src="/2023/02/02/linux%E5%A4%9A%E8%BF%9B%E7%A8%8B-%E4%B8%80/12.png" class=""><p>上图可以看到execlp第一个参数直接写pwd这个命令即可，不需要写全路径，因为环境变量PATH中已经包含了pwd命令<br>所在的路径了；第二个参数是空字符串，也可以是其它任意的字符串，但必须要有，不可为NULL，否则程序会报错。<br>这个规则是对创建系统命令程序的情况，自定义程序无此规则要求。<br>使用execlp调用自定义程序的话，需要将自定义程序的文件路径加入到环境变量PATH中，也可以将自定义程序移动到<br>PATH路径现在已经有的路径下。将上文的test_exemine复制一份到&#x2F;usr&#x2F;bin下，然后用execlp调用此程序示例如下：   </p><img src="/2023/02/02/linux%E5%A4%9A%E8%BF%9B%E7%A8%8B-%E4%B8%80/13.png" class=""><img src="/2023/02/02/linux%E5%A4%9A%E8%BF%9B%E7%A8%8B-%E4%B8%80/14.png" class=""><p>可以看到execlp调用自定义程序执行成功了，且参数为NULL。<br>实际上，只有函数execvpe才是真正意义上的系统调用，其它的都是在此基础上封装的函数。exec函数族的作用是根<br>据指定的文件名找到可执行文件，并用它来取代调用进程的内容（即在调用进程内部执行一个可执行文件，此文件既<br>可以是二进制文件，也可以是任何linux下可执行的脚本文件）。exec函数族的这6个函数都是以exec开头的，前面三<br>个函数后面的字母都是l，表示list（列举参数），后面三个函数接着字母v，表示vector（参数向量表）。它们的区<br>别在于，execv开头的函数是以“char *argv[]”（vector)形式传递命令行参数的，而execl开头的函数采用罗列<br>（list）的方式，把参数一个一个列出来，然后以一个NULL表示结束。这里的NULL的作用和argv数组里的NULL作用是<br>一样的。</p><h3 id="使用system创建进程"><a href="#使用system创建进程" class="headerlink" title="使用system创建进程"></a>使用system创建进程</h3><p>system函数通过使用shell程序来执行所传入的命令（效率低），相当于先fork(),再execve()。该函数的特定是原进<br>程和子进程各自运行，且原进程需要等子进程运行完成后再继续。system()会调用fork()产生子进程，然后由子进程<br>来调用&#x2F;bin&#x2F;sh -c执行system函数的参数command字符串所代表的命令，此命令执行完后随即返回原调用的进程。<br>&#x2F;bin&#x2F;sh一般是一个软链接，指向某个具体的shell，比如bash，-c选项是告诉shell从字符串command中读取命令。在<br>该command执行期间，SIGCHLD信号会被暂时搁置，SIGINT和SIGQUIT信号则会被忽略。system函数声明如下：   </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">system</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *command)</span></span>;<br></code></pre></td></tr></table></figure><p>其中参数command是要执行的命令，如果fork失败，则返回-1，如果command顺利执行完毕，则返回command通过exit<br>或return返回的值。关于system()函数的返回值，需要了解其执行的过程，实际上，system()函数执行了3步操作：</p><blockquote><ul><li>(1) fork一个子进程。</li><li>(2) 在子进程中调用exec函数去执行command。</li><li>(3) 在父进程中调用wait等待子进程结束。</li></ul></blockquote><p>如果fork失败，system()函数返回-1。如果exec执行成功，即command顺利执行完毕，则返回command通过return或<br>exit返回的值（注意，command顺利执行不代表执行成功，比如“rm xxx.txt”，无论文件是否存在，该command都顺利<br>执行了）。如果exec执行失败，即command没有顺利执行，比如被信号中断或者command命令根本不存在，system()函<br>数返回127。如果command为NULL，则system()函数返回非0值，一般为1。<br>实现： </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">system</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *command)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">pit_t</span> pid;<br>    <span class="hljs-type">int</span> status;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-literal">NULL</span> == command)<br>    &#123;<br>        <span class="hljs-comment">//如果命令为空，返回非0值，一般为1</span><br>        <span class="hljs-keyword">return</span> (<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">if</span>((pid = fork()) &lt; <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-comment">//fork子进程创建失败，返回-1</span><br>        status = <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(pid == <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-comment">//子进程使用execl函数嗲用shell，然后通过shell执行目标程序命令command</span><br>        <span class="hljs-built_in">execl</span>(<span class="hljs-string">&quot;/bin/sh&quot;</span>,<span class="hljs-string">&quot;sh&quot;</span>,<span class="hljs-string">&quot;-c&quot;</span>,command,<span class="hljs-literal">NULL</span>);<br>        <span class="hljs-comment">//execl执行成功后子进程就被目标程序替代，此时子进程就不再存在</span><br>        <span class="hljs-comment">//execl执行失败时才会返回到现在的子进程，才有127返回码</span><br>        _exit(<span class="hljs-number">127</span>);<br>    &#125;<br>    <span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-comment">//父进程等待子进程结束，并获取子进程结束状态</span><br>        <span class="hljs-keyword">while</span>(<span class="hljs-built_in">waitpid</span>(pid,&amp;status,<span class="hljs-number">0</span>) &lt; <span class="hljs-number">0</span>)<br>        &#123;<br>            <span class="hljs-keyword">if</span>(errno != EINTR)<br>            &#123;<br>                <span class="hljs-comment">//waitpid被信号中断，则返回-1</span><br>                status = <span class="hljs-number">-1</span>;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//返回子进程状态</span><br>    <span class="hljs-keyword">return</span> status;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>进程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++下的文件IO</title>
    <link href="/2023/01/31/C-%E4%B8%8B%E7%9A%84%E6%96%87%E4%BB%B6IO/"/>
    <url>/2023/01/31/C-%E4%B8%8B%E7%9A%84%E6%96%87%E4%BB%B6IO/</url>
    
    <content type="html"><![CDATA[<h2 id="流的概念"><a href="#流的概念" class="headerlink" title="流的概念"></a>流的概念</h2><p>在C++语言中，数据的输入和输出（简称为I&#x2F;O）包括：对标准输入设备（如键盘）和标准输出设备（如显示器）；对<br>在外存磁盘上的文件；和对内存中指定的字符串存储空间（该存储空间亦可以存储其它任何信息）进行输入输出这3方<br>面。对标准输入设备和标准输出设备的输入输出简称为标准I&#x2F;O；对在外存磁盘上文件的输入输出简称为文件I&#x2F;O；对<br>内存中指定的字符串存储空间的输入输出简称为串I&#x2F;O。“流”就是”流动”，是物质从一处向另一处流动的过程。C++<br>流是指信息从外部输入设备（如键盘和磁盘）向计算机内部（即内存）输入和从内存向外部设备（如显示器和键盘）<br>输出的过程。这种输入输出过程被形象的比喻为”流”。为了实现信息的内外流动，C++系统定义了I&#x2F;O类库，其中的每<br>一个类都称作相应的流或流类，用以完成某一方面的功能。一个流类定义的对象也时常被称为流。例如根据文件流类<br>fstream定义的一个对象fio可称作为fio流或fio文件流，用它可以同磁盘上一个文件相联系，实现对该文件的输入和<br>输出，fio就等同于与之相联系的文件。<br>因为C++兼容C，所以C中的输入输出函数依然可以在C++中使用，但是直接把C的那套输入输出搬到C++中无法满足C++的<br>需求，C中的输入输出有类型要求，只支持基本类型，因此不满足C++的需求，所以C++设计了易于使用的并且多种输入<br>输出流接口统一的IO类库，且支持多种格式化操作，还可以自定义格式化操作。总的来说，C++中有3种输入输出流：   </p><blockquote><ul><li>标准I&#x2F;O流：内存与标准输入输出设备之间信息的传递。</li><li>文件I&#x2F;O流：内存与外部文件之间信息的传递。</li><li>字符串I&#x2F;O流：内存变量与表示字符串流的字符数组之间信息的传递。</li></ul></blockquote><p>C++引入IO流，将这3种输入输出流接口统一起来，使用符号”&gt;&gt;”读取数据的时候，不用去管是从何处读取数据，使用<br>符号”&lt;&lt;”写数据的时候，也不需要考虑输出到哪里去。   </p><h2 id="流的类库"><a href="#流的类库" class="headerlink" title="流的类库"></a>流的类库</h2><p>C++语言系统为实现数据的输入和输出定义了一个庞大的类库，其中ios为根基类，其余都是它的直接或间接派生类，<br>它直接派生4个类：输入流类istream；输出流类ostream；文件流基类fstreambase；和字符串流基类strstreambase.<br>C++系统中的I&#x2F;O类库的所有类被包含在iostream、fstream和strstream 3个系统头文件中。各个类的继承关系如下：      </p><img src="/2023/01/31/C-%E4%B8%8B%E7%9A%84%E6%96%87%E4%BB%B6IO/1.png" class=""><br/>            <p>头文件<fstream>提供了三个文件流类：ifstream、ofstream和fstream。这三个类的描述如下：    </p><blockquote><ul><li>ifstream : 该类表示输入文件流，用于从文件流读取信息</li><li>ofstream : 该类表示输出文件流，用于创建文件并向文件写入信息</li><li>fstream : 该类通常表示文件流，且同时具有ifstream和ofstream两种功能，意味着它可以创建文件、向文件<br>        写入信息、从文件读取信息</li></ul></blockquote><p>使用C++进行文件处理时，必须包含头文件<fstream>。此外，C++新标准中，头文件都把.h去掉了，所以之前的写法<br>如 #include&lt;fstream.h&gt;现在要改为：  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;fstream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br></code></pre></td></tr></table></figure><p>同时需要把标准命名空间加上。需要注意的是，这两个写法的头文件并不是完全等价的。在旧头文件里的fstream.h，<br>如果使用ifstream fio的默认参数声明一个输入文件流，当这个要读的fio文件不存在时，会自动创建一个空文件，<br>从而给判断文件是否存在会造成麻烦。如果使用新标准fstream，就不会创建空文件，从而可以使用while(!fio)来判<br>断文件是否存在。类似的头文件iostream.h与iostream也是不同的。iostream.h在旧的标准C++中使用，新标准中用<br>头文件iostream，还需要引用命名空间std。iostream.h慢慢不再使用了，如微软VC6可以使用iostream.h，VS2008就<br>已经不能使用iostream.h了。    </p><h3 id="打开文件"><a href="#打开文件" class="headerlink" title="打开文件"></a>打开文件</h3><p>ifstream、ofstream和fstream都可以用来打开文件，如果只是需要对文件进行读操作，就使用ifstream对象，如果<br>需要对文件进行写入操作，就用ofstream或者fstream对象。被打开的文件在程序中由一个流对象（stream object）<br>来表示（这些类的实例对象），对这个流对象所做的任何输入输出操作实际上就是对该文件的操作。要通过一个流<br>对象打开一个文件，可以使用它的成员函数open(),open()函数是fstream、ifstream和ofstream对象的一个成员函数<br>该函数声明如下：   </p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">open</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *filename , ios::openmode mode)</span></span>;<br></code></pre></td></tr></table></figure><p>其中，第一个参数指定要打开的文件名称和位置，第二个参数定义文件打开的模式，模式有如下选项：  </p><blockquote><ul><li>ios::app : 追加模式。所有写入都追加到文件末尾</li><li>ios::ate : 文件打开后定位到文件末尾</li><li>ios::in : 打开文件用于读取</li><li>ios::out : 打开文件用于写入</li><li>ios::trunc: 如果该文件已经存在，其内容将在打开文件之前被截断，即把文件长度设为0</li><li>ios::binary: 以二进制方式打开文件</li></ul></blockquote><p>以上模式可以组合使用。</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-comment">//以写入模式打开文件，并希望截断文件，防止文件已经存在</span><br>ofstream <span class="hljs-attr">ofile</span><span class="hljs-punctuation">;</span><br>ofile.open(<span class="hljs-string">&quot;file.dat&quot;</span> , ios::out | ios::trunc)<span class="hljs-punctuation">;</span><br><br><span class="hljs-comment">//以读写模式打开</span><br>fstream <span class="hljs-attr">iofile</span><span class="hljs-punctuation">;</span><br>iofile.open(<span class="hljs-string">&quot;file.dat&quot;</span> , ios::in | ios::out)<span class="hljs-punctuation">;</span><br><br><span class="hljs-comment">//以二进制方式打开文件，并追加写入数据</span><br>ofstream <span class="hljs-attr">ofile</span><span class="hljs-punctuation">;</span><br>ofile.open(<span class="hljs-string">&quot;file.bin&quot;</span> , ios::out | ios::app | ios::binary)<span class="hljs-punctuation">;</span><br><br></code></pre></td></tr></table></figure><p>ifstream、ofstream和fstream类的成员函数open都包含一个默认打开文件的方式，这三个类的默认方式各不相同：</p><blockquote><ul><li>ofstream : ios::out | ios::trunc</li><li>ifstream : ios::in</li><li>fstream  : ios::in | ios::out</li></ul></blockquote><p>只有在函数被调用时没有声明方式参数的情况下，默认值才会生效。这三个类都有一个构造函数可以直接调用open<br>函数，因此可以通过如下方式定义对象并打开文件：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">//使用构造函数</span><br><span class="hljs-function">ofstream <span class="hljs-title">ofile</span>(<span class="hljs-params"><span class="hljs-string">&quot;file.bin&quot;</span> , ios::<span class="hljs-keyword">out</span> | ios::app | ios::binary</span>)</span>;<br><br><span class="hljs-comment">//检查文件是否被成功打开，true为成功打开，否则为false</span><br><span class="hljs-function"><span class="hljs-built_in">bool</span> <span class="hljs-title">is_open</span>()</span>;<br></code></pre></td></tr></table></figure><h3 id="关闭文件"><a href="#关闭文件" class="headerlink" title="关闭文件"></a>关闭文件</h3><p>文件读写操作完毕后，必须将文件关闭以使文件重新变为可访问的。关闭文件可以使用成员函数close()，它负责将缓<br>存中的数据刷新并关闭文件。类ifstream、ofstream和fstream都拥有成员函数close()，声明如下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">close</span>()</span>;<br></code></pre></td></tr></table></figure><p>该函数一旦被调用，之前使用的流对象就可以被用来打开其它的文件，关闭的文件也就可以重新被其它的进程所访问<br>了。为防止流对象被销毁时仍关联着打开的文件，析构函数将会自动调用关闭函数close。</p><h3 id="读写文件、数据块"><a href="#读写文件、数据块" class="headerlink" title="读写文件、数据块"></a>读写文件、数据块</h3><p>在C++中，可以使用流提取运算符”&gt;&gt;” 从文件读取信息，使用流插入运算符”&lt;&lt;”向文件写入数据，就如同使用该运算从<br>键盘读取信息，然后输出到屏幕一样。不同点在于文件操作时使用的是ifstream、ofstream或fstream对象，屏幕和键盘<br>使用的是cin和cout对象。C++的I&#x2F;O中也提供了write和read函数，分别从流中读取数据和向流写入数据。    </p><blockquote><ul><li>wirte()函数是ostream的一个成员函数，被ofstream所继承</li><li>read()函数是istream的一个成员函数，被ifstream所继承</li><li>fstream类对象同时拥有write和read两个函数</li></ul></blockquote><p>函数原型如下：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function">ostream&amp; <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-type">char</span> * buffer , streamsize size)</span></span>;<br><span class="hljs-function">istream&amp; <span class="hljs-title">read</span><span class="hljs-params">(<span class="hljs-type">char</span> * buffer , streamsize size)</span></span>;<br></code></pre></td></tr></table></figure><p>其中buffer是申请的一块内存地址，用于储存从流中读出的数据或者将要写入流的数据；参数size是一个整数值，表示<br>将要从流中读入buffer或者从buffer写入流时的大小。函数示例如下：     </p><img src="/2023/01/31/C-%E4%B8%8B%E7%9A%84%E6%96%87%E4%BB%B6IO/3.png" class=""><br/>          <h3 id="文件位置指针"><a href="#文件位置指针" class="headerlink" title="文件位置指针"></a>文件位置指针</h3><p>在C++中，istream和ostream也提供了用于重新定位文件位置指针的成员函数seekg和seekp，seekg用于设置输入文件<br>流的文件流指针位置，而seekp用于设置输出文件流的文件流指针位置。声明如下：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs scss">ostream&amp; <span class="hljs-built_in">seekp</span>(streampos pos);<br>ostream&amp; <span class="hljs-built_in">seekp</span>(streamoff off , ios::seek_dir dir);<br>istream&amp; <span class="hljs-built_in">seekg</span>(streampos pos);<br>istream&amp; <span class="hljs-built_in">seekg</span>(streamoff off , ios::seek_dir dir);<br></code></pre></td></tr></table></figure><p>其中，pos表示文件流指针新的位置值；off表示偏移量；dir表示起始位置；off和dir参数共同定位了文件流指针的操<br>作位置。dir在ios中定义的枚举类型如下：</p><figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs fsharp"><span class="hljs-built_in">enum</span> <span class="hljs-keyword">seek_dir</span>&#123;beg , cur , <span class="hljs-keyword">end</span>&#125;;<br></code></pre></td></tr></table></figure><p>每个枚举常量的含义如下：     </p><blockquote><ul><li>ios::beg : 文件流的起始位置（默认值，从流的开头开始定位）</li><li>ios::cur : 文件流的当前位置</li><li>ios::end : 文件流的结束位置</li></ul></blockquote><p>文件位置指针是一个整数值，指定了从文件的起始位置到指针所在位置的字节数。以下是关于定位获取文件位置指针<br>的示例：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>定位到fileObject的第n个字节（假设是ios::beg)<br>fileObject.seekg(n);<br><br><span class="hljs-regexp">//</span>把文件的读指针从fileObject当前位置向后移动n个字节<br>fileObject.seekg(n , ios::cur);<br><br><span class="hljs-regexp">//</span>把文件的读指针从fileObject末尾往回移动n个字节<br>fileObject.seekg(n , ios::end);<br><br><span class="hljs-regexp">//</span>定位到fileObject的末尾<br>fileObject.seekg(<span class="hljs-number">0</span> , ios::end);<br></code></pre></td></tr></table></figure><p>获取二进制文件大小的示例代码如下：     </p><img src="/2023/01/31/C-%E4%B8%8B%E7%9A%84%E6%96%87%E4%BB%B6IO/2.png" class=""><br/>               <h3 id="状态标识符"><a href="#状态标识符" class="headerlink" title="状态标识符"></a>状态标识符</h3><p>验证流的状态的成员函数可以用于读写文件的过程中，如eof()函数，它是ifstream从类ios中继承过来的，当到达文<br>件末尾时返回true，除了eof()以外，还有一些其它的验证流的成员函数，这些函数的返回类型都是bool型。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">//读写过程中出错返回true，如对一个打开模式不是为写状态的文件进行写操作、写入设备没有空间、文件受损或硬</span><br><span class="hljs-comment">//件故障</span><br><span class="hljs-function"><span class="hljs-built_in">bool</span> <span class="hljs-title">bad</span>()</span>;<br><br><span class="hljs-comment">//读取数据类型不匹配返回true，如果遇到EOF，该方法也返回true</span><br><span class="hljs-function"><span class="hljs-built_in">bool</span> <span class="hljs-title">fail</span>()</span>;<br><br><span class="hljs-comment">//是否到文件尾部，遇到EOF，true为已到文件尾部</span><br><span class="hljs-function"><span class="hljs-built_in">bool</span> <span class="hljs-title">eof</span>()</span>;<br><br><span class="hljs-comment">//没有发生任何错误的时候返回true，上面的方法如果返回true，则该方法返回false</span><br><span class="hljs-function"><span class="hljs-built_in">bool</span> <span class="hljs-title">good</span>()</span>;<br><br><span class="hljs-comment">//重置以上成员函数所检查的状态标识</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">clear</span>()</span>;    <br></code></pre></td></tr></table></figure><h3 id="文件属性"><a href="#文件属性" class="headerlink" title="文件属性"></a>文件属性</h3><p>除了上面对文件的读写情况外，获取文件的相关信息（如类型、大小、是否存在）也会经常遇到，linux用函数stat来<br>获取文件的相关信息，之前的linux系统调用下文件IO有过介绍，该函数声明如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">stat</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *filename , <span class="hljs-keyword">struct</span> stat *buf)</span></span>;<br></code></pre></td></tr></table></figure><p>其中参数filename指向文件名；buf指向结构体stat，用于存放文件属性信息。关于结构体stat的定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">stat</span>&#123;<br>    <span class="hljs-type">mode_t</span>  st_mode;    <span class="hljs-comment">//文件的类型和存取的权限</span><br>    <span class="hljs-type">ino_t</span>   st_ino;     <span class="hljs-comment">//inode节点号</span><br>    <span class="hljs-type">dev_t</span>   st_dev;     <span class="hljs-comment">//文件设备编号</span><br>    <span class="hljs-type">dev_t</span>   st_rdev;    <span class="hljs-comment">//（设备类型）若此文件为设备文件，则为其设备编号</span><br>    <span class="hljs-type">nlink_t</span> st_nlink;   <span class="hljs-comment">//连到该文件的硬链接数目，刚建立的文件值为1</span><br>    <span class="hljs-type">uid_t</span>   st_uid;     <span class="hljs-comment">//文件所有者的用户ID</span><br>    <span class="hljs-type">gid_t</span>   st_gid;     <span class="hljs-comment">//文件所有者对应的组ID</span><br>    <span class="hljs-type">off_t</span>   st_size;    <span class="hljs-comment">//普通文件，对应的文件字节数</span><br>    <span class="hljs-type">time_t</span>  st_atime;   <span class="hljs-comment">//文件最后一次被访问的时间</span><br>    <span class="hljs-type">time_t</span>  st_mtime;   <span class="hljs-comment">//文件内容最后一次被修改的时间</span><br>    <span class="hljs-type">time_t</span>  st_ctime;   <span class="hljs-comment">//文件状态改变的时间（指属性）</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>   st_blksize;    <span class="hljs-comment">//文件内容对应的块大小(文件系统的I/O缓冲区大小)</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>   st_blocks;     <span class="hljs-comment">//文件内容对应的块数量</span><br>&#125;；<br></code></pre></td></tr></table></figure><p>如果函数执行成功，返回0；失败返回-1；错误代码存在于errno中，常见错误代码如下：   </p><blockquote><ul><li>ENOENT： 参数filename指定的文件不存在</li><li>ENOTDIR： 路径中的目录存在但却非真正的目录</li><li>ELOOP： 欲打开的文件有过多符号连接问题，上限为16个符号链接</li><li>EFAULT： 参数buf为无效指针，指向无法存在的内存空间</li><li>EACCESS： 存取文件时被拒绝</li><li>ENOMEM： 核心内存不足</li><li>ENAMETOOLONG： 参数filename的路径名称太长</li></ul></blockquote><p>这些宏定义可以在include&#x2F;asm-generic&#x2F;errno-base.h中找到。可以通过stat获取文件的类型和文件大小等信息。文<br>件类型有：普通文件、目录文件、块特殊文件、字符特殊文件、FIFO、套接字和符号链接。<br>获取文件大小和判断文件是否存在示例：      </p><img src="/2023/01/31/C-%E4%B8%8B%E7%9A%84%E6%96%87%E4%BB%B6IO/4.png" class=""><br/>                <h3 id="文件目录项创建与删除"><a href="#文件目录项创建与删除" class="headerlink" title="文件目录项创建与删除"></a>文件目录项创建与删除</h3><p>目录文件中存放的是文件名和对应的inode号码，这些统称为目录项。link和unlink函数分别用于创建硬链接和删除硬<br>链接。link函数创建一个新目录项，并且增加一个链接数。unlink函数删除目录项，并且减少一个链接数。如果链接<br>数达到0并且没有任何进程打开该文件，该文件内容才被真正删除。如果在unlink之前没有close，那么依旧可以访问<br>文件内容。两个函数中的操作都是原子操作。总之，真正影响链接数的操作是link、unlink以及open的创建。删除文<br>件内容的真正含义是文件的链接数为0。link与unlink函数声明如下：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">link</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *oldpath , <span class="hljs-type">const</span> <span class="hljs-type">char</span> *newpath)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">unlink</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *pathname)</span></span>;<br></code></pre></td></tr></table></figure><p>link函数以参数newpath指定的名称来建立一个新的硬链接到参数oldpath所指定的已存在文件。如果参数newpath指定<br>的名称为一已经存在的文件则不会建立链接。link函数所建立的硬链接无法跨越不同文件系统，如果需要可以使用软<br>链接symlink函数。当oldpath不存在或者newpath存在会调用失败，调用成功时返回0，否则返回-1。<br>unlink函数的参数：pathname为要删除目录项的文件路径名。如果函数执行成功就返回0，否则返回-1。<br>linux中是用inode节点来区分文件的，当删除一个文件的时候，系统并不一定就会释放inode节点的内容。当满足以下<br>的要求时，系统才会释放inode节点的内容。   </p><blockquote><ul><li>(1) inode中记录指向该节点的硬链接数为0。</li><li>(2) 没有进程打开指向该节点的文件。</li></ul></blockquote><p>使用unlink函数删除文件的时候，只会删除目录项，并且将inode节点的硬链接数目减1，并不一定会释放inode节点。<br>如果此时没有进程正在打开该文件或者有其它文件指向该inode节点，该inode节点将会被释放；如果此时有进程正在<br>打开一个文件，而此时使用unlink删除了该文件，那么此时只是删除了目录项，并没有释放，因为此时仍然有进程在<br>占用此文件。<br>unlink函数的另一个用途就是用来创建临时文件，如果在程序中使用open创建了一个文件后，立即使用unlink函数删<br>除文件，由于此时进程正在打开该文件，因此系统并不会释放该文件的inode节点，而只是删除其目录项。当进程退出<br>时，该inode节点将会立即被释放。临时文件可以用在进程间通信的有名管道通信中。      </p><img src="/2023/01/31/C-%E4%B8%8B%E7%9A%84%E6%96%87%E4%BB%B6IO/5.png" class=""><img src="/2023/01/31/C-%E4%B8%8B%E7%9A%84%E6%96%87%E4%BB%B6IO/6.png" class=""><img src="/2023/01/31/C-%E4%B8%8B%E7%9A%84%E6%96%87%E4%BB%B6IO/7.png" class=""><br/>           <p>可以看到，第二步open只读时不影响链接数；第三步close时也不会影响链接数；第四步link后链接数会+1；unlink后<br>链接数会-1；第六步重新打开链接数不变；第七步unlink之后再次-1，此时使用fstat函数获取文件属性而非stat，因<br>为unlink已经删除了文件名，所以无法通过文件名访问，但是fd仍然是打开的，文件内容还没有被真正删除，仍然可<br>以使用fd取得文件信息，到最后程序close关闭fd之后，文件内容被删除，ls查看test.dat时已不存该文件。</p>]]></content>
    
    
    <categories>
      
      <category>c++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>文件io</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>我的2022</title>
    <link href="/2023/01/21/%E6%88%91%E7%9A%842022/"/>
    <url>/2023/01/21/%E6%88%91%E7%9A%842022/</url>
    
    <content type="html"><![CDATA[<h2 id="最是人间留不住，朱颜辞镜花辞树。"><a href="#最是人间留不住，朱颜辞镜花辞树。" class="headerlink" title="最是人间留不住，朱颜辞镜花辞树。"></a>最是人间留不住，朱颜辞镜花辞树。</h2><p>今天是一年的最后一天了，今晚过完就是癸卯兔年了。回顾2022全年，最开心的事情莫过于阿根廷夺冠，messi终圆童话梦,<br>也让我多年的青春和执念有始有终了。糟心的事情则是国内放开后家人相继中招，元旦时我和媳妇在这边也莫名中招了，家<br>里就剩小贝儿和母亲没被感染，真心希望这疫情赶紧早点结束，早点恢复正常的通航。工作上，今年好像干的挺杂乱的，一<br>会是java，一会是powershell，一会又是c++，东一榔头西一棒槌，技术上感觉什么都没学到。。。今年工作之余抽时间看<br>完的书有&lt;&lt;Essential C++&gt;&gt;、&lt;&lt;C++ Primer Plus&gt;&gt;这两本，&lt;&lt;计算机系统要素&gt;&gt;这本书看了有一半吧，但是感觉这本<br>书给我的受益最大，跟着这本书可以从硬件一直构建到操作系统和编程语言的实现，因为看到一半，所以我现在只做到虚拟<br>机实现的上半部分。&lt;&lt;java虚拟机规范&gt;&gt;看了两章、&lt;&lt;数据密集型应用系统设计&gt;&gt;看了一章、&lt;&lt;Vim实用技巧&gt;&gt;看了三<br>章、&lt;&lt;剑指offer&gt;&gt;也看了一章多、&lt;&lt;Linux C&#x2F;C++ &gt;&gt;看到第五章，&lt;&lt;百年孤独&gt;&gt;看了几十页，工作之余看书都比较随<br>意，所以把每本书看的都很零碎，希望新的一年可以改掉这个毛病吧，也希望自己能加把劲把这些书都啃完吧！<br>   最后，祝每个人新年健康平安快乐，得偿所愿！</p>]]></content>
    
    
    <categories>
      
      <category>生活</category>
      
    </categories>
    
    
    <tags>
      
      <tag>年终回顾</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>linux系统调用下的文件I/O</title>
    <link href="/2023/01/15/linux%E6%96%87%E4%BB%B6io/"/>
    <url>/2023/01/15/linux%E6%96%87%E4%BB%B6io/</url>
    
    <content type="html"><![CDATA[<h2 id="关于I-x2F-O"><a href="#关于I-x2F-O" class="headerlink" title="关于I&#x2F;O"></a>关于I&#x2F;O</h2><p>I&#x2F;O就是输入&#x2F;输出，它是主存和外部设备（比如硬盘、U盘）之间复制数据的过程，其中数据从设备到内存的过程<br>称为输入，数据从内存到设备的过程叫输出，I&#x2F;O可以分为高级I&#x2F;O和低级I&#x2F;O，高级I&#x2F;O通常也称为带缓冲的I&#x2F;O，<br>比如ANSI C提供的标准I&#x2F;O库。低级I&#x2F;O通常也称为不带缓冲的I&#x2F;O，它是linux提供的系统调用，速度快，如函数<br>open、read、write等。而带缓冲的I&#x2F;O在系统调用前采用一定的策略，速度慢，但比不带缓冲的I&#x2F;O安全，如fopen、<br>fread、fwrite等。在linux下对文件进行输入输出操作有3种编程方式，一种是调用C库中文件的I&#x2F;O函数，比如<br>fopen、fread&#x2F;fwrite、fclose等，另外两种方式是使用linux的系统调用和C++文件流的操作。</p><h2 id="I-x2F-O相关函数"><a href="#I-x2F-O相关函数" class="headerlink" title="I&#x2F;O相关函数"></a>I&#x2F;O相关函数</h2><h4 id="文件描述符"><a href="#文件描述符" class="headerlink" title="文件描述符"></a>文件描述符</h4><p>对于linux而言，所有设备或文件的操作都是通过文件描述符进行的。当打开或者创建一个文件的时候，内核向进<br>程返回一个非负的文件描述符。后续对文件的操作只需要通过该文件描述符，内核记录有关这个打开文件的信息。<br>一个进程启动时，默认打开三个文件，标准输入、标准输出、标准错误，对应文件描述符是0（STDIN_FILENO）、<br>1（STDOUT_FILENO）、2（STDERR_FILENO）,这些常量定义在unistd.h头文件中。文件描述符和文件指针可以互相<br>转换，具体通过函数fileno和fdopen。函数fileno将文件指针转为文件描述符，函数声明如下:</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fileno</span><span class="hljs-params">(FILE *stream)</span></span>;<br></code></pre></td></tr></table></figure><p>其中，参数stream是文件指针。<br>函数fdopen将文件描述符转换为文件指针，声明如下：    </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">FILE *<span class="hljs-title">fdopen</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *mode)</span></span>;<br></code></pre></td></tr></table></figure><p>其中，参数fd是文件描述符，mode是打开方式。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;fileno(stdin) = %d\n&quot;</span>,<span class="hljs-built_in">fileno</span>(stdin));<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;fileno(stdout) = %d\n&quot;</span>,<span class="hljs-built_in">fileno</span>(stdout));<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;fileno(stderr) = %d\n&quot;</span>,<span class="hljs-built_in">fileno</span>(stderr));<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>编译运行：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">fileno(stdin) <span class="hljs-operator">=</span> <span class="hljs-number">0</span><span class="hljs-comment">;</span><br>fileno(stdout) <span class="hljs-operator">=</span> <span class="hljs-number">1</span><span class="hljs-comment">;</span><br>fileno(stderr) <span class="hljs-operator">=</span> <span class="hljs-number">2</span><span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><h4 id="打开或创建文件"><a href="#打开或创建文件" class="headerlink" title="打开或创建文件"></a>打开或创建文件</h4><p>linux提供open函数来打开或者创建一个文件。该函数声明如下：   </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">open</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *pathname, <span class="hljs-type">int</span> flags)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">open</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *pathname, <span class="hljs-type">int</span> flags, <span class="hljs-type">mode_t</span> mode)</span></span>;<br></code></pre></td></tr></table></figure><p>其中，参数pathname表示文件的名称，可以包含（绝对和相对）路径；flags表示文件打开方式；mode用来规定对该文件的<br>所有者、文件的用户组及系统中其他用户的访问权限。如果函数执行成功，就返回文件描述符，如果函数执行失败就返回-1.<br>文件打开的方式flags可以使用下列宏（当有多个选项时，采用“|”连接）： </p><blockquote><ul><li>O_RDONLY: 打开一个只供读取的文件。</li><li>O_WRONLY: 打开一个只供写入的文件。</li><li>O_RDWR: 打开一个可供读写的文件。</li><li>O_APPEND: 写入的所有数据将被追加到文件的末尾。</li><li>O_CREAT: 打开文件，如果文件不存在就建立文件。</li><li>O_EXCL: 如果已经置O_CREAT且文件存在，就强制open失败。</li><li>O_TRUNC: 在打开文件时，将文件的内容清。</li><li>O_DSYNC: 每次写入时，等待数据写到磁盘上。</li><li>O_RSYNC: 每次读取时，等待相同部分先写到磁盘上。</li><li>O_SYNC: 以同步方式写入文件，强制刷新内核缓冲区到输出文件。</li></ul></blockquote><p>最后三个SYNC（同步）选项都会降低性能，使用这些宏需要包含头文件fcntl.h。O_RDONLY、O_WRONLY或O_RDWR<br>这三个选项是必选一个的。mode只有创建文件时才使用此参数，指定文件的访问权限。模式包含以下:  </p><blockquote><ul><li>S_IRUSR: 文件所有者的读权限位。</li><li>S_IWUSR: 文件所有者的写权限位。</li><li>S_IXUSR: 文件所有者的执行权限位。</li><li>S_IRWXU: S_IRUSR | S_IWUSR | S_IXUSR。</li><li>S_IRGRP: 文件用户组的读权限位。</li><li>S_IWGRP: 文件用户组的写权限位。</li><li>S_IXGRP: 文件用户组的执行权限位。</li><li>S_IRWXG: S_IRGRP | S_IWGRP | S_IXGRP。</li><li>S_IROTH: 文件其他用户的读权限位。</li><li>S_IWOTH: 文件其他用户的写权限位。</li><li>S_IXOTH: 文件其他用户的执行权限位。</li><li>S_IRWXO: S_IROTH | S_IWOTH | S_IXOTH。</li></ul></blockquote><p>使用这些权限宏时需要包含头文件sys&#x2F;stat.h。文件的访问权限是跟根据umask&amp;~mode得出来的。例如：umask &#x3D; 0022,<br>mode &#x3D; 0655，则访问权限为：644。umask是目前用户在建立档案或目录时的权限默认值，可以通过命令umask或者<br>umask -S查看该值。<br>打开创建文件示例:</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-keyword">int</span> fd = <span class="hljs-keyword">open</span>(<span class="hljs-string">&quot;./test.txt&quot;</span>,O_RDONLY);<span class="hljs-regexp">//</span>以只读方式打开test.txt文件<br><span class="hljs-keyword">int</span> fd = <span class="hljs-keyword">open</span>(<span class="hljs-string">&quot;./test.txt&quot;</span>,O_CREAT | O_RDWR);<span class="hljs-regexp">//</span>不存在就新建，否则以读写方式打开test.txt文件<br></code></pre></td></tr></table></figure><p>为了维持与早期的unix系统的向后兼容性，linux也提供了一个专门创建文件的系统调用，creat函数，它的声明如下:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">creat</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *pathname, <span class="hljs-type">mode_t</span> mode)</span></span>;<br></code></pre></td></tr></table></figure><p>其中参数pathname表示文件的名称，可以包含（绝对和相对）路径；mode用来规定对该文件的所有者、文件的用户<br>组及系统中其他用户的访问权限，其取值与open函数的mode相同。如果函数执行成功就返回文件描述符，负责返回<br>-1。在unix的早期版本中，open系统调用仅仅存在两个参数的形式。如果文件不存在，就不能打开这些文件。文件<br>的创建则由单独的系统调用creat完成。在Linux及所有unix的近代版本中，creat系统调用是多余的，因为open也<br>可以用来创建文件。以下两种形式等价。</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">int fd</span> = creat(file , mode);<br><span class="hljs-attribute">int fd</span> = open(file , O_WRONLY | O_CREAT | O_TRUNC , mode);<br></code></pre></td></tr></table></figure><img src="/2023/01/15/linux%E6%96%87%E4%BB%B6io/1.png" class=""><h4 id="关闭文件"><a href="#关闭文件" class="headerlink" title="关闭文件"></a>关闭文件</h4><p> 文件不再使用的时候，需要关闭，关闭问价使用close函数，该函数声明如下：<br> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">close</span><span class="hljs-params">(<span class="hljs-type">int</span> fd)</span></span>;<br></code></pre></td></tr></table></figure><br>其中fd为要关闭的文件描述符，函数执行成功就返回文件描述符，否则则返回-1。<br>文件关闭以后，此问价描述符不再指向任何文件，从而此描述符可以再次使用。如果每次打开文件后不关闭，就会<br>将系统的文件描述符耗尽，最终导致不能再打开文件。</p><h4 id="读取文件数据"><a href="#读取文件数据" class="headerlink" title="读取文件数据"></a>读取文件数据</h4><p>read函数可以实现从已经打开的文件中读取数据，该函数声明如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">ssize_t</span> <span class="hljs-title">read</span><span class="hljs-params">(<span class="hljs-type">int</span> fd , <span class="hljs-type">void</span> *buf , <span class="hljs-type">size_t</span> count)</span></span>;<br></code></pre></td></tr></table></figure><p>该函数把参数fd所指的文件传送count个字节到buf指针所指的内存中，若count为0，则read函数不会起作用并<br>返回0，返回值为实际读取到的字节数，如果返回0，表示已经到达文件结尾或没有可以读取的数据。<em><strong>注意：文件读写位置会随读取到的字节移动。</strong></em><br>需要强调的是，如果函数读取成功，会返回实际读取到的字节数，所以最好能将返回值与参数count做比较，若<br>返回的字节数小于要求读取的字节数，则有可能读到了文件尾部或者read函数被信号中断了读取动作。若有错<br>误发生时，则返回-1，错误代码存入errno中，此时文件读写位置无法预期。<br>常见的错误代码如下：</p><blockquote><ul><li>EINTR: 此调用被信号所中断。</li><li>EAGAIN: 当使用不可阻断I&#x2F;O时（O_NONBLOCK），若无数据可读取，则返回此值。</li><li>EBADF: 参数fd为非有效的文件描述符，或者当前文件已关闭。</li></ul></blockquote><p>read函数示例如下：  </p><img src="/2023/01/15/linux%E6%96%87%E4%BB%B6io/2.png" class="">  <h4 id="向文件写入数据"><a href="#向文件写入数据" class="headerlink" title="向文件写入数据"></a>向文件写入数据</h4><p>函数write可用于将数据写入已经打开的文件，该函数声明如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">ssize_t</span> <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-type">int</span> fd , <span class="hljs-type">const</span> <span class="hljs-type">void</span> *buf , <span class="hljs-type">size_t</span> count)</span></span>;<br></code></pre></td></tr></table></figure><p>该函数会把参数buf所指向的缓冲区中的count个字节数据写入fd所指的文件内，文件读写位置会随之移动。fd<br>是一个已经打开的文件描述符；buf指向一个缓冲区，为要写入的数据；count表示要写入的数据长度，单位是<br>字节。函数执行成功时返回实际写入的数据的字节数，当有错误发生时返回-1。错误代码用errno查看，常见<br>错误代码如下：</p><blockquote><ul><li>EINTR: 此调用被信号所中断。</li><li>EADF: 参数fd是非有效的文件描述符，或者该文件已经关闭。</li></ul></blockquote><p>代码示例：  </p><img src="/2023/01/15/linux%E6%96%87%E4%BB%B6io/3.png" class="">   <h4 id="文件偏移量"><a href="#文件偏移量" class="headerlink" title="文件偏移量"></a>文件偏移量</h4><p>读写文件时可能需要从不同的位置开始，此时需要让文件的读写位置可以移动到新的位置，所以需要用到设定文<br>件偏移量的函数。文件偏移量指的是当前文件操作位置相对于文件开始位置的偏移，当打开一个文件时，如果没<br>有指定O_APPEND参数，文件的偏移量为0，如果指定了O_APPEND参数，文件的偏移量与文件的长度相等，即文件的<br>当前操作位置移到了文件的末尾。<br>用来设定文件偏移量的系统函数是lseek，声明如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">off_t</span> <span class="hljs-title">lseek</span><span class="hljs-params">(<span class="hljs-type">int</span> fd , <span class="hljs-type">off_t</span> offset , <span class="hljs-type">int</span> whence)</span></span>;<br></code></pre></td></tr></table></figure><p>该函数对文件描述符fd所代表的文件，按照操作模式whence和偏移量的大小off_t，重新设置文件偏移量。如果<br>lseek()函数操作成功，就返回新的文件偏移量的值；如果失败就返回-1.由于文件的偏移量可以为负值，因此判<br>断lseek()是否操作成功时，要用是否等于-1来判断，不能使用小于0进行判断。参数offset和whence搭配使用，<br>具体含义如下：</p><blockquote><ul><li>whence值为SEEK_SET时，offset为相对文件开始处的值。</li><li>whence值为SEEK_CUR时，offset为相对当前位置的值。</li><li>whence值为SEEK_END时，offset为相对文件结尾的值。</li></ul></blockquote><p>函数使用示例如下：  </p><img src="/2023/01/15/linux%E6%96%87%E4%BB%B6io/4.png" class="">  <p>打开lseek.txt文件，可以看到写入的内容前有^@符号，这些不是空格,而是“0“，或者称为文件空洞。如果偏<br>移量设置超出文件的大小，就会造成文件空洞现象，即文件尾部（0字节大小的文件尾部就是文件的开头）到设置<br>之间被”0”填充。示例代码中新创建的文件lseek.txt文件大小为0kb，所以设置文件偏移量后会造成文件空洞<br>的现象。 </p><img src="/2023/01/15/linux%E6%96%87%E4%BB%B6io/5.png" class="">  <p>删除掉刚才的lseek.txt文件，然后新建一个文件lseek.txt,输入123456789ABCDEF，然后再重新执行示例程序，<br>会看到offset test被写入到7后面，并覆盖7以后的内容。  </p><img src="/2023/01/15/linux%E6%96%87%E4%BB%B6io/6.png" class="">  <img src="/2023/01/15/linux%E6%96%87%E4%BB%B6io/7.png" class="">  <img src="/2023/01/15/linux%E6%96%87%E4%BB%B6io/8.png" class="">  <h4 id="获取文件状态"><a href="#获取文件状态" class="headerlink" title="获取文件状态"></a>获取文件状态</h4><p>程序设计的时候经常要用到文件的一些属性特征值，如文件的所有者、文件的修改时间、文件的大小等。此时可以<br>使用stat()函数、fstat()函数或者lstat()函数。这些函数都可以获得文件的状态，函数声明如下：  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">stat</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *path , <span class="hljs-keyword">struct</span> stat *buf)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fstat</span><span class="hljs-params">(<span class="hljs-type">int</span> fd , <span class="hljs-keyword">struct</span> stat *buf)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lstat</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *path , <span class="hljs-keyword">struct</span> stat *buf)</span></span>;<br></code></pre></td></tr></table></figure><p>其中参数path是文件路径（包含文件名）；fd是文件描述符；buf为指向struct stat的结构体指针，获得的文件<br>属性特征值从这个参数中回传。当函数执行成功时返回0，执行失败时返回-1.<br>fstat函数区别于另外两个系统调用函数的地方在于，fstat系统调用接受的是一个文件描述符，而另外两个则直接<br>接受文件的全路径。文件描述符需要使用open系统调用后才能取得，而文件全路径可以省略此步，直接使用文件的<br>path就可以了。stat函数与lstat的区别是：当文件是一个符号链接时，lstat返回的是该符号链接本身的信息；而<br>stat返回的是该链接指向的文件的信息。<br>结构体struct stat是文件的属性特征描述，该结构定义如下：  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">stat</span>&#123;<br>    <span class="hljs-type">mode_t</span>  st_mode;    <span class="hljs-comment">//文件对应的模式、文件、目录等</span><br>    <span class="hljs-type">ino_t</span>   st_ino;     <span class="hljs-comment">//inode节点号</span><br>    <span class="hljs-type">dev_t</span>   st_dev;     <span class="hljs-comment">//设备号码</span><br>    <span class="hljs-type">dev_t</span>   st_rdev;    <span class="hljs-comment">//特殊设备号码</span><br>    <span class="hljs-type">nlink_t</span> st_nlink;   <span class="hljs-comment">//文件的链接数</span><br>    <span class="hljs-type">uid_t</span>   st_uid;     <span class="hljs-comment">//文件所有者</span><br>    <span class="hljs-type">gid_t</span>   st_gid;     <span class="hljs-comment">//文件所有者对应的组</span><br>    <span class="hljs-type">off_t</span>   st_size;    <span class="hljs-comment">//普通文件，对应的文件字节数</span><br>    <span class="hljs-type">time_t</span>  st_atime;   <span class="hljs-comment">//文件最后被访问的时间</span><br>    <span class="hljs-type">time_t</span>  st_mtime;   <span class="hljs-comment">//文件内容最后被修改的时间</span><br>    <span class="hljs-type">time_t</span>  st_ctime;   <span class="hljs-comment">//文件状态改变的时间</span><br>    <span class="hljs-type">blksize_t</span>   st_blksize;    <span class="hljs-comment">//文件内容对应的块大小</span><br>    <span class="hljs-type">blkcnt_t</span>    st_blocks;     <span class="hljs-comment">//文件内容对应的块数量</span><br>&#125;；<br></code></pre></td></tr></table></figure><p>示例代码：  </p><img src="/2023/01/15/linux%E6%96%87%E4%BB%B6io/9.png" class="">  <h4 id="文件锁定"><a href="#文件锁定" class="headerlink" title="文件锁定"></a>文件锁定</h4><p>当一个文件被多个用户共同使用和操作时，会导致共享资源产生竞争的状态，Linux采用给文件上锁的方法来避免产生共享资<br>源竞争。文件锁分为建议性锁和强制性锁，建议锁是指给文件上锁后，只在文件上设置一个锁的标识，其他进程如果要对该<br>文件进行操作时可以检测到有锁的存在，但该锁并不能阻止其它进程对这个文件要进行的操作。类似于红绿灯，红灯并不能<br>阻止车辆闯红灯的行为，更多的是建议规范。而强制性锁则是当给文件上锁后，其它进程要对这个文件进行不兼容的操作（<br>上了读锁，另外一个进程要写入）时，系统内核将会阻止后来的第二个进程，一直到第一个进程将锁解开。一般情况下，内<br>核和系统都不适合使用建议性锁，而应该使用强制性锁，这样可以防止一些破坏性的操作。每个进程对文件进行操作时，例<br>如执行open、read、write等操作时，内核都会检测该文件是否被加了强制性锁，如果加了强制性锁，其它进程对这些文件的<br>操作就会失败，也就是内核强制应用程序（即其它进程）来遵守游戏规则，这就是强制性锁的原理。<br><em><strong>对文件的加索操作是原子性的，并且，由fork产生的子进程不能继承父进程所设置的锁。也就意味着，若一个进程得到一把<br>锁，然后调用fork，那么对于父进程所获得的锁而言，子进程将被视为其它进程。对于从父进程处继承过来的任一描述符，<br>子进程都需要调用fnctl()函数才能获得属于它自己的锁。</strong></em><br>linux下可以使用fcntl()函数来实现文件的锁定。锁定文件在很多场合都很有用，例如为了防止进程的重复启动，可以在进<br>程启动时对&#x2F;var&#x2F;run目录下的.PID文件进行锁定，这样进程重复启动时，会因为无法对该文件上锁而退出。fcntl函数不仅能<br>对整个文件上锁，而且还可以对文件的某一记录上锁，此时的锁又称为记录锁。fcntl函数声明如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">fcntl</span><span class="hljs-params">(<span class="hljs-type">int</span> fd , <span class="hljs-type">int</span> cmd , <span class="hljs-keyword">struct</span> flock *lock)</span></span>;<br></code></pre></td></tr></table></figure><p>其中，参数fd为文件描述符，cmd为操作命令，锁定文件时取值如下：  </p><blockquote><ul><li>F_GETLK: 根据lock描述，决定是否上文件锁或者记录锁。</li><li>F_SETLK: 设置lock所描述的文件锁或者记录锁。</li></ul></blockquote><p>lock是指向结构体flock的指针，用来说明是一个文件锁还是一个记录锁，是用于整个文件锁定还是锁定文件中的某一部分字<br>节。锁的方式有两种：建议锁和强制锁（然而这两种锁的区分并不是通过参数设置完成的，而是通过对系统的设置加以实现<br>的）。建议锁，相对温柔，在对文件进行锁操作时，会检测是否已经有锁存在，并且尊重已有的锁，但是其它的进程仍然可<br>以自由的修改文件。如果所有的程序进程都以一致的方式处理文件锁（或者记录锁），即在读写共享的文件前都申请一次文<br>件锁或记录锁，或者都不申请，总之所有进程都要以一致的方式进行处理。那么就不会发生冲突，这样的进程集称为合作进<br>程，合作进程使用建议性锁是可行的。强制锁是由内核执行的锁，当一个文件被执行强制锁，并且当前进程正在写入数据的<br>操作，此时内核将阻止其它进程对该文件进行的读写操作。采取强锁会对性能影响很大，fcntl函数默认是建议锁，如果需要<br>在Linux中使用强制锁，则需要在root权限下，通过mount命令用-o mand选项打开该机制。结构体flock定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">flock</span><br>&#123;<br>    <span class="hljs-type">short</span> <span class="hljs-type">int</span> l_type;     <span class="hljs-comment">//锁定的状态</span><br>    <span class="hljs-type">short</span> <span class="hljs-type">int</span> l_whence;   <span class="hljs-comment">//决定l_start的位置</span><br>    <span class="hljs-type">off_t</span>     l_start;    <span class="hljs-comment">//锁定区域的开头位置</span><br>    <span class="hljs-type">off_t</span>     l_len;      <span class="hljs-comment">//锁定区域的大小</span><br>    <span class="hljs-type">pid_t</span>     l_pid;      <span class="hljs-comment">//锁定动作的进程</span><br>&#125;；<br></code></pre></td></tr></table></figure><p>l_type有三个选项：  </p><blockquote><ul><li>F_RDLCK: 共享锁（也称读锁），只读用，多个进程可以同时建立读取锁。</li><li>F_WRLCK: 独占锁（也称写锁），在任何时刻只能有一个进程建立写入锁</li><li>F_UNLCK: 解除锁定。</li></ul></blockquote><p>l_whence有以下几个选项（在unistd.h中定义）：</p><blockquote><ul><li>SEEK_SET: 文件开始位置</li><li>SEEK_CUR: 文件当前位置</li><li>SEEK_END: 文件末尾位置</li></ul></blockquote><p>其它的三个参数：</p><blockquote><ul><li>l_start: 相对开始偏移量，相对于l_whence而言。</li><li>l_len: 加锁的长度，0为到文件末尾。</li><li>l_pid：当前操作文件的进程ID号。</li></ul></blockquote><p>如果函数执行成功返回值为0，否则返回-1，此时可用errno查看错误码。函数使用示例代码如下：</p><img src="/2023/01/15/linux%E6%96%87%E4%BB%B6io/10.png" class="">  <p>如上图所示，程序编译并运行，此时程序处于死循环状态，并且文件已经加锁成功（默认为建议锁）。然后往lock.txt的文<br>件中写入数据，可以看到是可以写入成功的，如下图所示:  </p><img src="/2023/01/15/linux%E6%96%87%E4%BB%B6io/11.png" class="">  <p>上图中的lock.txt文件内容开始是空的，然后用echo往该上锁文件中写入数据，再次输出时可以看到写入的数据被输出了，<br>说明被建议锁锁住的文件的确是可以被其它进程修改的,所以建议锁只适合于合作进程。建议锁就是假定所有人都会遵守某<br>些规则去做一件事，例如人与车看到红灯都会停，看到绿灯才会继续走，此时的红绿灯就类似于建议锁，但这是一件需要<br>大家主动去遵守的规则，而并不能避免有些车与人强行闯红灯，而强制锁则完全是无法闯红灯的措施。<br>实现强制锁需要将文件所在的文件系统通过mount命令的“-o mand”选项来挂载，并且使用chmod函数或者chmod命令将文<br>件用户组的x权限去掉（即清楚组可执行位）。如下图所示：<br>首先切换到root用户，并查看我们的文件挂载硬盘信息：  </p><img src="/2023/01/15/linux%E6%96%87%E4%BB%B6io/12.png" class="">  <p> 可以看到lock.txt文件是挂载在&#x2F;dev&#x2F;sdc下的，所以进入lock.txt所在目录重新进行挂载，挂载完成后，此时文件系统<br> &#x2F;dev&#x2F;sdc增加了mand选项，然后再修改lock.txt的权限，将用户组的x权限去掉。如下图所示：  </p><img src="/2023/01/15/linux%E6%96%87%E4%BB%B6io/13.png" class="">  <img src="/2023/01/15/linux%E6%96%87%E4%BB%B6io/14.png" class="">  <p>此时重新运行之前的test_filelock程序，程序处于死循环当中，然后重新打开一个终端shell,尝试向lock.txt中写入新<br>内容，可以发现，#提示符出现不了，说明echo命令被阻塞不动了（内核阻止了该进程），说明强制锁已经生效。然后回<br>到之前的shell使用ctrl+c终止test_filelock程序，可以发现另一个shell的echo进程阻塞被解除了，出现了#提示符，查<br>看lock.txt文件，发现新的内容已经被写入，这说明强制锁解除后，就可以写入新内容了，否则无法写入。从这个例子可<br>以看出，强制锁的实现只是进行了一些系统上的设置，重新加载了文件系统，修改了文件的权限，程序上并没有进行任何<br>更改。</p><h4 id="文件与内存映射"><a href="#文件与内存映射" class="headerlink" title="文件与内存映射"></a>文件与内存映射</h4><p>文件和内存的映射，就是将普通文件映射到内存中，普通文件被映射到进程地址空间后，进程可以像访问普通内存一样对<br>文件进行访问，不需要再调用read或者write等函数进行操作。将普通文件映射到内存的系统函数为mmap,函数声明如下：  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/mman.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">void</span> *<span class="hljs-title">mmap</span><span class="hljs-params">(<span class="hljs-type">void</span> *start , <span class="hljs-type">size_t</span> length , <span class="hljs-type">int</span> prot , <span class="hljs-type">int</span> flags , <span class="hljs-type">int</span> fd , <span class="hljs-type">off_t</span> offset)</span></span>;<br></code></pre></td></tr></table></figure><p>其中参数start为映射区域的起始地址，通常为NULL或0，表示由系统自己决定映射到什么地址；length为映射数据的长度<br>，即文件需要映射到内存中的数据的大小；prot表示映射区域的保护方式，有以下取值（或它们的组合）：  </p><blockquote><ul><li>PROT_EXEC: 映射区可被执行。</li><li>PROT_READ: 映射区可读取。</li><li>PROT_WRITE: 映射区可写入。</li><li>PROT_NONE: 映射区不可访问。</li></ul></blockquote><p>flags用来指定映射对象的类型、映射选项和映射页是否可以共享，它的取值可以是一个或者多个位的组合。如下所示：  </p><blockquote><ul><li>MAP_FIXED: 如果参数start指定了需要映射到的地址，而所指定的地址无法成功建立映射，映射就会失败。通常不推<br>         荐使用此设置，而将start设置为NULL或0，由系统自动选取映射地址。</li><li>MAP_SHARED: 共享映射区域，映射区域允许其它进程共享，对映射区域写入数据将会写入原来的文件中。</li><li>MAP_PRIVATE: 对映射区域进行写入操作时会产生一个映射文件的复制，即私人的写入时复制（copy on write），对此<br>           映射区域的修改不会写回原来的文件，即不会影响原来文件的内容。</li><li>MAP_ANONYMOUS: 建立匿名映射。映射区不与任何文件关联，而且映射区无法与其它进程共享。</li><li>MAP_DENYWRITE: 对文件的写入操作将被禁止，不允许直接对文件进行操作。</li><li>MAP_LOCKED: 将映射区锁定，防止页面被交换出内存。</li></ul></blockquote><p>参数flags必须为MAP_SHARED或者MAP_PRIVATE二者之一的类型。MAP_SHARED类型表示多个进程使用的是一个内存映射的副<br>本，任何一个进程都可以对此映射进行修改，且其它进程对此修改是可见的。而MAP_PRIVATE则是多个进程使用的文件内存<br>映射，在写入操作后，会复制一个副本给修改的进程，多个进程之间的副本是不一致的。<br>参数fd表示文件描述符，一般由open()函数返回；<br>参数offset表示被映射数据在文件中的起点；<br>mmap()函数映射后，可以让用户程序直接访问设备内存，相比较在用户空间和内核空间相互复制数据，小路更高，在<br>要求高性能的应用中比较常用。mmap映射内存必须是页面大小的整数倍，面向流的设备不能进行mmap映射，mmap的实<br>现和硬件有关。<br>mmap()使用示例：   </p><img src="/2023/01/15/linux%E6%96%87%E4%BB%B6io/15.png" class="">   <img src="/2023/01/15/linux%E6%96%87%E4%BB%B6io/16.png" class="">     <p>以上的程序将文件test.txt的内容先映射到内存mapped_mem，然后使用printf函数将此内存区域的内容输出出来，可<br>以看到，输出的内容正是test.txt文本文件的内容。<br>以上的示例因为使用的是PROT_READ，所以只能读取文件里的内容，不能修改，如果使用PROT_WIRTE，就可以修改文件<br>的内容了。又因为使用了MMAP_PRIVATE，所以只能此进程使用此内存区域，若换用MAP_SHARED，则可以被其它进程访<br>问，如下例示：   </p><img src="/2023/01/15/linux%E6%96%87%E4%BB%B6io/17.png" class="">    <img src="/2023/01/15/linux%E6%96%87%E4%BB%B6io/18.png" class="">     <p>可以看到，我们通过对内存映射的修改，文本文件也修改成功了。   </p><h4 id="mmap和共享内存"><a href="#mmap和共享内存" class="headerlink" title="mmap和共享内存"></a>mmap和共享内存</h4><p>共享内存允许两个或者多个进程共享一个给定的存储区，因为数据不需要来回复制，所以是最快的一种进程间通讯机<br>制。共享内存可以通过mmap()映射普通文件（特殊情况下还可以采用匿名映射）机制实现，也可以通过系统V共享内<br>存机制实现。应用接口和原理很简单，内部机制复杂。为了实现更安全的通信，往往还与信号灯等同步机制共同使用<br>。对比如下：   </p><blockquote><ul><li>mmap机制：就是在硬盘上建立一个文件，每个进程存储器里面单独开辟一个空间来进行映射。如果是多进程，那<br>么对实际的物理存储器（主存）消耗不会太大。mmap保存到实际硬盘，实际存储并没有反映到主存上。优点是存储量<br>可以很大（多于主存），缺点是进程间读取和写入速度要比主存的慢。   </li><li>shm机制：每个进程的共享内存都直接映射到实际物理存储器里面。shm保存到物理存储器（主存），实际的存储<br>量直接反映到主存上。优点是进程间访问速度（读写）比磁盘要快，缺点是存储量不能非常大（多于主存）。</li></ul></blockquote><p>从使用上看，如果分配的存储量不大，就使用shm；如果存储量大，就使用mmap。</p>]]></content>
    
    
    <categories>
      
      <category>linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>文件io</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>窗口函数</title>
    <link href="/2022/11/20/%E7%AA%97%E5%8F%A3%E5%87%BD%E6%95%B0/"/>
    <url>/2022/11/20/%E7%AA%97%E5%8F%A3%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="窗口函数"><a href="#窗口函数" class="headerlink" title="窗口函数"></a>窗口函数</h2><p>窗口函数（也称为分析函数）针对一组行计算值，并为每行返回一个结果。这与聚合函数不同；聚合函数会为一组行返回一个结果。<br>窗口函数，也叫OLAP函数（Online Anallytical Processing，联机分析处理），可以对数据库数据进行实时分析处理。<br>窗口函数包含一个 OVER 子句，该子句定义了涵盖所要计算行的行窗口。对于每一行，系统会使用选定的行窗口作为输入来计算窗口函数结果，并可能进行聚合。<br>语法如下：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">&lt;窗口函数&gt; <span class="hljs-keyword">over</span> (<span class="hljs-keyword">partition</span> <span class="hljs-keyword">by</span> &lt;用于分组的列名&gt;<br>                <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> &lt;用于排序的列名&gt;)<br></code></pre></td></tr></table></figure><p>借助窗口函数，您可以计算移动平均值、对各项进行排名、计算累计总和，以及执行其他分析。<br>常用的业务场景有：部门按员工业绩排名、或者找出每个部门的topN员工等。</p><h4 id="窗口函数使用"><a href="#窗口函数使用" class="headerlink" title="窗口函数使用"></a>窗口函数使用</h4><p>窗口函数分为两种：</p><ul><li>专用窗口函数：rank, dense_rank, row_number等</li><li>聚合函数：sum. avg, count, max, min等</li></ul><ol><li>初始表数据如下<figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> student_score;<br></code></pre></td></tr></table></figure><img src="/2022/11/20/%E7%AA%97%E5%8F%A3%E5%87%BD%E6%95%B0/1.png" class=""><br><br></li><li>业务需求：各个班级独自按成绩排名<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">select</span> * ,rank()<span class="hljs-keyword">over</span>(<span class="hljs-keyword">partition</span> <span class="hljs-keyword">by</span> std_class <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> std_score <span class="hljs-keyword">desc</span>) <span class="hljs-keyword">as</span> ranking<br><span class="hljs-keyword">from</span> student_score;<br></code></pre></td></tr></table></figure>该sql语句使用partition by对班级进行分组，order by 对分组后的成绩进行排序。</li></ol><img src="/2022/11/20/%E7%AA%97%E5%8F%A3%E5%87%BD%E6%95%B0/2.png" class=""><br><br>上述业务group by和order by不易实现，因为group by分组完会改变表的行数，一行只代表一个类别，而partition by和rank是不会改变原表的行数的。    3. 其它窗口函数<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">select</span> * ,rank()<span class="hljs-keyword">over</span>(<span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> std_score <span class="hljs-keyword">desc</span>) <span class="hljs-keyword">as</span> ranking, <br>         dense_rank() <span class="hljs-keyword">over</span>(<span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> std_score <span class="hljs-keyword">desc</span>) <span class="hljs-keyword">as</span> den_ranking, <br>         row_number() <span class="hljs-keyword">over</span>(<span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> std_score <span class="hljs-keyword">desc</span>) <span class="hljs-keyword">as</span> row_num <br><span class="hljs-keyword">from</span> student_score;<br></code></pre></td></tr></table></figure><img src="/2022/11/20/%E7%AA%97%E5%8F%A3%E5%87%BD%E6%95%B0/3.png" class=""><br><br>> -  rank函数：如果有并列的名次，则排名相同，下一位置被占。> -  dense_rank函数：如果有并列的名次，则排名相同，下一位置不被占。> -  row_num函数：不考虑并列情况。<ol start="4"><li>其它聚合函数</li></ol><pre><code class="hljs">select * ,sum(std_score) over(order by std_id) as std_sum,       avg(std_score) over(order by std_id) as std_avg,       count(std_score) over(order by std_id) as std_count,       max(std_score) over(order by std_id) as std_max,       min(std_score) over(order by std_id) as std_min   from student_score;</code></pre><img src="/2022/11/20/%E7%AA%97%E5%8F%A3%E5%87%BD%E6%95%B0/4.png" class=""><br> <br>窗口函数中使用聚合函数的效果如上所示，每行的值都是截至到该行数据的一个汇总计算，不会涵盖该行以下。<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><blockquote><p>窗口函数不同于group by等，它不会改变原表的行数，且同时具有分组和排序的功能，<br>窗口是指分组过后每组的数据范围，通常窗口函数只存在于select语句中。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>sql</category>
      
    </categories>
    
    
    <tags>
      
      <tag>sql函数</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>power shell脚本命令</title>
    <link href="/2022/11/11/powershell%E8%84%9A%E6%9C%AC/"/>
    <url>/2022/11/11/powershell%E8%84%9A%E6%9C%AC/</url>
    
    <content type="html"><![CDATA[<p>最近开始支援其他项目组做一些脚本开发，记录一下。  </p><ul><li>去除输入文件的首行，重新生成新的文件：<figure class="highlight dsconfig"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dsconfig">$<span class="hljs-string">x</span> = <span class="hljs-string">Get-Content</span> -<span class="hljs-string">Path</span> <span class="hljs-string">&quot;..test.csv&quot;</span><br><span class="hljs-built_in">set-Content</span> -<span class="hljs-string">Path</span> <span class="hljs-string">&quot;..new.csv&quot;</span> -<span class="hljs-string">Value</span> ($<span class="hljs-string">x</span>[<span class="hljs-string">1</span>..($<span class="hljs-string">x</span>.<span class="hljs-string">Length-1</span>)])<br></code></pre></td></tr></table></figure></li><li>获取文件的当前路径 $PSScriptRoot</li></ul><figure class="highlight monkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs monkey"><span class="hljs-keyword">Import</span>-<span class="hljs-keyword">Module</span> ./test.ps1<span class="hljs-meta"></span><br><span class="hljs-meta"># 更改为</span><br><span class="hljs-keyword">Import</span>-<span class="hljs-keyword">Module</span> $PSScriptRoot/test.ps1<br></code></pre></td></tr></table></figure><p>这样可以避免执行脚本时必须进入脚本所在的目录，只需要在任意路径下输入脚本的绝对路径，这样脚本中其它的导入模块也会正常的被脚本读取到。</p><ul><li>将读入的csv文件转化为数组<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-variable">$csvdata</span> = <span class="hljs-selector-tag">@</span>(<span class="hljs-built_in">Import-Csv</span> <span class="hljs-variable">$csvfile</span> <span class="hljs-literal">-Encoding</span> UTF8)<br><span class="hljs-comment"># 数组长度</span><br><span class="hljs-variable">$arrsize</span> = <span class="hljs-variable">$csvdate</span>.Count<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>shell</category>
      
    </categories>
    
    
    <tags>
      
      <tag>powershell脚本</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>poi包冲突调试</title>
    <link href="/2022/11/02/poi%E5%8C%85%E5%86%B2%E7%AA%81%E8%B0%83%E8%AF%95/"/>
    <url>/2022/11/02/poi%E5%8C%85%E5%86%B2%E7%AA%81%E8%B0%83%E8%AF%95/</url>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>媳妇她们项目组在做一个老旧项目的升级移行工作，她最近主要在负责batch这块的改修，其中有一个功能是关于<br>excel生成的，之前老项目中是HSSF的导出，现在她要升级为XSSF的导出，所以得引入一些poi的包，由于导入了<br>部分新包，所以项目产生了莫名其妙的报错。</p><h2 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h2><p>由于她们的项目是很老的项目，没有使用maven管理，所以排查起来很是费劲。先是在本地建了一个maven的项目，<br>然后导入了主要的两个poi包，poi-5.2.2.jar和poi-ooxml-5.2.2.jar，查看了它们的依赖关系，锁定了需要的最<br>小依赖，写了段简略的读写测试代码，运行调试通过。最后将项目所有包导入，运行报错，试着删除和poi有依赖<br>冲突可能的包，直到测试代码可以正常运行。最后锁定了一个名为poi-2.5.1-final-20040804.jar的包，删掉此<br>包后测试代码正常执行导入导出，但是奇怪的是再次导入此包后测试代码仍然可以正常运行，以为是项目缓存<br>导致的，所以将project又clean了继续运行，然而测试代码仍然正常结束。重复了几次，发现只有在第一次导入<br>所有包时运行报错，删除poi-2.5.1-final-20040804.jar包后就正常运行，再次导入后又不会引发冲突错误，更<br>令人费解的是正式项目的引用包中是没有poi-2.5.1-final-20040804.jar的。<br><br>报错如下：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">Exception <span class="hljs-keyword">in</span> thread <span class="hljs-string">&quot;main&quot;</span> java.lang.NoSuchMethodError: org.apache.poi.util.<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">IOUtils</span>.</span></span>copy(Ljava/io/InputStream;Ljava/io/OutputStream;)J<br>at org.apache.poi.openxml4j.opc.internal.marshallers.<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ZipPartMarshaller</span>.</span></span>marshall(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ZipPartMarshaller</span>.</span></span>java:<span class="hljs-number">89</span>)<br>at org.apache.poi.openxml4j.opc.internal.<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">MemoryPackagePart</span>.</span></span>save(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">MemoryPackagePart</span>.</span></span>java:<span class="hljs-number">111</span>)<br>at org.apache.poi.openxml4j.opc.internal.marshallers.<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">DefaultMarshaller</span>.</span></span>marshall(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">DefaultMarshaller</span>.</span></span>java:<span class="hljs-number">46</span>)<br>at org.apache.poi.openxml4j.opc.<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ZipPackage</span>.</span></span>save<span class="hljs-constructor">Impl(ZipPackage.<span class="hljs-params">java</span>:584)</span><br>at org.apache.poi.openxml4j.opc.<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">OPCPackage</span>.</span></span>save(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">OPCPackage</span>.</span></span>java:<span class="hljs-number">1490</span>)<br>at org.apache.poi.ooxml.<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">POIXMLDocument</span>.</span></span>write(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">POIXMLDocument</span>.</span></span>java:<span class="hljs-number">227</span>)<br>at testlib.<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Test</span>.</span></span>main(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Test</span>.</span></span>java:<span class="hljs-number">31</span>)<br></code></pre></td></tr></table></figure><p>或者报错是关于btye[]的方法peekFirstNBtyes之类。</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>由于错误log中所报的这些方法经过跟踪确实是存在的，删掉poi-2.5.1-final-20040804.jar包也确实不再报错，所以可以<br>确定的是问题肯定出在了poi-2.5.1-final-20040804.jar这个jar包上，但是为什么只有第一次存在这个jar包引用时会出错<br>删掉再导入后又不会引发冲突，为什么正式项目中没有此包也报错？本能觉得是项目结构构筑的问题，所以就查看了关于<br>build path的详细信息，发现关于order and export的一段描述是越上层的优先级越高，而我本地的build path中的导致<br>报错的poi-2.5.1-final-20040804.jar包却在最底层，所以我将该包的优先级调为了上层又复现了之前的错误，为什么只<br>有第一次导入会导致报错，删除后重新导入就不会引发错误的问题至此已经解决，还有第二个问题是正式项目中没有此包<br>为什么也会报错，这个问题经过查看build path后发现老项目中引用了一个外部工程common，而位于顶层的common当中<br>引用了poi-2.5.1-final-20040804.jar此包，经过优先级重调，第二个问题也顺利解决。<br><br>模拟第一次报错：</p><img src="/2022/11/02/poi%E5%8C%85%E5%86%B2%E7%AA%81%E8%B0%83%E8%AF%95/1.png" class=""><br><br><br><p>删除冲突包执行成功：</p><img src="/2022/11/02/poi%E5%8C%85%E5%86%B2%E7%AA%81%E8%B0%83%E8%AF%95/2.png" class=""><img src="/2022/11/02/poi%E5%8C%85%E5%86%B2%E7%AA%81%E8%B0%83%E8%AF%95/3.png" class=""><br><br><br><p>再次导入冲突包执行依然成功：</p><img src="/2022/11/02/poi%E5%8C%85%E5%86%B2%E7%AA%81%E8%B0%83%E8%AF%95/4.png" class=""><img src="/2022/11/02/poi%E5%8C%85%E5%86%B2%E7%AA%81%E8%B0%83%E8%AF%95/5.png" class=""><img src="/2022/11/02/poi%E5%8C%85%E5%86%B2%E7%AA%81%E8%B0%83%E8%AF%95/6.png" class=""><img src="/2022/11/02/poi%E5%8C%85%E5%86%B2%E7%AA%81%E8%B0%83%E8%AF%95/7.png" class=""><img src="/2022/11/02/poi%E5%8C%85%E5%86%B2%E7%AA%81%E8%B0%83%E8%AF%95/8.png" class=""><br><br><br><p>更改引用顺序，重现错误：</p><img src="/2022/11/02/poi%E5%8C%85%E5%86%B2%E7%AA%81%E8%B0%83%E8%AF%95/9.png" class=""><img src="/2022/11/02/poi%E5%8C%85%E5%86%B2%E7%AA%81%E8%B0%83%E8%AF%95/10.png" class="">]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>jar包冲突</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>指针相等问题</title>
    <link href="/2022/11/01/%E5%88%A4%E6%96%AD%E4%B8%A4%E4%B8%AA%E6%8C%87%E9%92%88%E7%9B%B8%E7%AD%89%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/"/>
    <url>/2022/11/01/%E5%88%A4%E6%96%AD%E4%B8%A4%E4%B8%AA%E6%8C%87%E9%92%88%E7%9B%B8%E7%AD%89%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</url>
    
    <content type="html"><![CDATA[<h2 id="指针操作"><a href="#指针操作" class="headerlink" title="指针操作"></a>指针操作</h2><p>C++ Primer中关于指针操作中有一段描述是：</p><blockquote><p>对于两个类型相同的合法指针，可以用相等操作符 &#x3D;&#x3D; 或 不相等操作符 !&#x3D; 来比较它们，比较的的结果<br>是布尔类型。如果两个指针存放的地址值相同，则它们相等；反之它们不相等。这里两个指针存放的地址值相同（两个指针相等）<br>有三种可能：它们都为空、都指向同一个对象、或者都指向了同一个对象的下一地址。<br>需要注意的是:<strong>一个指针指向某对象，同时另一个指针指向另外对象的下一地址，此时也有可能出现这两个指针值相同的情况，即指针相等。</strong></p></blockquote><p>关于最后描述的同一个对象的下一地址，出现有可能相等的情况，这是因为内存的申请使用一般都是连续分配的，所以很可能出现指针运算过后指向的下一个地址和相同类型的另一指针指向的当前位置相等！具体如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br> <br>  <span class="hljs-type">int</span> a1 = <span class="hljs-number">1</span>;<br>  <span class="hljs-type">int</span> a2 = <span class="hljs-number">2</span>;<br> <br>  <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function">  </span>&#123;<br>      <span class="hljs-type">int</span>* p1 = &amp;a1;<br>      <span class="hljs-type">int</span>* p2 = &amp;a2;<br>      <span class="hljs-type">int</span>* p3;<br> <br>      std::cout&lt;&lt;<span class="hljs-string">&quot;*p1 = &quot;</span>&lt;&lt;*p1&lt;&lt;<span class="hljs-string">&quot;,地址为：p1 = &quot;</span>&lt;&lt;p1&lt;&lt;std::endl;<br>      std::cout&lt;&lt;<span class="hljs-string">&quot;*p2 = &quot;</span>&lt;&lt;*p2&lt;&lt;<span class="hljs-string">&quot;,地址为：p2 = &quot;</span>&lt;&lt;p2&lt;&lt;std::endl;<br>      p3 = ++p1;<br>      <span class="hljs-keyword">if</span>(p2 == p3)&#123;<br>      ¦   std::cout&lt;&lt;<span class="hljs-string">&quot;*p3 = &quot;</span>&lt;&lt;*p3&lt;&lt;<span class="hljs-string">&quot;,地址为：p3 = &quot;</span>&lt;&lt;p3&lt;&lt;std::endl;<br>      &#125;<br> <br>      <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  &#125;<br></code></pre></td></tr></table></figure><p>运行图如下所示：</p><img src="/2022/11/01/%E5%88%A4%E6%96%AD%E4%B8%A4%E4%B8%AA%E6%8C%87%E9%92%88%E7%9B%B8%E7%AD%89%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/bg1.png" class=""><h4 id="关于指针和引用"><a href="#关于指针和引用" class="headerlink" title="关于指针和引用"></a>关于指针和引用</h4><p>引用并非对象，它只是为一个已经存在的对象所起的别名而已，所以引用只能使用对象进行初始化(不能使用字面量初始化)，<br>引用的初始化过程并非是将对象的值拷贝给引用，而是绑定，程序将引用和它的初始值绑定在一起，一旦初始化完成，引用<br>将和它的初始值对象一直捆绑在一起，也正是因为引用无法重新解绑到另外一个对象，所以引用必须进行初始化操作！因为<br>引用不是对象，没有实际的地址，所以不能定义指向引用的指针 ！</p><p><strong>指针和引用的区别：</strong><br>指针和引用同为复合类型，都与内存中实际存在的对象有联系。指针”指向”内存中的某个对象，而引用”绑定到”内存中的某<br>个对象，它们都实现了对其他对象的间接访问，二者的区别主要有两方面：</p><p><em><strong>第一，指针本身就是一个对象，允许对指针赋值和拷贝，而且在指针的生命周期内它可以指向几个不同的对象；引用不是一<br>个对象，无法令引用重新绑定到另外一个对象。<br><br>第二，指针无须在定义时赋初值，和其他内置类型一样，在块作用域内定义的指针如果没有被初始化，也将拥有一个不确定<br>的值；引用则必须在定义时赋初值。</strong></em></p>]]></content>
    
    
    <categories>
      
      <category>C/C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>指针</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vimrc</title>
    <link href="/2022/10/24/%E4%B8%AA%E4%BA%BAvim%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/"/>
    <url>/2022/10/24/%E4%B8%AA%E4%BA%BAvim%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="配置如下"><a href="#配置如下" class="headerlink" title="配置如下"></a><center>配置如下</h1><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br></pre></td><td class="code"><pre><code class="hljs 1c"><span class="hljs-string">&quot; All system-wide defaults are set in $VIMRUNTIME/debian.vim and sourced by</span><br><span class="hljs-string">&quot; the call to :runtime you can find below.If you wish to change any of those</span><br><span class="hljs-string">&quot; settings, you should do it in this file (/etc/vim/vimrc), since debian.vim</span><br><span class="hljs-string">&quot; will be overwritten everytime an upgrade of the vim packages is performed.</span><br><span class="hljs-string">&quot; It is recommended to make changes after sourcing debian.vim since it alters</span><br><span class="hljs-string">&quot; the value of the &#x27;compatible&#x27; option.</span><br><br>runtime! debian.vim<br><br><span class="hljs-string">&quot; Vim will load $VIMRUNTIME/defaults.vim if the user does not have a vimrc.</span><br><span class="hljs-string">&quot; This happens after /etc/vim/vimrc(.local) are loaded, so it will override</span><br><span class="hljs-string">&quot; any settings in these files.</span><br><span class="hljs-string">&quot; If you don&#x27;t want that to happen, uncomment the below line to prevent</span><br><span class="hljs-string">&quot; defaults.vim from being loaded.</span><br><span class="hljs-string">&quot; let g:skip_defaults_vim = 1</span><br><br><span class="hljs-string">&quot; Uncomment the next line to make Vim more Vi-compatible</span><br><span class="hljs-string">&quot; NOTE: debian.vim sets &#x27;nocompatible&#x27;.  Setting &#x27;compatible&#x27; changes numerous</span><br><span class="hljs-string">&quot; options, so any other options should be set AFTER setting &#x27;compatible&#x27;.</span><br><span class="hljs-string">&quot;set compatible</span><br><br><span class="hljs-string">&quot; Vim5 and later versions support syntax highlighting. Uncommenting the next</span><br><span class="hljs-string">&quot; line enables syntax highlighting by default.</span><br>if has(<span class="hljs-string">&quot;syntax&quot;</span>)<br>  syntax on<br>endif<br><br><span class="hljs-string">&quot; If using a dark background within the editing area and syntax highlighting</span><br><span class="hljs-string">&quot; turn on this option as well</span><br><span class="hljs-string">&quot;set background=dark</span><br><br><span class="hljs-string">&quot; Uncomment the following to have Vim jump to the last position when</span><br><span class="hljs-string">&quot; reopening a file</span><br><span class="hljs-string">&quot;au BufReadPost * if line(&quot;</span>&#x27;\&quot;&quot;) &gt; 1 &amp;&amp; line(&quot;&#x27;\<span class="hljs-string">&quot;&quot;</span>) &lt;= line(<span class="hljs-string">&quot;$&quot;</span>) <span class="hljs-string">| exe &quot;</span>normal! g&#x27;\&quot;&quot; | endif<br><br>&quot; Uncomment the following to have Vim load indentation rules and plugins<br>&quot; according to the detected filetype.<br>&quot;filetype plugin indent on<br><br>&quot; The following are commented out as they cause vim to behave a lot<br>&quot; differently from regular Vi. They are highly recommended though.<br>&quot;set showcmd&quot; Show (partial) command in status line.<br>&quot;set showmatch&quot; Show matching brackets.<br>&quot;set ignorecase&quot; Do case insensitive matching<br>&quot;set smartcase&quot; Do smart case matching<br>&quot;set incsearch&quot; Incremental search<br>&quot;set autowrite&quot; Automatically save before commands like :next and :make<br>&quot;set hidden&quot; Hide buffers when they are abandoned<br>&quot;set mouse=a&quot; Enable mouse usage (all modes)<br><br>&quot; Source a global configuration file if available<br>if filereadable(&quot;/etc/vim/vimrc.local&quot;)<br>  source /etc/vim/vimrc.local<br>endif<br><br>&quot;个人配置==================================================================================================&gt;<br>&quot;打开文件的编码设置<br>set fileencodings=cs-bom,utf-8,utf-16,gbk,big5,gb<span class="hljs-number">1803</span>0,latin1<br>&quot;开启鼠标<br>&quot;set mouse=a <br>&quot;前缀键&lt;leader&gt;默认为\ 使用下面命令将前缀键定义为逗号<br>let mapleader=&quot;,&quot;<br>&quot;设置行号<br>set nu<br>&quot;设置缩进格式<br>set autoindent &quot;自动缩进<br>set cindent<br>set ts=4 &quot;表示一个tab在屏幕上打印多少个空格长度，默认为8<br>&quot;set softtabstop=4<br>set shiftwidth=4<br>set expandtab<br><br>&quot;set cursorcolumn<br>&quot;set cursorline<br>set hlsearch<br>hi Search term=bold,reverse cterm=bold ctermfg=15 ctermbg=2 gui=bold guifg=bg guibg=DarkGreen<br><br>&quot;设置引号和括号自动补全<br>inoremap &#x27; &#x27;&#x27;&lt;ESC&gt;i<br>inoremap <span class="hljs-string">&quot; &quot;&quot;&lt;ESC&gt;i</span><br>inoremap ( ()&lt;ESC&gt;i<br>inoremap [ []&lt;ESC&gt;i<br><span class="hljs-string">&quot;数组初始化使用补全</span><br>inoremap &#123; &#123;&#125;&lt;ESC&gt;i<br><span class="hljs-string">&quot;方法括号补全</span><br>inoremap &#123;&lt;CR&gt; &#123;&#125;&lt;ESC&gt;i&lt;CR&gt;&lt;ESC&gt;O<br><span class="hljs-string">&quot;跳出括号等</span><br>inoremap &lt;tab&gt;&lt;space&gt; &lt;ESC&gt;&lt;space&gt;a<br><span class="hljs-string">&quot;插入模式下注释当前行</span><br>inoremap <span class="hljs-comment">// &lt;ESC&gt;0i//&lt;ESC&gt;</span><br><span class="hljs-string">&quot;删除当前行注释</span><br>nnoremap &lt;leader&gt;/ <span class="hljs-number">0</span>xx<br><br><span class="hljs-string">&quot;将crtl+d映射为插入模式下的删除当前行</span><br>inoremap &lt;c-d&gt; &lt;ESC&gt;dd i<br><br><span class="hljs-string">&quot;插件管理-----------------------------------------&gt;</span><br>call plug<span class="hljs-meta">#begin(&#x27;~/.vim/plugged&#x27;)</span><br>Plug &#x27;vim-airline/vim-airline&#x27;<br>Plug &#x27;ludovicchabant/vim-gutentags&#x27;<br>Plug &#x27;ycm-core/YouCompleteMe&#x27;<br>Plug  &#x27;Yggdroot/indentLine&#x27;<br>Plug &#x27;skywind<span class="hljs-number">3000</span>/asyncrun.vim&#x27;<br>Plug &#x27;preservim/nerdtree&#x27;<br>Plug &#x27;iamcco/markdown-preview.nvim&#x27;, &#123; &#x27;do&#x27;: &#123; -&gt; mkdp<span class="hljs-meta">#util#install() &#125;, &#x27;for&#x27;: [&#x27;markdown&#x27;, &#x27;vim-plug&#x27;]&#125;</span><br><span class="hljs-string">&quot;Plug &#x27;puremourning/vimspector&#x27;</span><br><br><br>call plug<span class="hljs-meta">#end()</span><br><span class="hljs-string">&quot;-------------------------------------------------&gt;</span><br><br><span class="hljs-string">&quot;文件插件类型</span><br>filetype plugin indent on<br><br><span class="hljs-string">&quot;vim-gutentags插件设置----------------------------&gt;</span><br>set tags=./.tags;,.tags<br><span class="hljs-string">&quot;gutentags搜索工程目录的标志,碰到这些文件或者目录名就停止向上一级递归</span><br>let g:gutentags_project_root=[&#x27;.root&#x27;,&#x27;.svn&#x27;,&#x27;.git&#x27;,&#x27;.hg&#x27;,&#x27;.project&#x27;]<br><span class="hljs-string">&quot;所生成的数据的文件名称</span><br>let g:gutentags_ctags_tagfile=&#x27;.tags&#x27;<br><span class="hljs-string">&quot;将自动生成的tags文件全部放入~/.cache/tags/目录中，避免污染工程目录</span><br>let s:vim_tags=expand(&#x27;~/.cache/tags&#x27;)<br>let g:gutentags_cache_dir=s:vim_tags<br><span class="hljs-string">&quot;配置ctags的参数</span><br>let g:gutentags_ctags_extra_args=[&#x27;--fields=+niazS&#x27;,&#x27;--extra=+q&#x27;]<br>let g:gutentags_ctags_extra_args+=[&#x27;--c++-kinds=+px&#x27;]<br>let g:gutentags_ctags_extra_args+=[&#x27;--c-kinds=+px&#x27;]<br>let g:gutentags_ctags_extra_args+=[&#x27;--output-format=e-ctags&#x27;]<br><span class="hljs-string">&quot;检测~/.cache/tags,不存在就新建</span><br>if !isdirectory(s:vim_tags)<br>silent! call mkdir(s:vim_tags,&#x27;p&#x27;)<br>endif<br><br><span class="hljs-string">&quot;--------------------------------------------------&gt;</span><br><span class="hljs-string">&quot;YouCompleteMe代码补全插件设置-----------------------------------------&gt;</span><br><span class="hljs-string">&quot;设置补全窗口的背景色</span><br>highlight PMenu ctermfg=<span class="hljs-number">0</span> ctermbg=<span class="hljs-number">242</span> guifg=black guibg=darkgrey<br>highlight PMenuSel ctermfg=<span class="hljs-number">242</span> ctermbg=<span class="hljs-number">8</span> guifg=darkgrey guibg=black<br><br>let g:ycm_add_preview_to_completeopt = <span class="hljs-number">0</span><br>let g:ycm_show_diagnostics_ui = <span class="hljs-number">0</span><br>let g:ycm_server_log_level = &#x27;info&#x27;<br>let g:ycm_min_num_identifier_candidate_chars = <span class="hljs-number">2</span><br>let g:ycm_collect_identifiers_from_comments_and_strings = <span class="hljs-number">1</span><br>let g:ycm_complete_in_strings=<span class="hljs-number">1</span><br>let g:ycm_key_invoke_completion = &#x27;&lt;c-z&gt;&#x27;<br>set completeopt=menu,menuone<br><br>noremap &lt;c-z&gt; &lt;NOP&gt;<br><br>let g:ycm_semantic_triggers =  &#123;<br>\ &#x27;c,cpp,python,java,go,erlang,perl&#x27;: [&#x27;re!\w&#123;2&#125;&#x27;],<br>\ &#x27;cs,lua,javascript&#x27;: [&#x27;re!\w&#123;2&#125;&#x27;],<br>\ &#125;<br><br>let g:ycm_filetype_whitelist = &#123; <br>\ <span class="hljs-string">&quot;c&quot;</span>:<span class="hljs-number">1</span>,<br>\ <span class="hljs-string">&quot;cpp&quot;</span>:<span class="hljs-number">1</span>, <br>\ <span class="hljs-string">&quot;objc&quot;</span>:<span class="hljs-number">1</span>,<br>\ <span class="hljs-string">&quot;sh&quot;</span>:<span class="hljs-number">1</span>,<br>\ <span class="hljs-string">&quot;zsh&quot;</span>:<span class="hljs-number">1</span>,<br>\ <span class="hljs-string">&quot;zimbu&quot;</span>:<span class="hljs-number">1</span>,<br>\ &#125;<br><br><br><span class="hljs-string">&quot;-----------------------------------------------------------------------&gt;</span><br><br><span class="hljs-string">&quot;indentLine插件设置-----------------------------------------------------------------&gt;</span><br>let g:indentLine_char =  &#x27;¦&#x27;<span class="hljs-string">&quot; 设置缩进线字符，也可以为 &#x27;|&#x27;, &#x27;┆&#x27;, &#x27;┊&#x27; 等</span><br>let g:indentLine_conceallevel = <span class="hljs-number">2</span><span class="hljs-string">&quot; 使插件正常运行</span><br><br><span class="hljs-string">&quot;-----------------------------------------------------------------------------------&gt;</span><br><br><br><span class="hljs-string">&quot;asyncrun插件设置-----------------------------------------------------------------&gt;</span><br>let g:asyncrun_rootmarks = [&#x27;.svn&#x27;, &#x27;.git&#x27;, &#x27;.root&#x27;, &#x27;_darcs&#x27;, &#x27;build.xml&#x27;]<br>let g:asyncrun_open=<span class="hljs-number">10</span> <span class="hljs-string">&quot;自动打开quick window窗口，高度为10</span><br>let g:asyncrun_bell=<span class="hljs-number">1</span> <span class="hljs-string">&quot;任务结束响铃提醒</span><br><span class="hljs-string">&quot;设置F1打开关闭quickfix窗口</span><br>noremap &lt;F1&gt; :call asyncrun<span class="hljs-meta">#quickfix_toggle(6)&lt;cr&gt; </span><br><span class="hljs-string">&quot;设置F2单文件：编译(C文件)</span><br>nnoremap &lt;silent&gt; &lt;F2&gt; :AsyncRun! gcc -Wall -O2 <span class="hljs-string">&quot;$(VIM_FILEPATH)&quot;</span> -o <span class="hljs-string">&quot;$(VIM_FILEDIR)/$(VIM_FILENOEXT)&quot;</span> &lt;cr&gt;<br><span class="hljs-string">&quot;设置F3单文件：编译debug版本（C++）</span><br>nnoremap &lt;silent&gt; &lt;F3&gt; :AsyncRun! g++ -g <span class="hljs-string">&quot;$(VIM_FILEPATH)&quot;</span> -o <span class="hljs-string">&quot;$(VIM_FILEDIR)/$(VIM_FILENOEXT)&quot;</span>&lt;cr&gt;<br><span class="hljs-string">&quot;设置F4单文件：编译正常版本（C++）</span><br>nnoremap &lt;silent&gt; &lt;F4&gt; :AsyncRun! g++ -O3 <span class="hljs-string">&quot;$(VIM_FILEPATH)&quot;</span> -o <span class="hljs-string">&quot;$(VIM_FILEDIR)/$(VIM_FILENOEXT)&quot;</span>&lt;cr&gt;<br><span class="hljs-string">&quot;设置F5单文件：运行</span><br><span class="hljs-string">&quot;nnoremap &lt;silent&gt; &lt;F5&gt; :AsyncRun -raw -cwd=$(VIM_FILEDIR) \&quot;</span>$(VIM_FILEDIR)/$(VIM_FILENOEXT)<span class="hljs-string">&quot; &lt;cr&gt;</span><br>nnoremap &lt;silent&gt; &lt;F5&gt; :AsyncRun! -mode=term -pos=right -cols=<span class="hljs-number">60</span> <span class="hljs-string">&quot;$(VIM_PATHNOEXT)&quot;</span>&lt;cr&gt;<br><br><span class="hljs-string">&quot;设置F7项目：编译</span><br>nnoremap &lt;silent&gt; &lt;F7&gt; :AsyncRun! -cwd=&lt;root&gt; make &lt;cr&gt;<br><span class="hljs-string">&quot;设置F8项目：运行</span><br>nnoremap &lt;silent&gt; &lt;F8&gt; :AsyncRun! -cwd=&lt;root&gt; -raw make run &lt;cr&gt;<br><span class="hljs-string">&quot;退出运行时的终端窗口terminal</span><br>nnoremap &lt;leader&gt;w :exit&lt;cr&gt;<br><br><span class="hljs-string">&quot;--------------------------------------------------------------------------------&gt;&quot;</span><br><br><span class="hljs-string">&quot;NERDTree插件设置-----------------------------------------------------------------&gt;</span><br><span class="hljs-string">&quot;设置目录箭头</span><br>let g:NERDTreeDirArrowExpandable = &#x27;⇨⇨⇨&#x27;<br>let g:NERDTreeDirArrowCollapsible = &#x27;➤➤➤&#x27;<br><span class="hljs-string">&quot; 在 vim 启动的时候默认开启 NERDTree（autocmd 可以缩写为 au）</span><br><span class="hljs-string">&quot;autocmd VimEnter * NERDTree</span><br><span class="hljs-string">&quot;定位当前文件的位置，类似于eclipse的link with edited</span><br>nnoremap &lt;C-f&gt; :NERDTreeFind&lt;CR&gt;<br><span class="hljs-string">&quot;打开关闭目录树</span><br>nnoremap &lt;C-n&gt; :NERDTreeToggle&lt;CR&gt;<br><span class="hljs-string">&quot;如果 NERDTree 是唯一选项卡中剩下的唯一窗口，则退出 Vim</span><br>autocmd BufEnter * if tabpagenr(&#x27;$&#x27;) == <span class="hljs-number">1</span> <span class="hljs-meta">&amp;&amp; winnr(&#x27;$&#x27;) == 1 &amp;&amp; exists(&#x27;b:NERDTree&#x27;) &amp;&amp; b:NERDTree.isTabTree() | quit | endif</span><br><span class="hljs-string">&quot;如果 NERDTree 是其中唯一剩余的窗口，请关闭选项卡</span><br>autocmd BufEnter * if winnr(&#x27;$&#x27;) == <span class="hljs-number">1</span> <span class="hljs-meta">&amp;&amp; exists(&#x27;b:NERDTree&#x27;) &amp;&amp; b:NERDTree.isTabTree() | quit | endif</span><br><span class="hljs-string">&quot;关闭当前标签页</span><br>nnoremap &lt;leader&gt;c :tabc&lt;CR&gt;<br><span class="hljs-string">&quot;关闭其它标签页</span><br>nnoremap &lt;leader&gt;o :tabo&lt;CR&gt;<br><span class="hljs-string">&quot;前一个tab标签页</span><br>nnoremap &lt;leader&gt;m :tabp&lt;CR&gt;<br><span class="hljs-string">&quot;下一个标签页</span><br>nnoremap &lt;leader&gt;n :tabn&lt;CR&gt;<br><br><span class="hljs-string">&quot;---------------------------------------------------------------------------------&gt;&quot;</span><br><br><span class="hljs-string">&quot;vimspector插件设置-----------------------------------------------------------------&gt;</span><br><span class="hljs-string">&quot;F5 debugger/ Shift F5 stop debugger/ Ctrl+Shift+F5 restart debugger</span><br><span class="hljs-string">&quot;F6 pause debugger</span><br><span class="hljs-string">&quot;F9 Toggle line breakpoint on the current line</span><br><span class="hljs-string">&quot;Shift F9 Add a function breakpoint for the expression under cursor</span><br><span class="hljs-string">&quot;F10 Step Over</span><br><span class="hljs-string">&quot;F11 Step into</span><br><span class="hljs-string">&quot;Shift F11 Step out of current function scope</span><br><span class="hljs-string">&quot;let g:vimspector_enable_mappings = &#x27;VISUAL_STUDIO&#x27;</span><br><span class="hljs-string">&quot;nnoremap &lt;leader&gt;e :VimspectorReset&lt;CR&gt;</span><br><span class="hljs-string">&quot;---------------------------------------------------------------------------------&gt;&quot;</span><br><br><span class="hljs-string">&quot;vim8自带的Termdebug插件设置-----------------------------------------------------------------&gt;</span><br><span class="hljs-string">&quot;F6进入debug当前文件模式</span><br>nnoremap &lt;silent&gt; &lt;F6&gt; :packadd termdebug&lt;cr&gt;:Termdebug %:r&lt;cr&gt;<br><br><span class="hljs-string">&quot;---------------------------------------------------------------------------------&gt;&quot;</span><br><br><span class="hljs-string">&quot;vim8使用CGDB进行调试-----------------------------------------------------------------&gt;</span><br>nnoremap &lt;space&gt;cd :!cgdb %:r&lt;cr&gt;<br><span class="hljs-string">&quot;---------------------------------------------------------------------------------&gt;&quot;</span><br><br><br><span class="hljs-string">&quot;Markdownd插件设置----------------------------------------------------------------&gt;</span><br>imap &lt;C-s&gt; &lt;Plug&gt;MarkdownPreview<br><span class="hljs-string">&quot;---------------------------------------------------------------------------------&gt;&quot;</span><br><br><br><span class="hljs-string">&quot;---------------------------------------------------------------------------------&gt;&quot;</span><br><br><span class="hljs-string">&quot;---------------------------------------------------------------------------------&gt;&quot;</span><br><span class="hljs-string">&quot;====================================================================================================================&gt;</span><br><br><br></code></pre></td></tr></table></figure><img src="/2022/10/24/%E4%B8%AA%E4%BA%BAvim%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/vimrc1.png" class=""><img src="/2022/10/24/%E4%B8%AA%E4%BA%BAvim%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/vimrc2.png" class=""><img src="/2022/10/24/%E4%B8%AA%E4%BA%BAvim%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/vimrc3.png" class=""><img src="/2022/10/24/%E4%B8%AA%E4%BA%BAvim%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/vimrc4.png" class=""><img src="/2022/10/24/%E4%B8%AA%E4%BA%BAvim%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/vimrc5.png" class="">]]></content>
    
    
    <categories>
      
      <category>vim</category>
      
    </categories>
    
    
    <tags>
      
      <tag>个人配置</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
